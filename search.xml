<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>性能优化-懒加载</title>
      <link href="/2024/03/20/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
      <url>/2024/03/20/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>懒加载是一种延迟加载的技术。初始时，只加载可视区域内的目标元素，滚动页面时，动态加载可见区域的目标元素。</p><p>常见的实现方式有 <code>IntersectionObserver</code> 和 <code>scroll</code>两种，推荐使用 <code>IntersectionObserver</code>，因为他有更好的性能表现。 </p><p>下面以图片懒加载为例，看看如何实现。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list-item&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMIAAADDCAYAAADQvc6UAAABRWlDQ1BJQ0MgUHJvZmlsZQAAKJFjYGASSSwoyGFhYGDIzSspCnJ3UoiIjFJgf8LAwSDCIMogwMCcmFxc4BgQ4ANUwgCjUcG3awyMIPqyLsis7PPOq3QdDFcvjV3jOD1boQVTPQrgSkktTgbSf4A4LbmgqISBgTEFyFYuLykAsTuAbJEioKOA7DkgdjqEvQHEToKwj4DVhAQ5A9k3gGyB5IxEoBmML4BsnSQk8XQkNtReEOBxcfXxUQg1Mjc0dyHgXNJBSWpFCYh2zi+oLMpMzyhRcASGUqqCZ16yno6CkYGRAQMDKMwhqj/fAIcloxgHQqxAjIHBEugw5sUIsSQpBobtQPdLciLEVJYzMPBHMDBsayhILEqEO4DxG0txmrERhM29nYGBddr//5/DGRjYNRkY/l7////39v///y4Dmn+LgeHANwDrkl1AuO+pmgAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAwqADAAQAAAABAAAAwwAAAAD9b/HnAAAHlklEQVR4Ae3dP3PTWBSGcbGzM6GCKqlIBRV0dHRJFarQ0eUT8LH4BnRU0NHR0UEFVdIlFRV7TzRksomPY8uykTk/zewQfKw/9znv4yvJynLv4uLiV2dBoDiBf4qP3/ARuCRABEFAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghgg0Aj8i0JO4OzsrPv69Wv+hi2qPHr0qNvf39+iI97soRIh4f3z58/u7du3SXX7Xt7Z2enevHmzfQe+oSN2apSAPj09TSrb+XKI/f379+08+A0cNRE2ANkupk+ACNPvkSPcAAEibACyXUyfABGm3yNHuAECRNgAZLuYPgEirKlHu7u7XdyytGwHAd8jjNyng4OD7vnz51dbPT8/7z58+NB9+/bt6jU/TI+AGWHEnrx48eJ/EsSmHzx40L18+fLyzxF3ZVMjEyDCiEDjMYZZS5wiPXnyZFbJaxMhQIQRGzHvWR7XCyOCXsOmiDAi1HmPMMQjDpbpEiDCiL358eNHurW/5SnWdIBbXiDCiA38/Pnzrce2YyZ4//59F3ePLNMl4PbpiL2J0L979+7yDtHDhw8vtzzvdGnEXdvUigSIsCLAWavHp/+qM0BcXMd/q25n1vF57TYBp0a3mUzilePj4+7k5KSLb6gt6ydAhPUzXnoPR0dHl79WGTNCfBnn1uvSCJdegQhLI1vvCk+fPu2ePXt2tZOYEV6/fn31dz+shwAR1sP1cqvLntbEN9MxA9xcYjsxS1jWR4AIa2Ibzx0tc44fYX/16lV6NDFLXH+YL32jwiACRBiEbf5KcXoTIsQSpzXx4N28Ja4BQoK7rgXiydbHjx/P25TaQAJEGAguWy0+2Q8PD6/Ki4R8EVl+bzBOnZY95fq9rj9zAkTI2SxdidBHqG9+skdw43borCXO/ZcJdraPWdv22uIEiLA4q7nvvCug8WTqzQveOH26fodo7g6uFe/a17W3+nFBAkRYENRdb1vkkz1CH9cPsVy/jrhr27PqMYvENYNlHAIesRiBYwRy0V+8iXP8+/fvX11Mr7L7ECueb/r48eMqm7FuI2BGWDEG8cm+7G3NEOfmdcTQw4h9/55lhm7DekRYKQPZF2ArbXTAyu4kDYB2YxUzwg0gi/41ztHnfQG26HbGel/crVrm7tNY+/1btkOEAZ2M05r4FB7r9GbAIdxaZYrHdOsgJ/wCEQY0J74TmOKnbxxT9n3FgGGWWsVdowHtjt9Nnvf7yQM2aZU/TIAIAxrw6dOnAWtZZcoEnBpNuTuObWMEiLAx1HY0ZQJEmHJ3HNvGCBBhY6jtaMoEiJB0Z29vL6ls58vxPcO8/zfrdo5qvKO+d3Fx8Wu8zf1dW4p/cPzLly/dtv9Ts/EbcvGAHhHyfBIhZ6NSiIBTo0LNNtScABFyNiqFCBChULMNNSdAhJyNSiECRCjUbEPNCRAhZ6NSiAARCjXbUHMCRMjZqBQiQIRCzTbUnAARcjYqhQgQoVCzDTUnQIScjUohAkQo1GxDzQkQIWejUogAEQo121BzAkTI2agUIkCEQs021JwAEXI2KoUIEKFQsw01J0CEnI1KIQJEKNRsQ80JECFno1KIABEKNdtQcwJEyNmoFCJAhELNNtScABFyNiqFCBChULMNNSdAhJyNSiECRCjUbEPNCRAhZ6NSiAARCjXbUHMCRMjZqBQiQIRCzTbUnAARcjYqhQgQoVCzDTUnQIScjUohAkQo1GxDzQkQIWejUogAEQo121BzAkTI2agUIkCEQs021JwAEXI2KoUIEKFQsw01J0CEnI1KIQJEKNRsQ80JECFno1KIABEKNdtQcwJEyNmoFCJAhELNNtScABFyNiqFCBChULMNNSdAhJyNSiECRCjUbEPNCRAhZ6NSiAARCjXbUHMCRMjZqBQiQIRCzTbUnAARcjYqhQgQoVCzDTUnQIScjUohAkQo1GxDzQkQIWejUogAEQo121BzAkTI2agUIkCEQs021JwAEXI2KoUIEKFQsw01J0CEnI1KIQJEKNRsQ80JECFno1KIABEKNdtQcwJEyNmoFCJAhELNNtScABFyNiqFCBChULMNNSdAhJyNSiEC/wGgKKC4YMA4TAAAAABJRU5ErkJggg==&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">data-src</span>=<span class="string">&quot;http://c.hiphotos.baidu.com/image/pic/item/30adcbef76094b36de8a2fe5a1cc7cd98d109d99.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list-item&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMIAAADDCAYAAADQvc6UAAABRWlDQ1BJQ0MgUHJvZmlsZQAAKJFjYGASSSwoyGFhYGDIzSspCnJ3UoiIjFJgf8LAwSDCIMogwMCcmFxc4BgQ4ANUwgCjUcG3awyMIPqyLsis7PPOq3QdDFcvjV3jOD1boQVTPQrgSkktTgbSf4A4LbmgqISBgTEFyFYuLykAsTuAbJEioKOA7DkgdjqEvQHEToKwj4DVhAQ5A9k3gGyB5IxEoBmML4BsnSQk8XQkNtReEOBxcfXxUQg1Mjc0dyHgXNJBSWpFCYh2zi+oLMpMzyhRcASGUqqCZ16yno6CkYGRAQMDKMwhqj/fAIcloxgHQqxAjIHBEugw5sUIsSQpBobtQPdLciLEVJYzMPBHMDBsayhILEqEO4DxG0txmrERhM29nYGBddr//5/DGRjYNRkY/l7////39v///y4Dmn+LgeHANwDrkl1AuO+pmgAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAwqADAAQAAAABAAAAwwAAAAD9b/HnAAAHlklEQVR4Ae3dP3PTWBSGcbGzM6GCKqlIBRV0dHRJFarQ0eUT8LH4BnRU0NHR0UEFVdIlFRV7TzRksomPY8uykTk/zewQfKw/9znv4yvJynLv4uLiV2dBoDiBf4qP3/ARuCRABEFAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghgg0Aj8i0JO4OzsrPv69Wv+hi2qPHr0qNvf39+iI97soRIh4f3z58/u7du3SXX7Xt7Z2enevHmzfQe+oSN2apSAPj09TSrb+XKI/f379+08+A0cNRE2ANkupk+ACNPvkSPcAAEibACyXUyfABGm3yNHuAECRNgAZLuYPgEirKlHu7u7XdyytGwHAd8jjNyng4OD7vnz51dbPT8/7z58+NB9+/bt6jU/TI+AGWHEnrx48eJ/EsSmHzx40L18+fLyzxF3ZVMjEyDCiEDjMYZZS5wiPXnyZFbJaxMhQIQRGzHvWR7XCyOCXsOmiDAi1HmPMMQjDpbpEiDCiL358eNHurW/5SnWdIBbXiDCiA38/Pnzrce2YyZ4//59F3ePLNMl4PbpiL2J0L979+7yDtHDhw8vtzzvdGnEXdvUigSIsCLAWavHp/+qM0BcXMd/q25n1vF57TYBp0a3mUzilePj4+7k5KSLb6gt6ydAhPUzXnoPR0dHl79WGTNCfBnn1uvSCJdegQhLI1vvCk+fPu2ePXt2tZOYEV6/fn31dz+shwAR1sP1cqvLntbEN9MxA9xcYjsxS1jWR4AIa2Ibzx0tc44fYX/16lV6NDFLXH+YL32jwiACRBiEbf5KcXoTIsQSpzXx4N28Ja4BQoK7rgXiydbHjx/P25TaQAJEGAguWy0+2Q8PD6/Ki4R8EVl+bzBOnZY95fq9rj9zAkTI2SxdidBHqG9+skdw43borCXO/ZcJdraPWdv22uIEiLA4q7nvvCug8WTqzQveOH26fodo7g6uFe/a17W3+nFBAkRYENRdb1vkkz1CH9cPsVy/jrhr27PqMYvENYNlHAIesRiBYwRy0V+8iXP8+/fvX11Mr7L7ECueb/r48eMqm7FuI2BGWDEG8cm+7G3NEOfmdcTQw4h9/55lhm7DekRYKQPZF2ArbXTAyu4kDYB2YxUzwg0gi/41ztHnfQG26HbGel/crVrm7tNY+/1btkOEAZ2M05r4FB7r9GbAIdxaZYrHdOsgJ/wCEQY0J74TmOKnbxxT9n3FgGGWWsVdowHtjt9Nnvf7yQM2aZU/TIAIAxrw6dOnAWtZZcoEnBpNuTuObWMEiLAx1HY0ZQJEmHJ3HNvGCBBhY6jtaMoEiJB0Z29vL6ls58vxPcO8/zfrdo5qvKO+d3Fx8Wu8zf1dW4p/cPzLly/dtv9Ts/EbcvGAHhHyfBIhZ6NSiIBTo0LNNtScABFyNiqFCBChULMNNSdAhJyNSiECRCjUbEPNCRAhZ6NSiAARCjXbUHMCRMjZqBQiQIRCzTbUnAARcjYqhQgQoVCzDTUnQIScjUohAkQo1GxDzQkQIWejUogAEQo121BzAkTI2agUIkCEQs021JwAEXI2KoUIEKFQsw01J0CEnI1KIQJEKNRsQ80JECFno1KIABEKNdtQcwJEyNmoFCJAhELNNtScABFyNiqFCBChULMNNSdAhJyNSiECRCjUbEPNCRAhZ6NSiAARCjXbUHMCRMjZqBQiQIRCzTbUnAARcjYqhQgQoVCzDTUnQIScjUohAkQo1GxDzQkQIWejUogAEQo121BzAkTI2agUIkCEQs021JwAEXI2KoUIEKFQsw01J0CEnI1KIQJEKNRsQ80JECFno1KIABEKNdtQcwJEyNmoFCJAhELNNtScABFyNiqFCBChULMNNSdAhJyNSiECRCjUbEPNCRAhZ6NSiAARCjXbUHMCRMjZqBQiQIRCzTbUnAARcjYqhQgQoVCzDTUnQIScjUohAkQo1GxDzQkQIWejUogAEQo121BzAkTI2agUIkCEQs021JwAEXI2KoUIEKFQsw01J0CEnI1KIQJEKNRsQ80JECFno1KIABEKNdtQcwJEyNmoFCJAhELNNtScABFyNiqFCBChULMNNSdAhJyNSiEC/wGgKKC4YMA4TAAAAABJRU5ErkJggg==&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">data-src</span>=<span class="string">&quot;http://h.hiphotos.baidu.com/image/pic/item/7c1ed21b0ef41bd5f2c2a9e953da81cb39db3d1d.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list-item&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMIAAADDCAYAAADQvc6UAAABRWlDQ1BJQ0MgUHJvZmlsZQAAKJFjYGASSSwoyGFhYGDIzSspCnJ3UoiIjFJgf8LAwSDCIMogwMCcmFxc4BgQ4ANUwgCjUcG3awyMIPqyLsis7PPOq3QdDFcvjV3jOD1boQVTPQrgSkktTgbSf4A4LbmgqISBgTEFyFYuLykAsTuAbJEioKOA7DkgdjqEvQHEToKwj4DVhAQ5A9k3gGyB5IxEoBmML4BsnSQk8XQkNtReEOBxcfXxUQg1Mjc0dyHgXNJBSWpFCYh2zi+oLMpMzyhRcASGUqqCZ16yno6CkYGRAQMDKMwhqj/fAIcloxgHQqxAjIHBEugw5sUIsSQpBobtQPdLciLEVJYzMPBHMDBsayhILEqEO4DxG0txmrERhM29nYGBddr//5/DGRjYNRkY/l7////39v///y4Dmn+LgeHANwDrkl1AuO+pmgAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAwqADAAQAAAABAAAAwwAAAAD9b/HnAAAHlklEQVR4Ae3dP3PTWBSGcbGzM6GCKqlIBRV0dHRJFarQ0eUT8LH4BnRU0NHR0UEFVdIlFRV7TzRksomPY8uykTk/zewQfKw/9znv4yvJynLv4uLiV2dBoDiBf4qP3/ARuCRABEFAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghgg0Aj8i0JO4OzsrPv69Wv+hi2qPHr0qNvf39+iI97soRIh4f3z58/u7du3SXX7Xt7Z2enevHmzfQe+oSN2apSAPj09TSrb+XKI/f379+08+A0cNRE2ANkupk+ACNPvkSPcAAEibACyXUyfABGm3yNHuAECRNgAZLuYPgEirKlHu7u7XdyytGwHAd8jjNyng4OD7vnz51dbPT8/7z58+NB9+/bt6jU/TI+AGWHEnrx48eJ/EsSmHzx40L18+fLyzxF3ZVMjEyDCiEDjMYZZS5wiPXnyZFbJaxMhQIQRGzHvWR7XCyOCXsOmiDAi1HmPMMQjDpbpEiDCiL358eNHurW/5SnWdIBbXiDCiA38/Pnzrce2YyZ4//59F3ePLNMl4PbpiL2J0L979+7yDtHDhw8vtzzvdGnEXdvUigSIsCLAWavHp/+qM0BcXMd/q25n1vF57TYBp0a3mUzilePj4+7k5KSLb6gt6ydAhPUzXnoPR0dHl79WGTNCfBnn1uvSCJdegQhLI1vvCk+fPu2ePXt2tZOYEV6/fn31dz+shwAR1sP1cqvLntbEN9MxA9xcYjsxS1jWR4AIa2Ibzx0tc44fYX/16lV6NDFLXH+YL32jwiACRBiEbf5KcXoTIsQSpzXx4N28Ja4BQoK7rgXiydbHjx/P25TaQAJEGAguWy0+2Q8PD6/Ki4R8EVl+bzBOnZY95fq9rj9zAkTI2SxdidBHqG9+skdw43borCXO/ZcJdraPWdv22uIEiLA4q7nvvCug8WTqzQveOH26fodo7g6uFe/a17W3+nFBAkRYENRdb1vkkz1CH9cPsVy/jrhr27PqMYvENYNlHAIesRiBYwRy0V+8iXP8+/fvX11Mr7L7ECueb/r48eMqm7FuI2BGWDEG8cm+7G3NEOfmdcTQw4h9/55lhm7DekRYKQPZF2ArbXTAyu4kDYB2YxUzwg0gi/41ztHnfQG26HbGel/crVrm7tNY+/1btkOEAZ2M05r4FB7r9GbAIdxaZYrHdOsgJ/wCEQY0J74TmOKnbxxT9n3FgGGWWsVdowHtjt9Nnvf7yQM2aZU/TIAIAxrw6dOnAWtZZcoEnBpNuTuObWMEiLAx1HY0ZQJEmHJ3HNvGCBBhY6jtaMoEiJB0Z29vL6ls58vxPcO8/zfrdo5qvKO+d3Fx8Wu8zf1dW4p/cPzLly/dtv9Ts/EbcvGAHhHyfBIhZ6NSiIBTo0LNNtScABFyNiqFCBChULMNNSdAhJyNSiECRCjUbEPNCRAhZ6NSiAARCjXbUHMCRMjZqBQiQIRCzTbUnAARcjYqhQgQoVCzDTUnQIScjUohAkQo1GxDzQkQIWejUogAEQo121BzAkTI2agUIkCEQs021JwAEXI2KoUIEKFQsw01J0CEnI1KIQJEKNRsQ80JECFno1KIABEKNdtQcwJEyNmoFCJAhELNNtScABFyNiqFCBChULMNNSdAhJyNSiECRCjUbEPNCRAhZ6NSiAARCjXbUHMCRMjZqBQiQIRCzTbUnAARcjYqhQgQoVCzDTUnQIScjUohAkQo1GxDzQkQIWejUogAEQo121BzAkTI2agUIkCEQs021JwAEXI2KoUIEKFQsw01J0CEnI1KIQJEKNRsQ80JECFno1KIABEKNdtQcwJEyNmoFCJAhELNNtScABFyNiqFCBChULMNNSdAhJyNSiECRCjUbEPNCRAhZ6NSiAARCjXbUHMCRMjZqBQiQIRCzTbUnAARcjYqhQgQoVCzDTUnQIScjUohAkQo1GxDzQkQIWejUogAEQo121BzAkTI2agUIkCEQs021JwAEXI2KoUIEKFQsw01J0CEnI1KIQJEKNRsQ80JECFno1KIABEKNdtQcwJEyNmoFCJAhELNNtScABFyNiqFCBChULMNNSdAhJyNSiEC/wGgKKC4YMA4TAAAAABJRU5ErkJggg==&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">data-src</span>=<span class="string">&quot;http://g.hiphotos.baidu.com/image/pic/item/55e736d12f2eb938d5277fd5d0628535e5dd6f4a.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list-item&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMIAAADDCAYAAADQvc6UAAABRWlDQ1BJQ0MgUHJvZmlsZQAAKJFjYGASSSwoyGFhYGDIzSspCnJ3UoiIjFJgf8LAwSDCIMogwMCcmFxc4BgQ4ANUwgCjUcG3awyMIPqyLsis7PPOq3QdDFcvjV3jOD1boQVTPQrgSkktTgbSf4A4LbmgqISBgTEFyFYuLykAsTuAbJEioKOA7DkgdjqEvQHEToKwj4DVhAQ5A9k3gGyB5IxEoBmML4BsnSQk8XQkNtReEOBxcfXxUQg1Mjc0dyHgXNJBSWpFCYh2zi+oLMpMzyhRcASGUqqCZ16yno6CkYGRAQMDKMwhqj/fAIcloxgHQqxAjIHBEugw5sUIsSQpBobtQPdLciLEVJYzMPBHMDBsayhILEqEO4DxG0txmrERhM29nYGBddr//5/DGRjYNRkY/l7////39v///y4Dmn+LgeHANwDrkl1AuO+pmgAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAwqADAAQAAAABAAAAwwAAAAD9b/HnAAAHlklEQVR4Ae3dP3PTWBSGcbGzM6GCKqlIBRV0dHRJFarQ0eUT8LH4BnRU0NHR0UEFVdIlFRV7TzRksomPY8uykTk/zewQfKw/9znv4yvJynLv4uLiV2dBoDiBf4qP3/ARuCRABEFAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghgg0Aj8i0JO4OzsrPv69Wv+hi2qPHr0qNvf39+iI97soRIh4f3z58/u7du3SXX7Xt7Z2enevHmzfQe+oSN2apSAPj09TSrb+XKI/f379+08+A0cNRE2ANkupk+ACNPvkSPcAAEibACyXUyfABGm3yNHuAECRNgAZLuYPgEirKlHu7u7XdyytGwHAd8jjNyng4OD7vnz51dbPT8/7z58+NB9+/bt6jU/TI+AGWHEnrx48eJ/EsSmHzx40L18+fLyzxF3ZVMjEyDCiEDjMYZZS5wiPXnyZFbJaxMhQIQRGzHvWR7XCyOCXsOmiDAi1HmPMMQjDpbpEiDCiL358eNHurW/5SnWdIBbXiDCiA38/Pnzrce2YyZ4//59F3ePLNMl4PbpiL2J0L979+7yDtHDhw8vtzzvdGnEXdvUigSIsCLAWavHp/+qM0BcXMd/q25n1vF57TYBp0a3mUzilePj4+7k5KSLb6gt6ydAhPUzXnoPR0dHl79WGTNCfBnn1uvSCJdegQhLI1vvCk+fPu2ePXt2tZOYEV6/fn31dz+shwAR1sP1cqvLntbEN9MxA9xcYjsxS1jWR4AIa2Ibzx0tc44fYX/16lV6NDFLXH+YL32jwiACRBiEbf5KcXoTIsQSpzXx4N28Ja4BQoK7rgXiydbHjx/P25TaQAJEGAguWy0+2Q8PD6/Ki4R8EVl+bzBOnZY95fq9rj9zAkTI2SxdidBHqG9+skdw43borCXO/ZcJdraPWdv22uIEiLA4q7nvvCug8WTqzQveOH26fodo7g6uFe/a17W3+nFBAkRYENRdb1vkkz1CH9cPsVy/jrhr27PqMYvENYNlHAIesRiBYwRy0V+8iXP8+/fvX11Mr7L7ECueb/r48eMqm7FuI2BGWDEG8cm+7G3NEOfmdcTQw4h9/55lhm7DekRYKQPZF2ArbXTAyu4kDYB2YxUzwg0gi/41ztHnfQG26HbGel/crVrm7tNY+/1btkOEAZ2M05r4FB7r9GbAIdxaZYrHdOsgJ/wCEQY0J74TmOKnbxxT9n3FgGGWWsVdowHtjt9Nnvf7yQM2aZU/TIAIAxrw6dOnAWtZZcoEnBpNuTuObWMEiLAx1HY0ZQJEmHJ3HNvGCBBhY6jtaMoEiJB0Z29vL6ls58vxPcO8/zfrdo5qvKO+d3Fx8Wu8zf1dW4p/cPzLly/dtv9Ts/EbcvGAHhHyfBIhZ6NSiIBTo0LNNtScABFyNiqFCBChULMNNSdAhJyNSiECRCjUbEPNCRAhZ6NSiAARCjXbUHMCRMjZqBQiQIRCzTbUnAARcjYqhQgQoVCzDTUnQIScjUohAkQo1GxDzQkQIWejUogAEQo121BzAkTI2agUIkCEQs021JwAEXI2KoUIEKFQsw01J0CEnI1KIQJEKNRsQ80JECFno1KIABEKNdtQcwJEyNmoFCJAhELNNtScABFyNiqFCBChULMNNSdAhJyNSiECRCjUbEPNCRAhZ6NSiAARCjXbUHMCRMjZqBQiQIRCzTbUnAARcjYqhQgQoVCzDTUnQIScjUohAkQo1GxDzQkQIWejUogAEQo121BzAkTI2agUIkCEQs021JwAEXI2KoUIEKFQsw01J0CEnI1KIQJEKNRsQ80JECFno1KIABEKNdtQcwJEyNmoFCJAhELNNtScABFyNiqFCBChULMNNSdAhJyNSiECRCjUbEPNCRAhZ6NSiAARCjXbUHMCRMjZqBQiQIRCzTbUnAARcjYqhQgQoVCzDTUnQIScjUohAkQo1GxDzQkQIWejUogAEQo121BzAkTI2agUIkCEQs021JwAEXI2KoUIEKFQsw01J0CEnI1KIQJEKNRsQ80JECFno1KIABEKNdtQcwJEyNmoFCJAhELNNtScABFyNiqFCBChULMNNSdAhJyNSiEC/wGgKKC4YMA4TAAAAABJRU5ErkJggg==&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">data-src</span>=<span class="string">&quot;http://e.hiphotos.baidu.com/image/pic/item/4e4a20a4462309f7e41f5cfe760e0cf3d6cad6ee.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list-item&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMIAAADDCAYAAADQvc6UAAABRWlDQ1BJQ0MgUHJvZmlsZQAAKJFjYGASSSwoyGFhYGDIzSspCnJ3UoiIjFJgf8LAwSDCIMogwMCcmFxc4BgQ4ANUwgCjUcG3awyMIPqyLsis7PPOq3QdDFcvjV3jOD1boQVTPQrgSkktTgbSf4A4LbmgqISBgTEFyFYuLykAsTuAbJEioKOA7DkgdjqEvQHEToKwj4DVhAQ5A9k3gGyB5IxEoBmML4BsnSQk8XQkNtReEOBxcfXxUQg1Mjc0dyHgXNJBSWpFCYh2zi+oLMpMzyhRcASGUqqCZ16yno6CkYGRAQMDKMwhqj/fAIcloxgHQqxAjIHBEugw5sUIsSQpBobtQPdLciLEVJYzMPBHMDBsayhILEqEO4DxG0txmrERhM29nYGBddr//5/DGRjYNRkY/l7////39v///y4Dmn+LgeHANwDrkl1AuO+pmgAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAwqADAAQAAAABAAAAwwAAAAD9b/HnAAAHlklEQVR4Ae3dP3PTWBSGcbGzM6GCKqlIBRV0dHRJFarQ0eUT8LH4BnRU0NHR0UEFVdIlFRV7TzRksomPY8uykTk/zewQfKw/9znv4yvJynLv4uLiV2dBoDiBf4qP3/ARuCRABEFAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghgg0Aj8i0JO4OzsrPv69Wv+hi2qPHr0qNvf39+iI97soRIh4f3z58/u7du3SXX7Xt7Z2enevHmzfQe+oSN2apSAPj09TSrb+XKI/f379+08+A0cNRE2ANkupk+ACNPvkSPcAAEibACyXUyfABGm3yNHuAECRNgAZLuYPgEirKlHu7u7XdyytGwHAd8jjNyng4OD7vnz51dbPT8/7z58+NB9+/bt6jU/TI+AGWHEnrx48eJ/EsSmHzx40L18+fLyzxF3ZVMjEyDCiEDjMYZZS5wiPXnyZFbJaxMhQIQRGzHvWR7XCyOCXsOmiDAi1HmPMMQjDpbpEiDCiL358eNHurW/5SnWdIBbXiDCiA38/Pnzrce2YyZ4//59F3ePLNMl4PbpiL2J0L979+7yDtHDhw8vtzzvdGnEXdvUigSIsCLAWavHp/+qM0BcXMd/q25n1vF57TYBp0a3mUzilePj4+7k5KSLb6gt6ydAhPUzXnoPR0dHl79WGTNCfBnn1uvSCJdegQhLI1vvCk+fPu2ePXt2tZOYEV6/fn31dz+shwAR1sP1cqvLntbEN9MxA9xcYjsxS1jWR4AIa2Ibzx0tc44fYX/16lV6NDFLXH+YL32jwiACRBiEbf5KcXoTIsQSpzXx4N28Ja4BQoK7rgXiydbHjx/P25TaQAJEGAguWy0+2Q8PD6/Ki4R8EVl+bzBOnZY95fq9rj9zAkTI2SxdidBHqG9+skdw43borCXO/ZcJdraPWdv22uIEiLA4q7nvvCug8WTqzQveOH26fodo7g6uFe/a17W3+nFBAkRYENRdb1vkkz1CH9cPsVy/jrhr27PqMYvENYNlHAIesRiBYwRy0V+8iXP8+/fvX11Mr7L7ECueb/r48eMqm7FuI2BGWDEG8cm+7G3NEOfmdcTQw4h9/55lhm7DekRYKQPZF2ArbXTAyu4kDYB2YxUzwg0gi/41ztHnfQG26HbGel/crVrm7tNY+/1btkOEAZ2M05r4FB7r9GbAIdxaZYrHdOsgJ/wCEQY0J74TmOKnbxxT9n3FgGGWWsVdowHtjt9Nnvf7yQM2aZU/TIAIAxrw6dOnAWtZZcoEnBpNuTuObWMEiLAx1HY0ZQJEmHJ3HNvGCBBhY6jtaMoEiJB0Z29vL6ls58vxPcO8/zfrdo5qvKO+d3Fx8Wu8zf1dW4p/cPzLly/dtv9Ts/EbcvGAHhHyfBIhZ6NSiIBTo0LNNtScABFyNiqFCBChULMNNSdAhJyNSiECRCjUbEPNCRAhZ6NSiAARCjXbUHMCRMjZqBQiQIRCzTbUnAARcjYqhQgQoVCzDTUnQIScjUohAkQo1GxDzQkQIWejUogAEQo121BzAkTI2agUIkCEQs021JwAEXI2KoUIEKFQsw01J0CEnI1KIQJEKNRsQ80JECFno1KIABEKNdtQcwJEyNmoFCJAhELNNtScABFyNiqFCBChULMNNSdAhJyNSiECRCjUbEPNCRAhZ6NSiAARCjXbUHMCRMjZqBQiQIRCzTbUnAARcjYqhQgQoVCzDTUnQIScjUohAkQo1GxDzQkQIWejUogAEQo121BzAkTI2agUIkCEQs021JwAEXI2KoUIEKFQsw01J0CEnI1KIQJEKNRsQ80JECFno1KIABEKNdtQcwJEyNmoFCJAhELNNtScABFyNiqFCBChULMNNSdAhJyNSiECRCjUbEPNCRAhZ6NSiAARCjXbUHMCRMjZqBQiQIRCzTbUnAARcjYqhQgQoVCzDTUnQIScjUohAkQo1GxDzQkQIWejUogAEQo121BzAkTI2agUIkCEQs021JwAEXI2KoUIEKFQsw01J0CEnI1KIQJEKNRsQ80JECFno1KIABEKNdtQcwJEyNmoFCJAhELNNtScABFyNiqFCBChULMNNSdAhJyNSiEC/wGgKKC4YMA4TAAAAABJRU5ErkJggg==&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">data-src</span>=<span class="string">&quot;http://b.hiphotos.baidu.com/image/pic/item/9d82d158ccbf6c81b94575cfb93eb13533fa40a2.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list-item&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMIAAADDCAYAAADQvc6UAAABRWlDQ1BJQ0MgUHJvZmlsZQAAKJFjYGASSSwoyGFhYGDIzSspCnJ3UoiIjFJgf8LAwSDCIMogwMCcmFxc4BgQ4ANUwgCjUcG3awyMIPqyLsis7PPOq3QdDFcvjV3jOD1boQVTPQrgSkktTgbSf4A4LbmgqISBgTEFyFYuLykAsTuAbJEioKOA7DkgdjqEvQHEToKwj4DVhAQ5A9k3gGyB5IxEoBmML4BsnSQk8XQkNtReEOBxcfXxUQg1Mjc0dyHgXNJBSWpFCYh2zi+oLMpMzyhRcASGUqqCZ16yno6CkYGRAQMDKMwhqj/fAIcloxgHQqxAjIHBEugw5sUIsSQpBobtQPdLciLEVJYzMPBHMDBsayhILEqEO4DxG0txmrERhM29nYGBddr//5/DGRjYNRkY/l7////39v///y4Dmn+LgeHANwDrkl1AuO+pmgAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAwqADAAQAAAABAAAAwwAAAAD9b/HnAAAHlklEQVR4Ae3dP3PTWBSGcbGzM6GCKqlIBRV0dHRJFarQ0eUT8LH4BnRU0NHR0UEFVdIlFRV7TzRksomPY8uykTk/zewQfKw/9znv4yvJynLv4uLiV2dBoDiBf4qP3/ARuCRABEFAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghgg0Aj8i0JO4OzsrPv69Wv+hi2qPHr0qNvf39+iI97soRIh4f3z58/u7du3SXX7Xt7Z2enevHmzfQe+oSN2apSAPj09TSrb+XKI/f379+08+A0cNRE2ANkupk+ACNPvkSPcAAEibACyXUyfABGm3yNHuAECRNgAZLuYPgEirKlHu7u7XdyytGwHAd8jjNyng4OD7vnz51dbPT8/7z58+NB9+/bt6jU/TI+AGWHEnrx48eJ/EsSmHzx40L18+fLyzxF3ZVMjEyDCiEDjMYZZS5wiPXnyZFbJaxMhQIQRGzHvWR7XCyOCXsOmiDAi1HmPMMQjDpbpEiDCiL358eNHurW/5SnWdIBbXiDCiA38/Pnzrce2YyZ4//59F3ePLNMl4PbpiL2J0L979+7yDtHDhw8vtzzvdGnEXdvUigSIsCLAWavHp/+qM0BcXMd/q25n1vF57TYBp0a3mUzilePj4+7k5KSLb6gt6ydAhPUzXnoPR0dHl79WGTNCfBnn1uvSCJdegQhLI1vvCk+fPu2ePXt2tZOYEV6/fn31dz+shwAR1sP1cqvLntbEN9MxA9xcYjsxS1jWR4AIa2Ibzx0tc44fYX/16lV6NDFLXH+YL32jwiACRBiEbf5KcXoTIsQSpzXx4N28Ja4BQoK7rgXiydbHjx/P25TaQAJEGAguWy0+2Q8PD6/Ki4R8EVl+bzBOnZY95fq9rj9zAkTI2SxdidBHqG9+skdw43borCXO/ZcJdraPWdv22uIEiLA4q7nvvCug8WTqzQveOH26fodo7g6uFe/a17W3+nFBAkRYENRdb1vkkz1CH9cPsVy/jrhr27PqMYvENYNlHAIesRiBYwRy0V+8iXP8+/fvX11Mr7L7ECueb/r48eMqm7FuI2BGWDEG8cm+7G3NEOfmdcTQw4h9/55lhm7DekRYKQPZF2ArbXTAyu4kDYB2YxUzwg0gi/41ztHnfQG26HbGel/crVrm7tNY+/1btkOEAZ2M05r4FB7r9GbAIdxaZYrHdOsgJ/wCEQY0J74TmOKnbxxT9n3FgGGWWsVdowHtjt9Nnvf7yQM2aZU/TIAIAxrw6dOnAWtZZcoEnBpNuTuObWMEiLAx1HY0ZQJEmHJ3HNvGCBBhY6jtaMoEiJB0Z29vL6ls58vxPcO8/zfrdo5qvKO+d3Fx8Wu8zf1dW4p/cPzLly/dtv9Ts/EbcvGAHhHyfBIhZ6NSiIBTo0LNNtScABFyNiqFCBChULMNNSdAhJyNSiECRCjUbEPNCRAhZ6NSiAARCjXbUHMCRMjZqBQiQIRCzTbUnAARcjYqhQgQoVCzDTUnQIScjUohAkQo1GxDzQkQIWejUogAEQo121BzAkTI2agUIkCEQs021JwAEXI2KoUIEKFQsw01J0CEnI1KIQJEKNRsQ80JECFno1KIABEKNdtQcwJEyNmoFCJAhELNNtScABFyNiqFCBChULMNNSdAhJyNSiECRCjUbEPNCRAhZ6NSiAARCjXbUHMCRMjZqBQiQIRCzTbUnAARcjYqhQgQoVCzDTUnQIScjUohAkQo1GxDzQkQIWejUogAEQo121BzAkTI2agUIkCEQs021JwAEXI2KoUIEKFQsw01J0CEnI1KIQJEKNRsQ80JECFno1KIABEKNdtQcwJEyNmoFCJAhELNNtScABFyNiqFCBChULMNNSdAhJyNSiECRCjUbEPNCRAhZ6NSiAARCjXbUHMCRMjZqBQiQIRCzTbUnAARcjYqhQgQoVCzDTUnQIScjUohAkQo1GxDzQkQIWejUogAEQo121BzAkTI2agUIkCEQs021JwAEXI2KoUIEKFQsw01J0CEnI1KIQJEKNRsQ80JECFno1KIABEKNdtQcwJEyNmoFCJAhELNNtScABFyNiqFCBChULMNNSdAhJyNSiEC/wGgKKC4YMA4TAAAAABJRU5ErkJggg==&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">data-src</span>=<span class="string">&quot;http://e.hiphotos.baidu.com/image/pic/item/4bed2e738bd4b31c1badd5a685d6277f9e2ff81e.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>小细节优化</strong><br>给<code>src</code>属性添加一张默认占位图（如果有使用组件库的话可以用骨架组件），体验上更加友好。</p><h3 id="IntersectionObserver"><a href="#IntersectionObserver" class="headerlink" title="IntersectionObserver"></a>IntersectionObserver</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> io = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(callback, [option]);</span><br></pre></td></tr></table></figure><p>callback 是可见性变化时的回调函数，option 是配置对象。</p><pre><code>相比 `scroll`，性能更好：    - 节流处理：用户快速滚动页面，也只会触发少量的回调    - 异步处理：回调函数是由浏览器在适当的时机（requestIdleCallback）调用的，不会阻塞页面渲染和用户交互    - 跨线程处理：观察过程由浏览器内部线程完成，不会阻塞主线程    - 精准度高：能够精准地检测目标元素和文档视口之间的交叉状态判断目标元素是否在是视野内的逻辑简单，根据 item.isInterSection 布尔值判断即可</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> lazyImages = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;img[data-src]&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">    <span class="attr">root</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">rootMargin</span>: <span class="string">&quot;0px&quot;</span>,</span><br><span class="line">    <span class="attr">threshold</span>: <span class="number">0.1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> loadImage = <span class="keyword">function</span>(<span class="params">image</span>) &#123;</span><br><span class="line">    image.<span class="property">src</span> = image.<span class="property">dataset</span>.<span class="property">src</span>;</span><br><span class="line">    image.<span class="title function_">removeAttribute</span>(<span class="string">&quot;data-src&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(<span class="keyword">function</span>(<span class="params">entries, observer</span>) &#123;</span><br><span class="line">    entries.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">entry</span>) &#123;</span><br><span class="line">        <span class="comment">// isIntersecting是一个Boolean值，判断目标元素当前是否可见</span></span><br><span class="line">        <span class="keyword">if</span> (entry.<span class="property">isIntersecting</span>) &#123;</span><br><span class="line">            <span class="title function_">loadImage</span>(entry.<span class="property">target</span>);</span><br><span class="line">            <span class="comment">// 图片加载后即停止监听该元素</span></span><br><span class="line">            observer.<span class="title function_">unobserve</span>(entry.<span class="property">target</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, options);</span><br><span class="line"></span><br><span class="line">lazyImages.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">image</span>) &#123;</span><br><span class="line">    observer.<span class="title function_">observe</span>(image);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="scroll（不推荐）"><a href="#scroll（不推荐）" class="headerlink" title="scroll（不推荐）"></a>scroll（不推荐）</h3><pre><code>scroll 事件频繁触发，可能会影响页面的性能和用户体验判断目标元素是否在视野内的计算麻烦</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">lazyload</span> () &#123;</span><br><span class="line">    <span class="keyword">const</span> lazyImages = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;.lazy[data-src]&quot;</span>);    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历检查所有懒加载图片</span></span><br><span class="line">    lazyImages.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">img</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> rect = img.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line">        <span class="keyword">if</span> (rect.<span class="property">top</span> &gt;= <span class="number">0</span> &amp;&amp; rect.<span class="property">bottom</span> &lt;= <span class="variable language_">window</span>.<span class="property">innerHeight</span>) &#123;</span><br><span class="line">          img.<span class="property">src</span> = img.<span class="title function_">getAttribute</span>(<span class="string">&quot;data-src&quot;</span>);</span><br><span class="line">          img.<span class="title function_">removeAttribute</span>(<span class="string">&quot;data-src&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无未加载图片时，移除相关事件监听</span></span><br><span class="line">    <span class="keyword">if</span>(lazyImages.<span class="property">length</span> == <span class="number">0</span>) &#123; </span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot;scroll&quot;</span>, lazyload);</span><br><span class="line">      <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot;resize&quot;</span>, lazyload);</span><br><span class="line">      <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot;orientationChange&quot;</span>, lazyload);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加事件监听</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;scroll&quot;</span>, lazyload);</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;resize&quot;</span>, lazyload);</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;orientationChange&quot;</span>, lazyload);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>懒加载是一种动态加载技术，只有当目标元素进入视野时才会去加载目标元素。通常的实现方法有两种，<code>scroll</code>和<code>IntersectionObserver</code>，监听 scroll 事件，会频繁触发回调函数，可能会造成页面卡顿，性能上和用户体验上不好。IntersectionObserver 利用 requestIdelCallback 在程序空闲时调用回调函数，异步处理，不会阻塞页面渲染和用户交互，还能够精准检测目标元素和文档视口之间的可见性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发环境代理 proxy</title>
      <link href="/2024/03/16/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%BB%A3%E7%90%86-proxy/"/>
      <url>/2024/03/16/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%BB%A3%E7%90%86-proxy/</url>
      
        <content type="html"><![CDATA[<p>前端项目本地开发过程中，常常会遇到跨域问题，这是因为我们的本地服务域名为<code>localhost</code>，而后端服务一般都是在后端服务器上，所以两个不同的域名之间通信就会存在跨域，严谨点来说是受同源策略的影响。</p><p>假设后端的完整 api 路径：<code>https://pruduct.com/api/chat/user/list</code>，前端在<code>localhost</code>下想要去访问这个api</p><p>有个重要的前提是，<strong>后端需要在响应头设置<code>&#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;</code></strong> ，该属性表示允许任何的源都有权限访问资源，<code>*</code>表示通配符。<br>如果后端没有设置这个属性，就算前端设置了本地代理<code>proxy</code>也是无法成功访问的。</p><p>后端设置了<code>Access-Control-Allow-Origin</code>后，其实本地可以不需要proxy也不会产生跨域问题，因为已经允许了任何源都有权限访问。</p><p>下面这个示例直接写死baseURL发起请求，不会跨域：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://pruduct.com&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">request</span>(<span class="string">&#x27;/api/chat/user/list&#x27;</span>)</span><br></pre></td></tr></table></figure><p>那什么场景需要使用<code>proxy</code>代理呢？<br></p><p>以下场景，<code>proxy</code>就派上了用场：</p><ul><li>想在本地调用&#x2F;打包不同环境的数据，不想手动修改 request baseURL</li><li>本地需要同时调用多个服务（测试环境&#x2F;正式环境，可能还有一些第三方环境）的接口，写死 <code>baseURL</code>无法满足要求</li></ul><p>来看下如何使用<code>proxy</code>解决这两个问题</p><h3 id="脚本调用-打包不同服务"><a href="#脚本调用-打包不同服务" class="headerlink" title="脚本调用&#x2F;打包不同服务"></a>脚本调用&#x2F;打包不同服务</h3><p>如果不想手动修改 request baseURL，可以通过脚本调用不同的环境变量来实现，假如环境变量为<code>API_BASE_URL</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="variable constant_">API_BASE_URL</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cross-env UMI_ENV=test max dev&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dev:online&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cross-env UMI_ENV=online max dev&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .umirc.online.ts 生产环境配置文件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">define</span>: &#123;</span><br><span class="line">    <span class="attr">API_BASE_URL</span>: <span class="string">&#x27;https://pruduct.com&#x27;</span>, <span class="comment">// 正式环境</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .umirc.test.ts 测试环境配置文件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">define</span>: &#123;</span><br><span class="line">    <span class="attr">API_BASE_URL</span>: <span class="string">&#x27;https://test.com&#x27;</span>, <span class="comment">// 测试环境</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="同时调用多个服务"><a href="#同时调用多个服务" class="headerlink" title="同时调用多个服务"></a>同时调用多个服务</h3><p>就好比想同时请求两个服务时，<code>/api/user</code>这个接口在<code>https://pruduct.com</code>下，<code>/test/user</code>在<code>https://test.com</code>下，本地代理就派上用场了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="attr">proxy</span>: &#123;</span><br><span class="line">  <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">    <span class="attr">target</span>: <span class="string">&#x27;https://pruduct.com&#x27;</span>,</span><br><span class="line">    <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;/test&#x27;</span>: &#123;</span><br><span class="line">    <span class="attr">target</span>: <span class="string">&#x27;https://test.com&#x27;</span>,</span><br><span class="line">    <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="proxy-怎么用"><a href="#proxy-怎么用" class="headerlink" title="proxy 怎么用"></a>proxy 怎么用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">API_BASE_URL</span>=<span class="string">&#x27;https://pruduct.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件发起请求</span></span><br><span class="line"><span class="keyword">const</span> request = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> apiUrl = <span class="string">&#x27;/api/user&#x27;</span></span><br><span class="line"><span class="title function_">request</span>(apiUrl)</span><br><span class="line"></span><br><span class="line"><span class="attr">proxy</span>: &#123;</span><br><span class="line">  <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">    <span class="attr">target</span>: <span class="variable constant_">API_BASE_URL</span>,</span><br><span class="line">    <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发起<code>/api/user</code>请求时，匹配到proxy对象的路径<code>/api</code>后，那么实际请求地址为<code>target + /api/user</code>，即 <code>https://pruduct.com + /api/user</code></p><p>应该有部分人以为 proxy 匹配路径必须是后端定义的，其实不是。<br>假设前端想自定义路径，或者说后端没有统一的路径，那么就可以自定义匹配路径</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">API_BASE_URL</span>=<span class="string">&#x27;https://pruduct.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件发起请求</span></span><br><span class="line"><span class="title function_">request</span>(<span class="string">&#x27;/customApiPrefix/api/user&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="attr">proxy</span>: &#123;</span><br><span class="line">  <span class="string">&#x27;/customApiPrefix&#x27;</span>: &#123;</span><br><span class="line">    <span class="attr">target</span>: <span class="variable constant_">API_BASE_URL</span>,</span><br><span class="line">    <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 重写匹配的字段，如果不想出现在请求路径上，可以重写为&quot;&quot;</span></span><br><span class="line">    <span class="attr">pathRewrite</span>: &#123; <span class="string">&quot;^/customApiPrefix&quot;</span>: <span class="string">&quot;&quot;</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际请求地址还是为<code>https://pruduct.com + /api/user</code></p><p>小结：<br>开发过程中出现跨域是因为受同源策略的约束影响，<code>localhost</code>不能与后端服务通信，想要通信，后端需要设置允许请求的源<code>&#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;</code>。设置<code>&#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;</code>后，如果后端服务只有一个，可以写死<code>baseUrl</code>无需proxy。如果有多个服务，那么通过<code>proxy</code>和环境变量的配置，可以让我们在开发或打包时更方便。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 项目场景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css padding-top 实现自适应容器的宽高比例保持一致</title>
      <link href="/2024/03/16/css-padding-top-%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E8%87%AA%E9%80%82%E5%BA%94%E5%AE%BD%E9%AB%98%E6%AF%94%E4%BE%8B/"/>
      <url>/2024/03/16/css-padding-top-%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E8%87%AA%E9%80%82%E5%BA%94%E5%AE%BD%E9%AB%98%E6%AF%94%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p>默认情况下，当我们想要设置一个容器的宽高比为一个固定比例时，通常需要固定其中一个属性（例如宽度或高度）的数值（以像素为单位），然后根据期望的比例计算另一个属性的数值。然而，这种方法存在一个问题：容器的尺寸不会自动适应。为了实现自适应，我们需要将容器的宽度设置为百分比，通过 JavaScript 得到宽度的固定值，然后通过比例计算高度属性的固定数值（以像素为单位）。</p><p>有没有一种方法可以在保持容器自适应的同时保持宽高比呢？这就是 CSS 中 <code>padding-top</code> 和 <code>padding-bottom</code> 属性的用武之地。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img-container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.img-container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="built_in">calc</span>(<span class="number">9</span> / <span class="number">16</span> * <span class="number">100%</span>); <span class="comment">/* 16:9 的比例。如果是 9:16 的比例，将分子和分母互换位置 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码示例中，我们给容器元素添加了 <code>padding-top: calc(9 / 16 * 100%)</code>，而不是直接设置高度，从而实现了容器的高度根据宽高比例自动调整的效果。</p><p>相较于使用 JavaScript 来计算宽高，<code>padding-top</code> 属性更为方便，而且性能更高。</p><p>这种方法通常用于图片或视频需要完全填充父容器的场景。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.img-container</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="built_in">calc</span>(<span class="number">9</span> / <span class="number">16</span> * <span class="number">100%</span>); <span class="comment">/* 16:9 的比例。如果是 9:16 的比例，将分子和分母互换位置 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.img</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img-container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;img&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://img1.baidu.com/it/u=1571454416,119170533&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=889&amp;h=500&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>容器占位，更好的用户体验</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;img&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://img1.baidu.com/it/u=1571454416,119170533&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=889&amp;h=500&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，当图片尚未加载到页面上时，<code>&lt;div&gt;你好&lt;/div&gt;</code> 将出现在顶部位置。但是，当图片加载完成后，<code>&lt;div&gt;你好&lt;/div&gt;</code> 将被顶到图片后面，这可能会给用户带来不良的视觉体验。</p><p>通过使用 <code>padding-top</code> 和 <code>padding-bottom</code> 技巧，我们可以确保容器的位置被保留，后续元素也不会被顶到。这将提升用户的整体体验。</p>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascritp 双精度浮点数 精度问题</title>
      <link href="/2024/03/02/javascritp-%E5%8F%8C%E7%B2%BE%E5%BA%A6%E6%B5%AE%E7%82%B9%E6%95%B0-%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98/"/>
      <url>/2024/03/02/javascritp-%E5%8F%8C%E7%B2%BE%E5%BA%A6%E6%B5%AE%E7%82%B9%E6%95%B0-%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><a name="Jfg8D"></a></p><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>今天遇到一个问题，场景如下：<br />后端返回一个 uuid 为 <code>1763118905011392500</code> ，我带 <code>1763118905011392500</code> 去查数据时，接口报错提示： <code>uuid 不存在</code>，我问后端怎么回事，后端查了一下这个 uuid，发现数据库确实不存在值为 <code>1763118905011392500</code> 的 uuid。</p><p>谷歌了一下，发现是 <strong>javascript 使用双精度浮点数表示数字，最大安全整数是 2^53 - 1 ，即 9007199254740991</strong>。<br /></p><p>浏览器中可以接收的值的大小取决于浏览器的 javascript 引擎的实现。大多数浏览器都遵循 javascript 标准。<br /></p><p>当浏览器接收到大于最大安全整数的值时，超出这个范围的整数值将会失去精度，可能会被舍入。<br /></p><p>也就是说，后端给我的值大于 2^53-1 ，浏览器将丢失精度的值保存了下来，前端将丢失精度的值传递给后端去查询数据时，那必然找不到该值。</p><p>找到了原因后，接下来了解下 <strong>双精度浮点数</strong> ，以及如何解决这个问题。<br><a name="F37SD"></a></p><h1 id="双精度浮点数"><a href="#双精度浮点数" class="headerlink" title="双精度浮点数"></a>双精度浮点数</h1><p>浮点数是什么？</p><blockquote><p>在 JavaScript 中，浮点数是一种用于表示小数的数据类型。浮点数采用 IEEE 754 标准表示，通常被称为双精度浮点数，即使用 64 位（8 字节）来表示一个浮点数。这意味着无论数字的大小如何，它们在内存中占用的空间都是相同的，即 64 位或者 8 个字节。<br>这种格式可以表示小数（小数是指非整数的有理数，其中包含了小数点及其后面的数字部分）部分，而不仅仅是整数部分，因此可以用来存储小数值。</p></blockquote><p>双精度浮点数是什么？</p><blockquote><p>双精度浮点数是一种用于表示实数的数字表示方法，它在计算机科学中被广泛使用。它的名称中的“双精度”表示它的存储空间是单精度浮点数(32 位)的两倍，因此可以存储更大范围和更高精度的数字。<br>具体来说，双精度浮点数使用 64 位（8 字节）来存储一个数字，这 64 位被划分为三部分：</p><ol><li>符号位（1 位）：用于表示数字的正负。</li><li>指数部分（11 位）：用于表示数字的指数部分，决定了数字的数量级。</li><li>尾数部分（52 位）：用于表示数字的小数部分，决定了数字的精度。</li></ol><p>在科学计数法中，一个数字通常表示为 M × 10^E 的形式，其中 M 是尾数（即小数部分），E 是指数（表示这个数需要移动的小数点位数）</p></blockquote><p>64 位（8 字节）是什么意思？</p><blockquote><p>64 位（8 字节）是指在计算机中用来表示数据的一种存储方式。它表示一个数据单元占用的存储空间大小。具体来说，64 位意味着这个数据单元可以存储 64 位二进制数字，即包含了 64 个二进制位。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Bit</span>-比特 <span class="title class_">Byte</span>-字节 <span class="variable constant_">KB</span>-千字节 <span class="variable constant_">MB</span>-兆字节 <span class="variable constant_">GB</span>-吉字节 <span class="variable constant_">TB</span>-太字节</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="title class_">Byte</span> = <span class="number">8</span> <span class="title class_">Bits</span></span><br><span class="line"><span class="number">1</span> <span class="variable constant_">GM</span> = <span class="number">1024</span> <span class="variable constant_">MB</span></span><br><span class="line"><span class="number">1</span> <span class="variable constant_">TB</span> = <span class="number">1024</span> <span class="variable constant_">GB</span></span><br><span class="line"></span><br><span class="line">一个二进制位的大小称为一比特，也就是最小单位</span><br></pre></td></tr></table></figure><p><a name="OrLuV"></a></p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>js 有没有什么办法可以表示大于 2^53 - 1 的数呢？有的，就是 BigInt 类型，它可以表示任意大的整数。</p><p>要表示 2^53，可以直接使用 BigInt 类型的字面量赋值，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bigIntNumber = <span class="number">2n</span> ** <span class="number">53n</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bigIntNumber); <span class="comment">// 输出：9007199254740992n</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> bigIntNumber); <span class="comment">// &#x27;bigint&#x27;</span></span><br></pre></td></tr></table></figure><p>这里的 <strong>2n</strong> 表示一个 BigInt 数字 2，<strong>**</strong> 表示幂运算符，<strong>53n</strong> 表示一个 BigInt 数字 53。</p><p>但在因为 Java 原生不支持 BitInt 类型，所以不能使用 BitInt 来处理。</p><p>所以解决方案有以下两种：</p><ol><li>将 uuid 改为 2^53-1 下的值，也就是小于等于 15 位数</li><li>或者将 uuid 字符串化，如<code>&#39;1763118905011392500&#39;</code><br><a name="JO3vL"></a></li></ol><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>js 标准中，使用双精度浮点数表示数字，最大安全整数为 2^53 - 1。js number 类型无法精准表示超出最大安全数的值，可用 BigInt 类型表示。如果后端给的数值超出最大安全值，可以采用”字符串化”方案，解决前后端交互时精度丢失的问题。</p><p>思考：<br />3 和 99 占用的存储空间大小一样吗？</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx+pm2 部署项目</title>
      <link href="/2024/02/27/Nginx-pm2-%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/"/>
      <url>/2024/02/27/Nginx-pm2-%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p>继续 Nginx 入门章节，本章主要讲解基本的 nginx 文件配置和启动一个 nodejs 服务。其中涉及到前端资源存放，环境域名配置、默认端口处理等。</p><p>如果顺利，我们将可以访问 <a href="http://138.128.222.180/">http://138.128.222.180/</a>。如果使用域名，则还需要备案才能访问 <a href="http://www.weilunaichat.xyz/">http://www.weilunaichat.xyz</a>。</p><p><a name="fFSlz"></a></p><h1 id="网站域名配置"><a href="#网站域名配置" class="headerlink" title="网站域名配置"></a>网站域名配置</h1><p>简单介绍下，申请个域名，添加一个记录集，将域名指向 IP 地址，也就是指向存放前端资源文件的服务器 IP 地址。<br>如果使用域名，还需要进行备案才能进行访问。</p><p>备案：todo</p><h1 id="nginx-配置文件"><a href="#nginx-配置文件" class="headerlink" title="nginx 配置文件"></a>nginx 配置文件</h1><p>编辑 nginx 配置文件，使用 http 默认端口号 80 作为网站访问地址的端口号。也就是说，如果我们使用 80 端口 server 块配置资源，页面访问时 url 则不需要带上端口。<br><br />第一段 location 代码块中，<code>root</code>设置为前端资源文件所在路径，<code>index</code>设置为 html 文件名<br />第二段 location，<code>proxy_pass</code>设置为后端服务地址</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">  <span class="attribute">server_name</span>  localhost; // 这里可以使用域名</span><br><span class="line"></span><br><span class="line">  <span class="section">location</span> / &#123;</span><br><span class="line">    <span class="attribute">root</span>   html/frontend/chatgpt-web;// 目录位置，相对于Nginx的安装目录</span><br><span class="line">    <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    <span class="comment"># try_files  $uri $uri/    /index.html;// 如果是history路由，需要匹配兜底文件</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="section">location</span> /api &#123;</span><br><span class="line">      <span class="comment"># 反向代理，代理本机器3002端口</span></span><br><span class="line">      <span class="comment"># 如果有其他服务，就指向其他服务</span></span><br><span class="line">      <span class="attribute">proxy_pass</span> <span class="number">127.0.0.1:3002</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="UbCxt"></a></p><h1 id="启动-nginx"><a href="#启动-nginx" class="headerlink" title="启动 nginx"></a>启动 nginx</h1><p>进入 nginx 安装目录下的 sbin 目录，并执行 nginx 文件，即执行<code>./nginx</code><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-27/pic.1709045583924.png" alt="pic.1709045583924"></p><p>没有任何提示就表示启动成功了。此时已经可以访问 <a href="http://138.128.222.180/">http://124.70.17887.156</a><br><a name="BC28o"></a></p><h1 id="启动后端服务"><a href="#启动后端服务" class="headerlink" title="启动后端服务"></a>启动后端服务</h1><p>本地开发时，我们启动项目时，会启动 localhost 作为本地服务器。那么，想要在服务器上启动服务，我们需要在服务器上安装启动服务的工具，再执行启动脚本即可。</p><p>以启动后端 nodejs 服务来说，先在服务器上安装 nodejs，再执行启动服务脚本<br><a name="OWG8y"></a></p><h2 id="安装-nodejs"><a href="#安装-nodejs" class="headerlink" title="安装 nodejs"></a>安装 nodejs</h2><p>第一步仍然需要下载对应的二进制文件：<br /><br><code>wget -c https://nodejs.org/dist/v18.16.0/node-v18.16.0-linux-x64.tar.xz</code><br /><br>提取文件：<br /><br><code>tar -xvf node-v18.16.0-linux-x64.tar.xz</code><br /><br>解压之后得到的文件夹就是已经安装好的 Nodejs 了，为了方便我们可以把它重命名一下（在这里我把它放到了<br /><br>用户根目录下面的 app 的文件夹里，你也可以换成其他路径）：<br /><br><code>mv node-v18.16.0-linux-x64 ~/app/nodejs</code><br /><br>然而，这种方式安装的 Nodejs 并不完美。首先，Nodejs 的命令 node 和 npm 并不能在全局使用。为了解决这个问题，我们需要建立两个软链接：<br /><br><code>sudo ln -s ~/app/nodejs/bin/node /usr/local/bin/node</code><br /><br><code>sudo ln -s ~/app/nodejs/bin/npm /usr/local/bin/npm</code><br /><br>其中，~&#x2F;app&#x2F;nodejs 是我们刚才安装的 Nodejs 的路径，在建立软链接的时候要注意区别。<br /><br>现在，node 和 npm 可以在全局使用了，同样输入命令 node -v 来检查 Nodejs 是否安装成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">v18.16.0         # 出现了对应的版本号信息，说明安装成功</span><br></pre></td></tr></table></figure><p>还有一个问题，在 npm 下全局安装的模块无法直接在 bash 中执行。例如，我们要在 npm 中安装 pnpm：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g pnpm</span><br><span class="line">$ pnpm</span><br><span class="line">bash: pnpm: command not found...</span><br></pre></td></tr></table></figure><p>为了解决这个问题，我们需要在 Linux 上手动配置环境变量。编辑 &#x2F;etc&#x2F;profile 文件：<br />sudo vi &#x2F;etc&#x2F;profile<br />在文件的底部，添加下面两行代码：<br /><code>export NODE_HOME=~/app/nodejs/bin</code><br /><code>export PATH=$NODE_HOME:$PATH</code><br />跟刚才一样，~&#x2F;app&#x2F;nodejs 是我们安装的 Nodejs 的路径。<br />现在，npm 全局安装的模块也可以使用了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pnpm -v</span><br><span class="line">8.15.3</span><br></pre></td></tr></table></figure><p>至此，Nodejs 的安装已经顺利完成，我们可以在服务器上对 Nodejs 为所欲为了！<br><a name="tvxBV"></a></p><h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><p>执行启动脚本，<code>pnpm start</code><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-27/pic.1709532090132.png" alt="pic.1709532090132"></p><p>接口也可以访问了<br /><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-27/pic.1709532156349.png" alt="pic.1709532156349"></p><p>现在可以通过域名访问了，但是还是存在一个问题，就是我们刚才执行的 pnpm start 命令，必须打开命令行才有效，一旦关闭命令行，进程也终止了。这时候可以借助 pm2 来解决这个问题。<br><a name="tLS3h"></a></p><h2 id="pm2"><a href="#pm2" class="headerlink" title="pm2"></a>pm2</h2><p>PM2 是一个用于管理 Node.js 应用程序的生产过程的流行工具，可以用它部署 运行 监控 应用。<br />安装：<code>npm i pm2 -g</code></p><p><strong>介绍</strong><br />进入项目所在目录，执行如下命令启动 node 服务：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 start npm --name yourName -- run server</span><br></pre></td></tr></table></figure><ul><li><code>pm2 start</code>: 这是 PM2 的命令，用于启动一个 Node.js 应用。</li><li><code>npm</code>: 这是 Node.js 的包管理器，用于管理 JavaScript 包和依赖项。</li><li><code>--name yourName</code>: 这是一个可选的参数，用于指定应用程序的名称。在这里，您可以将”yourName”替换为您的应用程序的实际名称。</li><li><code>--</code> : 这是一个分隔符，它告诉 npm 后面的内容是要传递给 npm 的命令。</li><li><code>run server</code>: 这是 npm 的子命令，它告诉 npm 运行名为”server”的脚本。通常，”server”是一个在<strong>package.json</strong>文件中定义的脚本名称。例如，如果您的<strong>package.json</strong>文件包含以下内容：</li></ul><p>对于我们的 nodejs 服务，启动脚本为<code>pnpm start</code>，如果我们使用 pm2 来启动的话，就执行<code>pm2 start pnpm --name chatgpt-web-server -- run start</code><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-27/pic.1709045710219.png" alt="pic.1709045710219"><br>成功了，现在就算我们关闭了终端，nodejs 服务也会一直启动着。<br><a name="KlRJo"></a></p><h2 id="pm2-常用命令"><a href="#pm2-常用命令" class="headerlink" title="pm2 常用命令"></a>pm2 常用命令</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 list</span><br><span class="line">$ pm2 show app_name</span><br><span class="line">$ pm2 start app_name</span><br><span class="line">$ pm2 stop app_name</span><br><span class="line">$ pm2 delete app_name</span><br><span class="line">$ pm2 restart app_name</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx安装和启动</title>
      <link href="/2024/02/27/Nginx%E5%AE%89%E8%A3%85%E5%92%8C%E5%90%AF%E5%8A%A8/"/>
      <url>/2024/02/27/Nginx%E5%AE%89%E8%A3%85%E5%92%8C%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>nginx 是一个轻量 web 服务器。<br><a name="iRU1S"></a></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>查看服务器是什么系统</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure><p>我是 Linux 系统，可使用 yum 软件包管理器</p><p>第一步：先安装 PCRE pcre-devel 和 Zlib，配置 nginx 的时候会用到这两个东西</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y pcre pcre-devel</span><br><span class="line">yum install -y zlib zlib-devel</span><br></pre></td></tr></table></figure><p>第二步：安装 nginx1.18.0</p><ol><li>下载 nginx 文件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -c https://nginx.org/download/nginx-1.18.0.tar.gz</span><br></pre></td></tr></table></figure><p>Linux 系统中的 wget 是一个下载文件的工具</p><ol start="2"><li>解压并进入 nginx 目录</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf nginx-1.18.0.tar.gz</span><br><span class="line">cd nginx-1.18.0</span><br></pre></td></tr></table></figure><ol start="3"><li>使用 nginx 的默认配置</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure><ol start="4"><li>编译安装</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>nginx 已经安装完成了</p><p>查找 nginx 安装路径：<br /><br><code>whereis nginx</code><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-27/pic.1709045302233.png" alt="pic.1709045302233"></p><p>启动 nginx 服务器。进入 nginx 安装目录下的 sbin 目录，并执行 nginx 文件，即执行<code>./nginx</code><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-27/pic.1709045387708.png" alt="pic.1709045387708"></p><p><br />没有任何提示就表示启动成功了。访问机器 ip，如果显示 welcome to nginx 则表示 nginx 运行成功了。<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-27/pic.1709045415961.png" alt="pic.1709045415961"></p><p>如果还无法访问服务器 ip 地址，以我的华为云服务器为例，还需要添加安全组规则。http 协议默认 80 端口（https 默认端口为 443），我们添加一个 80 端口：<br /><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-27/pic.1709045483441.png" alt="pic.1709045483441"></p><p>添加后即可成功访问 nginx 欢迎页面。</p><p>查看配置文件目录。这个语句也可以验证 nginx.conf 文件是否正确。正确的格式会提示 test is successful</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./nginx -t</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-27/pic.1709045506823.png" alt="pic.1709045506823"><br><a name="hN0ts"></a></p><h1 id="nginx-常用命令"><a href="#nginx-常用命令" class="headerlink" title="nginx 常用命令"></a>nginx 常用命令</h1><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">查看Nginx安装位置</span><br><span class="line">  <span class="attribute">whereis</span> nginx</span><br><span class="line">常见位置：</span><br><span class="line">  /etc/nginx/conf</span><br><span class="line">  /usr/local/etc/nginx</span><br><span class="line">  /opt/homebrew/etc/nginx</span><br><span class="line"></span><br><span class="line">启动</span><br><span class="line">  启动代码格式：nginx安装目录地址 -c nginx配置文件地址</span><br><span class="line">  /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line">  ./nginx</span><br><span class="line">没有任何提示消息就表示成功了</span><br><span class="line"></span><br><span class="line">查看Nginx进程</span><br><span class="line">  ps -ef|grep nginx</span><br><span class="line">master 是主进程（唯一），worker是工作进程</span><br><span class="line"></span><br><span class="line">查看端口情况</span><br><span class="line">  lsof -i:<span class="number">80</span></span><br><span class="line">-i:<span class="number">80</span> 表示只看<span class="number">80</span>端口</span><br><span class="line"></span><br><span class="line">杀死进程</span><br><span class="line">kill -QUIT pid</span><br><span class="line"></span><br><span class="line">Nginx停止或重启。进入nginx可执行目录sbin下，输入以下命令</span><br><span class="line">  ./nginx -s signal</span><br><span class="line">    quit:优雅停止</span><br><span class="line">    stop:立即停止</span><br><span class="line">    reload:重载配置文件</span><br><span class="line">    reopen:重新打开日志文件</span><br></pre></td></tr></table></figure><p><a href="https://segmentfault.com/a/1190000012297511">https://segmentfault.com/a/1190000012297511</a><br /><a href="https://bbs.huaweicloud.com/blogs/304663">https://bbs.huaweicloud.com/blogs/304663</a><br /><a href="https://www.cnblogs.com/ghzjm/p/10677599.html">https://www.cnblogs.com/ghzjm/p/10677599.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么需要虚拟DOM</title>
      <link href="/2024/02/27/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%99%9A%E6%8B%9FDOM/"/>
      <url>/2024/02/27/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%99%9A%E6%8B%9FDOM/</url>
      
        <content type="html"><![CDATA[<p>先说结论：</p><ol><li>操作真实 DOM 的代价是巨大的</li><li>虚拟 DOM 为框架自动优化 DOM 操作提供了可能<br><a name="oPnEI"></a></li></ol><h1 id="什么是虚拟-DOM"><a href="#什么是虚拟-DOM" class="headerlink" title="什么是虚拟 DOM"></a>什么是虚拟 DOM</h1><p>以 JS 的形式描述真实的 DOM 结构。<br><a name="TmIz1"></a></p><h1 id="操作真实-DOM-存在什么问题"><a href="#操作真实-DOM-存在什么问题" class="headerlink" title="操作真实 DOM 存在什么问题"></a>操作真实 DOM 存在什么问题</h1><p>从浏览器内核结构来说，在内存中，DOM 模块独占一块内存，这和 JS 引擎所管理的内存并无直接关系，<strong>也就是说 JS 引擎不能直接操作真实 DOM 树</strong>。<br />为了给 JS 提供操作 DOM 树的能力，浏览器在全局对象上为 JS 封装了一个<code>document</code>对象，该对象上封装了大量操作 DOM 的接口，这些接口都是 c++实现的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">document</span>.<span class="title function_">getElementById</span>();</span><br></pre></td></tr></table></figure><p>当我们调用这个函数时，JS 引擎没有直接和 DOM 操作交互，而是由浏览器来操作 DOM，再由浏览器把操作结果返回给 JS 引擎。所以我们说操作真实 DOM 的代价是比较大的（还涉及到 c++和 javascript 数据结构转换的问题）。<br><a name="DiFgX"></a></p><h1 id="早期模板引擎-EJS-存在的问题"><a href="#早期模板引擎-EJS-存在的问题" class="headerlink" title="早期模板引擎(EJS)存在的问题"></a>早期模板引擎(EJS)存在的问题</h1><p>模板引擎的思想，让我们只需要关注数据层的变化。但是还存在以下问题：</p><ul><li>每次数据变化都是重新渲染整个列表视图</li><li>当数据量巨大时，性能不尽人意<br><a name="TvJpN"></a></li></ul><h1 id="虚拟-DOM-解决了什么问题"><a href="#虚拟-DOM-解决了什么问题" class="headerlink" title="虚拟 DOM 解决了什么问题"></a>虚拟 DOM 解决了什么问题</h1><p>为了解决模板引擎的问题，虚拟 DOM 出生了。<br />既然模板解决方案每次数据变化都是重新渲染整个列表视图，那只操作变化部分的 DOM 不就好了。既然操作真实 DOM 性能损耗巨大，那操作假的不就好了。<br />对比下：</p><ul><li>模板引擎的渲染：数据 + 模板 –&gt; 直接渲染为真实 DOM –&gt; 挂载至页面</li><li>虚拟 DOM 的渲染：数据 + 模板 –&gt; 虚拟 DOM –&gt; 真实 DOM –&gt; 挂载至页面<br><a name="pUjbV"></a></li></ul><h1 id="虚拟-DOM-带来的好处"><a href="#虚拟-DOM-带来的好处" class="headerlink" title="虚拟 DOM 带来的好处"></a>虚拟 DOM 带来的好处</h1><ul><li>页面性能的提升：只处理变化的 DOM，减少操作真实 DOM 的次数</li><li>开发效率的提升：react 中的 jsx、vue 模板语法</li><li>跨平台得以实现：一份代码，多端使用</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-this.setState是同步还是异步的</title>
      <link href="/2024/02/27/react-this-setState%E6%98%AF%E5%90%8C%E6%AD%A5%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84/"/>
      <url>/2024/02/27/react-this-setState%E6%98%AF%E5%90%8C%E6%AD%A5%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<ol><li>如果需要依赖更新后的值，如果是<code>classComponent</code>，我们可以在<code>componentDidUpdate</code>中执行，或者<code>this.setState</code>的第二个参数。如果是<code>functionComponent</code>，我们可以在<code>useEffect</code>中执行</li><li>不同模式下的 react，这个答案是不一样的</li></ol><p>本文讨论第二点<br><a name="T0WCw"></a></p><h1 id="react-的三种模式："><a href="#react-的三种模式：" class="headerlink" title="react 的三种模式："></a>react 的三种模式：</h1><ul><li><code>legacy</code>，react 当前使用的模式，<code>ReactDOM.render</code></li><li><code>blocking</code>，开启部分<code>concurrent</code>模式特性的中间模式</li><li><code>concurrent</code>，react v18 启用。<code>任务中断/任务优先级</code>都是针对<code>concurrent</code>模式<br><a name="KXE85"></a></li></ul><h2 id="lagecy-模式"><a href="#lagecy-模式" class="headerlink" title="lagecy 模式"></a>lagecy 模式</h2><p>lagecy 模式下，<code>this.setState</code>触发的更新是异步的。因为它会命中<code>batchedUpdates</code>函数。<br><a name="QBwZk"></a></p><h3 id="batchedUpdates"><a href="#batchedUpdates" class="headerlink" title="batchedUpdates"></a>batchedUpdates</h3><p><strong>定义:</strong><br />batchedUpdates 表示批处理，<strong>react 会将多次</strong><code>**this.setState**</code><strong>合并为一次更新，并异步执行</strong>。这样只会触发一次<code>render函数</code>，以此提高性能。</p><p><strong>实现：</strong><br /><code>fn</code>：包含<code>this.setState</code>的函数，比如点击事件、生命周期等。<br />react 内部有个<code>batchedUpdates</code> 函数，在执行这个<code>fn</code>之前，会给全局变量<code>executionContext</code>附加上<code>BatchedContex</code>这个 flag</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">batchedUpdates</span>(<span class="params">fn, a</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> prevExecutionContext = executionContext;</span><br><span class="line">  executionContext |= <span class="title class_">BatchedContext</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fn</span>(a);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    executionContext = prevExecutionContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (executionContext === <span class="title class_">NoContext</span>) &#123;</span><br><span class="line">      <span class="title function_">resetRenderTimer</span>();</span><br><span class="line">      <span class="title function_">flushSyncCallbackQueue</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后它会执行这个 fn，执行完之后，会把<code>BatchedContex</code>从<code>executionContext</code>去除。</p><p><strong>如果全局变量</strong><code>executionContext</code><strong>包含了</strong><code>BatchedContext</code><strong>，他就会认为这是一次批处理</strong>。批处理中的<code>setState</code>会被合并为一次更新。<br />以 <strong>classComponent</strong> 为例<br />例子一：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">PureComponent</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">MyClassCmp</span> <span class="keyword">extends</span> <span class="title class_ inherited__">PureComponent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onAdd</span> = <span class="variable language_">this</span>.<span class="property">onAdd</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onAdd</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span> &#125;);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span> &#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;after&quot;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>); <span class="comment">// 输入 0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;componentDidMount&quot;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>); <span class="comment">// 输出 1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; count &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        count: &#123;count&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.onAdd&#125;</span>&gt;</span>add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>onAdd</code>中调用<code>this.setState</code>，会被认为是批处理，并不能马上获取到最新的<code>count</code>。可以在<code>componentDidUpdate</code>钩子中或者<code>this.setState</code>的第二个参数中获取到最新值。<br><a name="aqmHq"></a></p><h3 id="如何跳出batchedUpdates"><a href="#如何跳出batchedUpdates" class="headerlink" title="如何跳出batchedUpdates"></a>如何跳出<code>batchedUpdates</code></h3><p>如果<code>fn</code>中触发的<code>this.setState</code>是异步执行的话，等<code>this.setState</code>执行的时候，全局的<code>executionContext</code>就已经不存在<code>BatchedContext</code>，他就会跳出批处理。<br />跳出批处理后，每次调度更新都会执行<code>scheduleUpdateOnFiber</code>函数，函数内部有段逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// react V &lt; 18</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">scheduleUpdateOnFiber</span>(<span class="params">fiber, lane, eventTime</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (lane === <span class="title class_">SyncLane</span>) &#123;</span><br><span class="line">    <span class="comment">// 省略其他代码...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (executionContext === noContext) &#123;</span><br><span class="line">      <span class="title function_">flushSyncCallbackQueue</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里不用关心，只是单纯了解下18版本源码</span></span><br><span class="line"><span class="comment">// react V18</span></span><br><span class="line"><span class="comment">// flushSyncCallbacksOnlyInLegacyMode 命名更语义化了</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">scheduleUpdateOnFiber</span>(<span class="params">fiber, lane, eventTime</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    lane === <span class="title class_">SyncLane</span> &amp;&amp;</span><br><span class="line">    executionContext === <span class="title class_">NoContext</span> &amp;&amp;</span><br><span class="line">    (fiber.<span class="property">mode</span> &amp; <span class="title class_">ConcurrentMode</span>) === <span class="title class_">NoMode</span> &amp;&amp; <span class="comment">// Treat `act` as if it&#x27;s inside `batchedUpdates`, even in legacy mode.</span></span><br><span class="line">    !<span class="title class_">ReactCurrentActQueue</span>$1.<span class="property">isBatchingLegacy</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// Flush the synchronous work now, unless we&#x27;re already working or inside</span></span><br><span class="line">    <span class="comment">// a batch. This is intentionally inside scheduleUpdateOnFiber instead of</span></span><br><span class="line">    <span class="comment">// scheduleCallbackForFiber to preserve the ability to schedule a callback</span></span><br><span class="line">    <span class="comment">// without immediately flushing it. We only do this for user-initiated</span></span><br><span class="line">    <span class="comment">// updates, to preserve historical behavior of legacy mode.</span></span><br><span class="line">    <span class="title function_">resetRenderTimer</span>();</span><br><span class="line">    <span class="title function_">flushSyncCallbacksOnlyInLegacyMode</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，如果<code>executionContext</code>什么都没有的话，会执行<code>fulshSyncCallbackQueue</code>函数，同步的执行这次更新。</p><p>例子二：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">onAdd () &#123;</span><br><span class="line">  <span class="comment">// this.setState(&#123; count: this.state.count+1 &#125;)</span></span><br><span class="line">  <span class="comment">// this.setState(&#123; count: this.state.count+1 &#125;)</span></span><br><span class="line">  <span class="comment">// console.log(&#x27;after&#x27;, this.state.count); // 输入 0</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>+<span class="number">1</span> &#125;)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>+<span class="number">1</span> &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;after&#x27;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>); <span class="comment">// 输入 2</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;componentDidMount&#x27;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>); <span class="comment">// 输出两次： 1 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="mdjkl"></a></p><h2 id="concurrent-模式"><a href="#concurrent-模式" class="headerlink" title="concurrent 模式"></a>concurrent 模式</h2><p>将<code>ReactDOM.render(&lt;App /&gt;, rootNode)</code>变为为<code>ReactDOM.createRoot(rootNode).render(&lt;App /&gt;)</code>，这样就切换到了<code>concurrent</code> 模式下。<br /><code>concurrent</code>模式下，例子一的表现结果与<code>laecy</code>模式一致。<br />例子二，after 的输出 从<code>2</code>变为<code>0</code>，<code>componentDidMount</code>里的输出两次<code>1和2</code> 变为输出一次<code>1</code>，这是为什么呢？</p><p>这是因为，执行<code>scheduleUpdateOnFiber</code>函数的前提是本次更新的优先级是同步的优先级<code>lane === SyncLane</code>。那什么是同步的优先级呢，也就是<code>ReactDOM.render</code>创建的应用的更新都是同步的优先级，而<code>concurrent</code>模式创建的应用有不同的优先级，所以不会命中<code>fulshSyncCallbackQueue</code>，即同步的更新。<br><a name="IcwUq"></a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>lagecy 模式命中 <code>batchedUpdates</code>时异步</li><li>lagecy 模式未命中<code>batchedUpdates</code>时同步</li><li>concurrent 模式都是异步</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react更新流程</title>
      <link href="/2024/02/27/react%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B/"/>
      <url>/2024/02/27/react%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>我们了解了 react 的<code>Scheduler-Reconciler-Renderer</code>架构体系</p><ul><li><code>Scheduler</code>负责任务的优先级调度</li><li><code>Reconciler</code>工作的工作阶段被称为<code>render</code>阶段。因为在该阶段会调用<code>render</code>方法</li><li><code>Renderer</code>工作的阶段被称为<code>commit</code>阶段。<code>commit</code>阶段会把<code>render</code>阶段提交的信息渲染到页面上。</li></ul><p>前面已经介绍了<code>render阶段</code>和<code>commit阶段</code>。<code>render阶段</code>完成后会进入<code>commit阶段</code>，而<code>render阶段</code>之前就是<code>触发状态更新阶段</code>。<br><a name="AHUoR"></a></p><h1 id="render-阶段前阶段"><a href="#render-阶段前阶段" class="headerlink" title="render 阶段前阶段"></a>render 阶段前阶段</h1><p>状态更新的整个调用路径的关键节点：<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-27/20240227111159.png"><br><a name="PsSqU"></a></p><h2 id="触发状态更新"><a href="#触发状态更新" class="headerlink" title="触发状态更新"></a>触发状态更新</h2><p>在 react 中，有以下方法可以触发状态更新：</p><ul><li>this.setState</li><li>this.focusUpdate</li><li>ReactDOM.render</li><li>useState</li><li>useReducer</li></ul><p>每次触发状态更新都会走一遍<code>render阶段前阶段-&gt;render阶段-&gt;commit阶段</code>这个流程。<br><a name="HYVHi"></a></p><h2 id="创建-Update-对象"><a href="#创建-Update-对象" class="headerlink" title="创建 Update 对象"></a>创建 Update 对象</h2><p>在<code>react</code>中，有多种触发状态更新的方法，他们是如何保持同一套<strong>状态更新机制</strong>呢？<br />每次<code>状态更新</code>都会创建一个保存<strong>更新状态相关内容</strong>的对象，我们叫他<code>Update</code>。在<code>render阶段</code>会根据<code>Update</code>计算新的<code>state</code>。<br><a name="ZNorx"></a></p><h2 id="从-fiber-到-root，得到-rootFiber"><a href="#从-fiber-到-root，得到-rootFiber" class="headerlink" title="从 fiber 到 root，得到 rootFiber"></a>从 fiber 到 root，得到 rootFiber</h2><p>这个阶段，<code>触发状态更新的fiber</code>上已经包含了<code>Update</code>对象。<br />我们知道，<code>render阶段</code>是从<code>rootFiber</code>开始向下遍历。那么如何从<code>触发状态更新的fiber</code>得到<code>rootFiber</code>呢？<br />答案是：调用<code>markUpdateLaneFromFiberToRoot</code><br />这个方法的工作：从<code>触发状态更新的fiber</code>一直向上遍历到<code>rootFiber</code>，得到<code>rootFiber</code>，并返回<code>rootFiber</code><br><a name="gb8ym"></a></p><h2 id="调度更新"><a href="#调度更新" class="headerlink" title="调度更新"></a>调度更新</h2><p>现在我们拥有了一个<code>rootFiber</code>，该<code>rootFiber</code>对应的<code>fiber树</code>中的某个<code>fiber节点</code>包含一个<code>Update</code>。接下来通知<code>Scheduler</code>根据<strong>更新的优先级</strong>，决定以<strong>同步</strong>还是<strong>异步</strong>的方式调度本次更新。<br />调用的方法是<code>ensureRootIsScheduled</code>。<br />这个方法会根据<code>优先级</code>调度回调函数执行，这里调度的回调函数为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">performSyncWorkOnRoot.<span class="title function_">bind</span>(<span class="literal">null</span>, root); <span class="comment">// 同步的回调函数</span></span><br><span class="line">performConcurrentWorkOnRoot.<span class="title function_">bind</span>(<span class="literal">null</span>, root); <span class="comment">// 异步的回调函数</span></span><br></pre></td></tr></table></figure><p>这个回调函数也是<code>render阶段</code>的入口函数。<br><a name="zr5cy"></a></p><h1 id="render-阶段"><a href="#render-阶段" class="headerlink" title="render 阶段"></a>render 阶段</h1><p>同步或异步调度本次更新，根据 rootFiber 得到 fiber 树<br><a name="F6bDe"></a></p><h1 id="commit-阶段"><a href="#commit-阶段" class="headerlink" title="commit 阶段"></a>commit 阶段</h1><p>副作用对应的<code>DOM操作</code>在 commit 阶段执行。<br />执行 DOM 操作前：</p><ul><li>处理<code>DOM节点</code>渲染后的<code>autoFocus/blur</code>逻辑</li><li>会调用<code>getSnapshotBeforeUpdate</code>，能在操作 DOM 前捕获 DOM 信息（如滚动位置）</li><li>异步调度<code>useEffect</code></li></ul><p>执行 DOM 操作：</p><ul><li>通过一次插入 DOM 操作将整颗<code>DOM树</code>插入页面。</li><li>执行<code>useEffect、useLayoutEffect</code>销毁函数</li><li>会调用<code>componentWillUnmount</code></li><li>解绑 ref</li></ul><p>执行 DOM 操作后：</p><ul><li>会调用<code>useLayoutEffect</code>的<code>回调函数</code></li><li>调度<code>useEffect</code>，在<code>Layout阶段</code>完成后再异步执行<code>useEffect</code>的<code>回调函数</code></li><li>调用<code>this.setState</code>的第二个参数<code>回调函数</code></li></ul><p><code>useLayoutEffect</code>从上一次更新的<code>销毁函数</code>调用到本次更新的<code>回调函数</code>调用是同步执行的。<br />而<code>useEffect</code>则需要先调用，在<code>Layout阶段</code>完成后再异步执行。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redux+ts</title>
      <link href="/2024/02/27/redux+ts/"/>
      <url>/2024/02/27/redux+ts/</url>
      
        <content type="html"><![CDATA[<p>安装<code>redux</code>、<code>react-redux</code>、<code>@reduxjs/toolkit</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; configureStore &#125; <span class="keyword">from</span> <span class="string">&quot;@reduxjs/toolkit&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> userSliceReducer <span class="keyword">from</span> <span class="string">&quot;./userSlice&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">configureStore</span>(&#123;</span><br><span class="line">  <span class="attr">reducer</span>: &#123;</span><br><span class="line">    <span class="attr">user</span>: userSliceReducer,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 store 本身推断出 `RootState` 和 `AppDispatch` 类型</span></span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">RootState</span> = <span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> store.<span class="property">getState</span>&gt;;</span><br><span class="line"><span class="comment">// 推断出类型: &#123;posts: PostsState, comments: CommentsState, users: UsersState&#125;</span></span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">AppDispatch</span> = <span class="keyword">typeof</span> store.<span class="property">dispatch</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure><p>定义 useDispatch, useSelector hook 类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store/hooks.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">TypedUseSelectorHook</span>, useDispatch, useSelector &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> type &#123; <span class="title class_">RootState</span>, <span class="title class_">AppDispatch</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./index&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在整个应用程序中使用，而不是简单的 `useDispatch` 和 `useSelector`</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">useAppDispatch</span>: <span class="function">() =&gt;</span> <span class="title class_">AppDispatch</span> = useDispatch;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">useAppSelector</span>: <span class="title class_">TypedUseSelectorHook</span>&lt;<span class="title class_">RootState</span>&gt; = useSelector;</span><br></pre></td></tr></table></figure><p>创建一个 reducer</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createSlice &#125; <span class="keyword">from</span> <span class="string">&quot;@reduxjs/toolkit&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">RootState</span>, <span class="title class_">AppDispatch</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./index&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userSlice = <span class="title function_">createSlice</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;user&quot;</span>,</span><br><span class="line">  <span class="attr">initialState</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">123</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">reducers</span>: &#123;</span><br><span class="line">    <span class="attr">incremented</span>: <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// Redux Toolkit 允许在 reducers 中编写 &quot;mutating&quot; 逻辑。</span></span><br><span class="line">      <span class="comment">// 它实际上并没有改变 state，因为使用的是 Immer 库，检测到“草稿 state”的变化并产生一个全新的</span></span><br><span class="line">      <span class="comment">// 基于这些更改的不可变的 state。</span></span><br><span class="line">      state.<span class="property">value</span> += <span class="number">1</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">decremented</span>: <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">      state.<span class="property">value</span> -= <span class="number">1</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> &#123; incremented, decremented &#125; = userSlice.<span class="property">actions</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">selectCount</span> = (<span class="params">state: RootState</span>) =&gt; state.<span class="property">user</span>.<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> userSlice.<span class="property">reducer</span>;</span><br></pre></td></tr></table></figure><p>组件使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useAppSelector, useAppDispatch &#125; <span class="keyword">from</span> <span class="string">&quot;@/store/hooks&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> count = <span class="title function_">useAppSelector</span>(<span class="function">(<span class="params">state</span>) =&gt;</span> state.<span class="property">user</span>.<span class="property">value</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;count: &quot;</span>, count);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react组件中的共享变量</title>
      <link href="/2024/02/27/react%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F/"/>
      <url>/2024/02/27/react%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Feature.tsx</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> react;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义全局变量</span></span><br><span class="line"><span class="keyword">let</span> pageNumber = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Feature</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onLoadMore</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setLoading</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="title function_">setListData</span>(</span><br><span class="line">      data.<span class="title function_">concat</span>(</span><br><span class="line">        [...<span class="keyword">new</span> <span class="title class_">Array</span>(pageSize)].<span class="title function_">map</span>(<span class="function">() =&gt;</span> (&#123;</span><br><span class="line">          <span class="attr">createdAt</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">          <span class="attr">uri</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">          <span class="attr">loading</span>: <span class="literal">true</span>,</span><br><span class="line">        &#125;)),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">    pageNumber++;</span><br><span class="line"></span><br><span class="line">    request.<span class="title function_">get</span>(list, &#123; pageNumber, pageSize &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;onLoadMore&#125;</span>&gt;</span>加载更多<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Feature</span>;</span><br></pre></td></tr></table></figure><p>当前文件中，我们在 Feature 函数前面定义了一个<code>pageNumber</code>变量，每次调用<code>onLoadMore</code>则<code>pageNumber++</code>，这个逻辑在当前页面没有问题。<br />当我们离开这个组件，下次重新进入时，<code>pageNumber</code>的值不是预期的<code>1</code>，而是<code>1+onLoadMore的调用次数</code>。也就是说<code>Feature函数</code>前定义的变量，不会随<code>Feature函数</code>的销毁而销毁。</p><p>而且这个变量是被所有 <code>Feature</code>组件共享的。</p><p>参考： <a href="https://zh-hans.react.dev/learn/referencing-values-with-refs#fix-debouncing">https://zh-hans.react.dev/learn/referencing-values-with-refs#fix-debouncing</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hooks-useLayoutEffect</title>
      <link href="/2024/02/27/Hooks-useLayoutEffect/"/>
      <url>/2024/02/27/Hooks-useLayoutEffect/</url>
      
        <content type="html"><![CDATA[<p>在 <code>useEffect</code> 环节已经知道，useEffect 会在 DOM 渲染之后执行，也就是在下一轮事件循环中执行。<br />而<code>useLayoutEffect</code>的回调函数，会在渲染之前执行，也就是会在 DOM 变更之后同步的触发重新渲染。</p><p>该 Demo 中我们点击页面中的数字，再在<code>useLayoutEffect</code>回调中变为随机数。但在页面上数字不会变为 0，而是直接变为新的随机数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useLayoutEffect, useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./styles.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useLayoutEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> randomNum = <span class="number">10</span> + <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> now = performance.<span class="title function_">now</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (performance.<span class="title function_">now</span>() - now &lt; <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="title function_">setCount</span>(randomNum);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [count]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(0)&#125;&gt;&#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果把<code>useLayoutEffect</code>换成<code>useEffect</code>，页面中就会先出现 0，再变为一个随机数。</p><p><code>useLayoutEffect</code>会在<code>layout阶段</code>同步执行回调。回调函数中，触发了状态更新<code>setCount(randomNum)</code>，这会重新调度一个同步任务。<br />该任务会在<code>commitRoot</code>的<code>flushSyncCallbakQeueu()</code>函数中同步执行。</p><p>在线 demo 地址： <a href="https://codesandbox.io/s/pedantic-pare-zzqktq?file=/src/App.js">https://codesandbox.io/s/pedantic-pare-zzqktq?file=/src/App.js</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hooks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hooks-useImperativeHandle+forwardRef</title>
      <link href="/2024/02/27/Hooks-useImperativeHandle-forwardRef/"/>
      <url>/2024/02/27/Hooks-useImperativeHandle-forwardRef/</url>
      
        <content type="html"><![CDATA[<p>使用 ref 时，可用<code>useImperativeHandle</code> 自定义暴露给父组件的实例值，这比命令式使用 ref 更好。<br><a name="acttu"></a></p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useImperativeHandle</span>(ref, createHandle, [deps]);</span><br></pre></td></tr></table></figure><ol><li>ref：需要被赋值的 ref 对象。</li><li>createHandle：createHandle 函数的返回值作为 ref.current 的值。</li><li>[deps]：依赖数组，依赖发生变化会重新执行 createHandle 函数。</li></ol><p>因为函数式组件没有实例，所以无法使用<code>ref</code>获取到子组件实例。<br />这时候可以通过<code>React.forwardRef</code>包裹子组件，将<code>ref</code>传递下去，子组件通过第二个参数可接收到<code>ref</code>。</p><p>父组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect, useState, useRef &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Parent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> whiteLinkRef = <span class="title function_">useRef</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleRemoveLink</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;whiteLinkRef.current: &quot;</span>, whiteLinkRef.<span class="property">current</span>);</span><br><span class="line">    <span class="comment">// 调用子组件暴露的方法</span></span><br><span class="line">    whiteLinkRef.<span class="property">current</span>.<span class="title function_">handleSetChecked</span>(<span class="literal">false</span>);</span><br><span class="line">    whiteLinkRef.<span class="property">current</span>.<span class="title function_">handleSetHref</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WhiteLink</span> <span class="attr">ref</span>=<span class="string">&#123;whiteLinkRef&#125;</span> <span class="attr">visible</span>=<span class="string">&#123;showWhiteLink&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Parent</span>;</span><br></pre></td></tr></table></figure><p>子组件：<br />通过第二个参数接收<code>ref</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect, useState, useImperativeHandle &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Child</span> = (<span class="params">props, ref</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 自定义暴露组件内部的方法</span></span><br><span class="line">  <span class="comment">// 需要配合forwardRef使用</span></span><br><span class="line">  <span class="title function_">useImperativeHandle</span>(ref, <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    handleSetChecked,</span><br><span class="line">    handleSetHref,</span><br><span class="line">  &#125;));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">React</span>.<span class="title function_">forwardRef</span>(<span class="title class_">Child</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> hooks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hooks-useRef</title>
      <link href="/2024/02/27/Hooks-useRef/"/>
      <url>/2024/02/27/Hooks-useRef/</url>
      
        <content type="html"><![CDATA[<p>作用：</p><ol><li>访问 DOM 节点&#x2F;react 元素<ul><li>useRef 替换 class 组件中的 createRef</li><li>使用 forwardRef 传递 ref 引用</li><li>使用 useImperativeHandle 自定义暴露实例值</li></ul></li><li>保持变量引用</li></ol><p><a name="aAQ1Q"></a></p><h1 id="保持变量的引用"><a href="#保持变量的引用" class="headerlink" title="保持变量的引用"></a>保持变量的引用</h1><p>在下面这个例子中，如果我们只是想设置一个定时器，可以使用局部变量<code>id</code>，但是如果我们想要在其他地方清除这个定时器，<code>useRef</code>就够帮助我们保存定时器的引用。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./index.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cardDataList = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&quot;杭州市通用5元券&quot;</span>,</span><br><span class="line">    <span class="attr">subTitle</span>:</span><br><span class="line">      <span class="string">&quot;杭味面馆非常好吃，太好吃了，相当不错，味道鲜美，特别划算，快快抢购，聚划算&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&quot;杭州市10元券&quot;</span>,</span><br><span class="line">    <span class="attr">subTitle</span>: <span class="string">&quot;兰州拉面非常好吃&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">delay</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(data);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 这里是react实现方式**/</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">CardReact</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data &#125; = props;</span><br><span class="line">  <span class="keyword">let</span> [btnText, setBtnText] = <span class="title function_">useState</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="title function_">useRef</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 抢购</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleBuy</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">delay</span>(<span class="string">&quot;已抢购&quot;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setBtnText</span>(res);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始倒计时</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    timer.<span class="property">current</span> = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setBtnText</span>(--btnText);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      timer.<span class="property">current</span> &amp;&amp; <span class="built_in">clearInterval</span>(timer.<span class="property">current</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 满足条件后清除定时器</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (btnText &lt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// If we just wanted to set an interval, we wouldn’t need the ref (id could be local to the effect),</span></span><br><span class="line">      <span class="comment">// but it’s useful if we want to clear the interval from an event handler:</span></span><br><span class="line">      <span class="built_in">clearInterval</span>(timer.<span class="property">current</span>);</span><br><span class="line">      <span class="title function_">setBtnText</span>(<span class="string">&quot;抢购&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [btnText]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;title&quot;</span>&gt;</span>&#123;data.title&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;subTitle&quot;</span>&gt;</span>&#123;data.subTitle&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;handleBuy&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;btnText&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">CardList</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;props.list.map((data) =&gt; (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">CardReact</span> <span class="attr">data</span>=<span class="string">&#123;data&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      ))&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">CardList</span> <span class="attr">list</span>=<span class="string">&#123;cardDataList&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="DT64N"></a></p><h1 id="ref-回调函数实参不更新问题"><a href="#ref-回调函数实参不更新问题" class="headerlink" title="ref 回调函数实参不更新问题"></a>ref 回调函数实参不更新问题</h1><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CustomizeContext</span> = <span class="title function_">createContext</span>(defaultV);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="title class_">CustomizeContext</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Customize</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [sceneList, setSceneList] = useState&lt;<span class="title class_">ILiveScene</span>[]&gt;([]);</span><br><span class="line">  <span class="keyword">const</span> [activeLayerIndex, setActiveLayerIndex] = <span class="title function_">useState</span>(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">updateSceneList</span> = (<span class="params">sceneList: ILiveScene[]</span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setSceneList</span>(<span class="title function_">cloneDeep</span>(sceneList));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">updateActiveLayerIndex</span> = (<span class="params">layerId: <span class="built_in">string</span> | -<span class="number">1</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (layerId === -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="title function_">setActiveLayerIndex</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> layerIndex = sceneList[activeSceneIndex].<span class="property">layout</span>.<span class="property">layers</span>.<span class="title function_">findIndex</span>(</span><br><span class="line">        <span class="function">(<span class="params">x</span>) =&gt;</span> x.<span class="property">id</span> === layerId</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      <span class="title function_">setActiveLayerIndex</span>(layerIndex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Container</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">CustomizeContext.Provider</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">value</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">liveId</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">sceneList</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">activeSceneIndex</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">activeLayerIndex</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">updateSceneList</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">updateActiveSceneIndex</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">updateActiveLayerIndex</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Scene</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">CustomizeContext.Provider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Container</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Customize</span>;</span><br></pre></td></tr></table></figure><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  useRef,</span><br><span class="line">  useState,</span><br><span class="line">  useEffect,</span><br><span class="line">  useContext,</span><br><span class="line">  useLayoutEffect,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CustomizeContext</span> &#125; <span class="keyword">from</span> <span class="string">&quot;../../../index&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Scene</span> = (<span class="params">&#123; zIndex &#125;: SceneProp</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> contextData = <span class="title function_">useContext</span>(<span class="title class_">CustomizeContext</span>);</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    sceneList,</span><br><span class="line">    activeSceneIndex,</span><br><span class="line">    updateSceneList,</span><br><span class="line">    updateActiveLayerIndex,</span><br><span class="line">    activeLayerIndex,</span><br><span class="line">  &#125; = contextData;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 保存drop节点，监听拖拽事件</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> node drop节点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> layer 该节点对应的数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleDropRefCallback</span> = (<span class="params"></span></span><br><span class="line"><span class="params">    node: <span class="built_in">any</span>,</span></span><br><span class="line"><span class="params">    layer: ILiveScene[<span class="string">&quot;layout&quot;</span>][<span class="string">&quot;layers&quot;</span>][<span class="built_in">number</span>]</span></span><br><span class="line"><span class="params">  </span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="title function_">getMap</span>();</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">      map.<span class="title function_">set</span>(layer.<span class="property">id</span>, node);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 按下非 active drop</span></span><br><span class="line">      node.<span class="title function_">addEventListener</span>(<span class="string">&quot;mousedown&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!activeDropStateRef.<span class="property">current</span>.<span class="property">isDragging</span>) &#123;</span><br><span class="line">          activeDropStateRef.<span class="property">current</span>.<span class="property">isResize</span> = <span class="literal">false</span>;</span><br><span class="line">          activeDropStateRef.<span class="property">current</span>.<span class="property">isDragging</span> = <span class="literal">true</span>;</span><br><span class="line">          activeDropStateRef.<span class="property">current</span>.<span class="property">startX</span> = e.<span class="property">clientX</span>;</span><br><span class="line">          activeDropStateRef.<span class="property">current</span>.<span class="property">startY</span> = e.<span class="property">clientY</span>;</span><br><span class="line">          activeDropStateRef.<span class="property">current</span>.<span class="property">node</span> = node;</span><br><span class="line">          activeDropStateRef.<span class="property">current</span>.<span class="property">id</span> = layer.<span class="property">id</span>;</span><br><span class="line">          activeDropStateRef.<span class="property">current</span>.<span class="property">rect</span> = layer.<span class="property">rect</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// node.style.zIndex = (zIndex + 1).toString();</span></span><br><span class="line">          <span class="title function_">updateActiveLayerIndex</span>(layer.<span class="property">id</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      map.<span class="title function_">delete</span>(layer.<span class="property">id</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles.sceneContentWrap&#125;</span> <span class="attr">style</span>=<span class="string">&#123;sceneStyle&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;sceneList[activeSceneIndex].layout.layers.map((layer, i) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">        let cp;</span></span><br><span class="line"><span class="language-xml">        const &#123; text, type, digitalHuman, image, video, z &#125; = layer;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        return (</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">className</span>=<span class="string">&#123;cx(styles.drop,</span> &#123;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              [<span class="attr">styles.active</span>]<span class="attr">:</span> <span class="attr">layer.id</span> === <span class="string">activeDropStateRef.current.id,</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &#125;)&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            // <span class="attr">key</span>=<span class="string">&#123;layer.id&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">key</span>=<span class="string">&#123;i&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">ref</span>=<span class="string">&#123;(node)</span> =&gt;</span> handleDropRefCallback(node, layer, i)&#125;</span></span><br><span class="line"><span class="language-xml">            style=&#123;&#123;</span></span><br><span class="line"><span class="language-xml">              left: rect.x,</span></span><br><span class="line"><span class="language-xml">              top: rect.y,</span></span><br><span class="line"><span class="language-xml">              width: rect.width,</span></span><br><span class="line"><span class="language-xml">              height: rect.height,</span></span><br><span class="line"><span class="language-xml">              backgroundColor: type === &quot;text&quot; ? text.backgroundColor : &quot;&quot;,</span></span><br><span class="line"><span class="language-xml">              zIndex: z,</span></span><br><span class="line"><span class="language-xml">            &#125;&#125;</span></span><br><span class="line"><span class="language-xml">          &gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">style</span>=<span class="string">&#123;s&#125;</span> <span class="attr">src</span>=<span class="string">&#123;image.url&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        );</span></span><br><span class="line"><span class="language-xml">      &#125;)&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Scene</span>;</span><br></pre></td></tr></table></figure><p>有一个列表，为了保存列表项节点，我使用 ref 回调来处理。</p><p>有这么个场景，点击 layers 中的第一项并做删除操作，layers.splice(0, 1)，然后更新 layers 引用</p><p>点击第二项时，我期望<code>handleDropRefCallback</code> 中的<code>i</code>为 0，因为 layer 已经更新了，但是结果为 1，也就是还是首次 i 的值</p><p>纳闷了好久，后面才发现是<code>key</code>属性<code>key=&#123;layer.id&#125;</code>保持了该节点的稳定，该节点没有重新渲染，所以 ref 的回调函数还是旧的回调函数，i 的值还是第一项还未删除时的值。<br />解决这个问题，只需要将 key 改为<code>key=&#123;i&#125;</code>，此时列表项重新渲染，<code>handleDropRefCallback</code> 中的<code>i</code>就是期望值 0。</p><p>但是我们清楚，用下标作为 key 的值，如果列表发生更改（新增、删除）时，那么其他列表项的 key 值可能会发生变化，那么变化的部分就会造成没必要的重新渲染问题。所以我还是想用<code>layer.id</code>作为 key 值，通过 id，遍历 layers，查找当前项所在的下标位置。<br />结果却出乎意外，发现 Provied.value 对象中<code>updateLayersFn</code>函数中的 layers 还是旧值，难道 Provider 组件 value 对象中的函数引用了 layers，此时产生了闭包对象？</p>]]></content>
      
      
      
        <tags>
            
            <tag> hooks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hooks-useReducer</title>
      <link href="/2024/02/27/Hooks-useReducer/"/>
      <url>/2024/02/27/Hooks-useReducer/</url>
      
        <content type="html"><![CDATA[<p><code>useReduces</code> 是<code>useState</code>的替代方案。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, initialArg, init);</span><br></pre></td></tr></table></figure><p>当<code>state</code><strong>逻辑复杂</strong>且包含<strong>多个子值</strong>的时候，<code>useReducer</code>会比<code>setState</code>更适用。</p><p>可以使用<code>dispatch</code>发起一个动作，<code>state</code>可以获取到最新的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">state, action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;setAssetsType&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">assetsType</span>: action.<span class="property">payload</span>.<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> (&#123;</span><br><span class="line">          <span class="attr">label</span>: x.<span class="property">fundTypeName</span>,</span><br><span class="line">          <span class="attr">value</span>: x.<span class="property">id</span>,</span><br><span class="line">        &#125;)),</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Edit</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, &#123;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取资产类型</span></span><br><span class="line">  <span class="title function_">getAssetsType</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span></span><br><span class="line">    <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&quot;setAssetsType&quot;</span>, <span class="attr">payload</span>: res &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a name="cb3q8"></a></p><h1 id="复杂的-redux-方案"><a href="#复杂的-redux-方案" class="headerlink" title="复杂的 redux 方案"></a>复杂的 redux 方案</h1><p>&#x2F;reducer&#x2F;assets.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createAction, handleActions &#125; <span class="keyword">from</span> <span class="string">&quot;redux-actions&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">SET_ASSETS_TYPE</span> = <span class="string">&quot;SET_ASSETS_TYPE&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> setAssetsType = <span class="title function_">createAction</span>(<span class="variable constant_">SET_ASSETS_TYPE</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">handleActions</span>(</span><br><span class="line">  &#123;</span><br><span class="line">    [<span class="variable constant_">SET_ASSETS_TYPE</span>]: <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; payload &#125; = action;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        <span class="attr">assetsType</span>: payload,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">assetsType</span>: [],</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>reducer&#x2F;index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">&quot;redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> assets <span class="keyword">from</span> <span class="string">&quot;./assets&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">combineReducers</span>(&#123;</span><br><span class="line">  assets,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>页面组件：每个 connect 的包装组件都会订阅（subscribe） store 的变化，并在变化时触发 render</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; bindActionCreators &#125; <span class="keyword">from</span> <span class="string">&quot;redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; setAssetsType &#125; <span class="keyword">from</span> <span class="string">&quot;ROOT/reducer/assets&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">mapState</span> = (<span class="params">&#123; assets &#125;</span>) =&gt; (&#123;</span><br><span class="line">  <span class="attr">assetsType</span>: assets.<span class="property">assetsType</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">mapActions</span> = (<span class="params">dispatch</span>) =&gt; (&#123;</span><br><span class="line">  <span class="attr">actions</span>: <span class="title function_">bindActionCreators</span>(</span><br><span class="line">    &#123;</span><br><span class="line">      setAssetsType,</span><br><span class="line">    &#125;,</span><br><span class="line">    dispatch</span><br><span class="line">  ),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">List</span> = (<span class="params">&#123; actions, assetsType &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 获取资产类型</span></span><br><span class="line">  <span class="title function_">getAssetsType</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> options = res.<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> (&#123; <span class="attr">label</span>: x.<span class="property">fundTypeName</span>, <span class="attr">value</span>: x.<span class="property">id</span> &#125;));</span><br><span class="line">    actions.<span class="title function_">setAssetsType</span>(options);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">connect</span>(mapState, mapActions)(<span class="title class_">List</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> hooks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hooks-useContext</title>
      <link href="/2024/02/27/Hooks-useContext/"/>
      <url>/2024/02/27/Hooks-useContext/</url>
      
        <content type="html"><![CDATA[<p><code>useContetn</code>接收一个 context 对象（React.createContext 的返回值），并返回该 context 的当前值。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createContext, useState, useMemo, useContext &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">GlobalContext</span> = <span class="title function_">createContext</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [a, updateA] = <span class="title function_">useState</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> [b] = <span class="title function_">useState</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> contextValue = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> (&#123; a, b &#125;), [a, b]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">GlobalContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;contextValue&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ConsumeA</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ConsumeB</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;a&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> updateA(e.target.value)&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">GlobalContext.Provider</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ConsumeA</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; a &#125; = <span class="title function_">useContext</span>(<span class="title class_">GlobalContext</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ConsumeB</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; b &#125; = <span class="title function_">useContext</span>(<span class="title class_">GlobalContext</span>);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;render b with: &quot;</span>, b);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>参考：<br /><a href="https://zhuanlan.zhihu.com/p/346616580">https://zhuanlan.zhihu.com/p/346616580</a><br /><a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usecontext">https://zh-hans.reactjs.org/docs/hooks-reference.html#usecontext</a><br /><a href="https://github.com/facebook/react/issues/15156">https://github.com/facebook/react/issues/15156</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hooks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hooks-useEffect</title>
      <link href="/2024/02/27/Hooks-useEffect/"/>
      <url>/2024/02/27/Hooks-useEffect/</url>
      
        <content type="html"><![CDATA[<p><code>Effect</code> hook 可以让你在函数组件中执行副作用操作。</p><p>在 React 中，由 state 的变化导致 UI 发生变化的过程是正常操作，<strong>其他操作行为</strong>：如数据请求、直接操作 DOM（改变 Document.title）等都是副作用操作。React 无法感知它的变化，所以被归类到 effect。</p><p><strong>副作用操作时相对于操作 state 而言的。</strong></p><p>每一次因为 state 的改变，都有一次对应副作用函数的执行时机。<br><a name="eiNnp"></a></p><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p><strong>语法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;&#125;, []);</span><br></pre></td></tr></table></figure><p>Effect 的第一个参数为回调函数，该函数会在<strong>每次 DOM 渲染完成之后执行</strong>。在事件循环里，useEffect 在下一轮事件循环执行。<br />我们可以在 effect 中获取到最新的 <code>count</code>值，因为他在函数的作用域内。</p><p>第二个参数为一个数组，这是一个优化性能的可选项。</p><ol><li>如果不传第二个参数，那么回调函数会在每一次渲染完成后执行</li><li>如果传入一个空数组<code>[]</code>，那么回调函数会在组件挂载和卸载时执行</li><li>如果传入依赖项数组，如<code>[count]</code>，那么仅会在依赖项改变时重新执行</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">&#125;, [count]); <span class="comment">// 仅在 count 更改时更新</span></span><br></pre></td></tr></table></figure><p><a name="Iawyi"></a></p><h1 id="如何清除副作用"><a href="#如何清除副作用" class="headerlink" title="如何清除副作用"></a>如何清除副作用</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title class_">ChatAPI</span>.<span class="title function_">subscribeToFriendStatus</span>(props.<span class="property">id</span>, handleStatusChange);</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">ChatAPI</span>.<span class="title function_">unsubscribeFromFriendStatus</span>(props.<span class="property">id</span>, handleStatusChange);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> clear;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>假设 props 参数 id 改变了两次，第一次传入<code>id: 1</code>，第二次传入<code>id: 2</code>，那么过程如下：</p><ol><li>传入<code>props.id = 1</code></li><li>组件渲染</li><li>DOM 渲染完成，执行副作用逻辑，返回清除副作用的函数<code>clear</code>，命名为<code>clear1</code></li><li>传入<code>props.is = 2</code></li><li>组件渲染</li><li>组件渲染完成，<code>clear1</code>执行</li><li>副作用逻辑执行，返回另一个 clear 函数，命名为<code>clear2</code></li><li>组件销毁，<code>clear2</code>执行</li></ol><p>总结 clear 函数的执行，它的特征如下：</p><ul><li>每次副作用执行，都会返回一个新的 clear 函数</li><li>clear 函数会在下一次副作用逻辑执行之前执行(DOM 渲染完成之后)</li><li>组件销毁时会执行一次<br><a name="N3aLW"></a></li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>渲染其实是一个比较模糊的概念。像<code>div.style.left = &#39;20px&#39;</code>这段代码，可以分为派发指令和 GUI 执行两个步骤。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="property">style</span>.<span class="property">left</span> = <span class="string">&quot;20px&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">useLayoutEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  div.<span class="property">style</span>.<span class="property">left</span> = <span class="string">&quot;30px&quot;</span>;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p>像上面这个例子，useLayoutEffect 回调函数中的 <code>div.style.left = &#39;30px&#39;</code>，会在 DOM 变更之后同步调用，在 GUI 线程执行之前执行，也就是在浏览器执行渲染之前执行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> hooks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hooks-useEvent</title>
      <link href="/2024/02/27/Hooks-useEvent/"/>
      <url>/2024/02/27/Hooks-useEvent/</url>
      
        <content type="html"><![CDATA[<p><code>useEvent</code>解决了一个问题：如何同时保持函数引用不变与访问到最新状态</p><p>因为<code>useCallback</code>存在<strong>保持函数引用稳定时状态不更新的</strong>问题，所以引入了<code>useEvent</code>hook。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useCallback, useRef, useLayoutEffect &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Button</span> &#125; <span class="keyword">from</span> <span class="string">&quot;../components&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">UseEvent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count4, setCount4] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [count5, setCount5] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为了保持函数引用不变，依赖项为空</span></span><br><span class="line">  <span class="keyword">const</span> stableClickFn = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 访问到的总是初始值</span></span><br><span class="line">    <span class="title function_">setCount4</span>(count4 + <span class="number">1</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用useEvent,保持函数引用不变的同时状态实时更新</span></span><br><span class="line">  <span class="keyword">const</span> stableClickFn2 = <span class="title function_">useEvent</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount5</span>(count5 + <span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>useCallback + []<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClickButton</span>=<span class="string">&#123;stableClickFn&#125;</span>&gt;</span>stable button4<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>count 只会更新一次<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>count4: &#123;count4&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>useEvent<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClickButton</span>=<span class="string">&#123;stableClickFn2&#125;</span>&gt;</span>stable button4<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>count 只会更新一次<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>count5: &#123;count5&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现原理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模仿useEvent</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useEvent</span>(<span class="params">handler</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> handlerRef = <span class="title function_">useRef</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// In a real implementation, this would run before layout effects</span></span><br><span class="line">  <span class="title function_">useLayoutEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    handlerRef.<span class="property">current</span> = handler;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">useCallback</span>(<span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// In a real implementation, this would throw if called during render</span></span><br><span class="line">    <span class="keyword">const</span> fn = handlerRef.<span class="property">current</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fn</span>(...args);</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解一下：</p><ol><li>为了返回一个稳定引用，那么最后返回的函数一定使用<code>useCallback</code>和依赖项空数组<code>[]</code></li><li>又要在函数执行时访问到最新值，那么每次都要拿最新函数来执行，所以在 Hook 里使用 Ref 存储每次接收到的最新函数引用，在执行函数时，实际上执行的是最新的函数引用。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> hooks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hooks-useCallback和useMemo</title>
      <link href="/2024/02/27/Hooks-useCallback%E5%92%8CuseMemo/"/>
      <url>/2024/02/27/Hooks-useCallback%E5%92%8CuseMemo/</url>
      
        <content type="html"><![CDATA[<p><a name="qr2eI"></a></p><h1 id="记忆函数"><a href="#记忆函数" class="headerlink" title="记忆函数"></a>记忆函数</h1><p>在开发实践中，有一种优化手段叫做<strong>记忆函数。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">summation</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sum: &quot;</span>, sum);</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">summation</span>(<span class="number">10</span>);</span><br><span class="line"><span class="title function_">summation</span>(<span class="number">100</span>);</span><br><span class="line"><span class="title function_">summation</span>(<span class="number">100</span>);</span><br><span class="line"><span class="title function_">summation</span>(<span class="number">100</span>);</span><br><span class="line"><span class="title function_">summation</span>(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>这是一个求和函数，每次执行函数都会重新计算结果。当我们重复调用<code>summation(100)</code>时，内部的循环计算是不是有点冗余？因为传入相同的参数，必定得到相同的结果，因此如果传入参数一样，是不是可以不再重复计算直接使用上次的计算结果呢？</p><p>是的，利用闭包能够实现我们的目的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// memoFn.jsx</span></span><br><span class="line"><span class="comment">// 初始化一个非正常数字</span></span><br><span class="line"><span class="keyword">let</span> preTarget = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> memoSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">memoSummation</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  <span class="comment">// 传入参数与上次一样，直接返回缓存结果</span></span><br><span class="line">  <span class="keyword">if</span> (prevTarget &gt; <span class="number">0</span> &amp;&amp; prevTarget === target) &#123;</span><br><span class="line">    <span class="keyword">return</span> memoSum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 缓存本次传入的参数</span></span><br><span class="line">  prevTarget = target;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我出现，表示又重新计算了一次&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 缓存本次计算结果</span></span><br><span class="line">  memoSum = sum;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; memoSummation &#125; <span class="keyword">from</span> <span class="string">&quot;./memoFn&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">memoSummation</span>(<span class="number">10</span>);</span><br><span class="line"><span class="title function_">memoSummation</span>(<span class="number">50</span>);</span><br><span class="line"><span class="title function_">memoSummation</span>(<span class="number">100</span>);</span><br><span class="line"><span class="title function_">memoSummation</span>(<span class="number">50</span>);</span><br><span class="line"><span class="title function_">memoSummation</span>(<span class="number">100</span>);</span><br><span class="line"><span class="title function_">memoSummation</span>(<span class="number">100</span>);</span><br><span class="line"><span class="title function_">memoSummation</span>(<span class="number">100</span>);</span><br><span class="line"><span class="title function_">memoSummation</span>(<span class="number">100</span>);</span><br><span class="line"><span class="title function_">memoSummation</span>(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><code>&#39;我出现，表示又重新计算了一次&#39;</code>只打印了 5 次。</p><p>将<code>memoFn.jsx</code>模块用伪代码表示，如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoFn = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> prevTarget = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> memoSum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">memoFn</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="comment">// 传入参数与上次一样，直接返回缓存结果</span></span><br><span class="line">    <span class="keyword">if</span> (prevTarget &gt; <span class="number">0</span> &amp;&amp; prevTarget === target) &#123;</span><br><span class="line">      <span class="keyword">return</span> memoSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存本次传入的参数</span></span><br><span class="line">    prevTarget = target;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我出现，表示又重新计算了一次&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">      sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 缓存本次计算结果</span></span><br><span class="line">    memoSum = sum;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> memoSummation = memoFn;</span><br></pre></td></tr></table></figure><p><strong>hooks 中的记忆函数</strong><br />hooks 提供的 api 中，大多都有记忆功能，例如：</p><ul><li>useState</li><li>useEffect</li><li>useCallback</li><li>useMemo</li><li>useLayoutEffect</li><li>useReducer</li><li>useRef</li></ul><p>这里主要讲<code>useCallback</code>和<code>useMemo</code>。<br><a name="jUPqG"></a></p><h1 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h1><p><strong>useMemo 缓存计算结果</strong>。它接收两个参数，第一个参数是回调函数（返回计算结果），第二个参数是依赖项（数组），当依赖项中某一项发生变化时，结果将会重新计算。<br /><code>const memorizedValue = useMemo(() =&gt; &#123;&#125;, deps)</code><br><a name="FSewX"></a></p><h1 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h1><p><strong>useCallback 缓存函数。</strong> 他的使用跟<code>useMemo</code>几乎一样，当依赖项中的某一个发生变化时，返回一个新函数。<br /><code>const memorizedFn = useCallback(() =&gt; &#123;&#125;, deps)</code><br><a name="YzPEU"></a></p><h3 id="伪代码实现"><a href="#伪代码实现" class="headerlink" title="伪代码实现"></a>伪代码实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * useCallback 简易实现（不考虑多个useCallbacks的情况）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> memoizedState = [];</span><br><span class="line"><span class="keyword">let</span> hookIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useCallbacks</span>(<span class="params">callback, nextDeps</span>) &#123;</span><br><span class="line">  <span class="comment">// debugger</span></span><br><span class="line">  <span class="keyword">const</span> prevState = memoizedState[hookIndex];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (prevState) &#123;</span><br><span class="line">    <span class="comment">// 更新</span></span><br><span class="line">    <span class="keyword">let</span> [prevCallback, prevDeps] = prevState;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对比依赖项</span></span><br><span class="line">    <span class="keyword">let</span> same = nextDeps.<span class="title function_">every</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> item === prevDeps[index]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依赖项相同</span></span><br><span class="line">    <span class="keyword">if</span> (same) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;返回旧函数&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> prevCallback;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 首次挂载时 或者 更新时但依赖项不同，都返回新函数</span></span><br><span class="line">  memoizedState[hookIndex] = [callback, nextDeps];</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;返回新函数&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> callback;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useCallbacks;</span><br></pre></td></tr></table></figure><p><a name="Vlhn4"></a></p><h3 id="useCallback-和-useMemo-的区别"><a href="#useCallback-和-useMemo-的区别" class="headerlink" title="useCallback 和 useMemo 的区别"></a>useCallback 和 useMemo 的区别</h3><ul><li>useCallback 缓存的是<code>callback</code>函数本身，useMemo 缓存的是<code>callback</code>函数的计算结果，也可以是一个函数</li><li>都是利用闭包缓存计算结果。只有在函数或计算的过程非常复杂时才考虑使用</li><li>useCallback&#x2F;useMemo 可以用来优化子组件和当前组件。优化子组件时，可以防止子组件没必要的重复渲染，useCallback 需要配合 React.memo 一起使用，useMemo 不需要；优化当前组件时，useCallback 主要用于某个会多次 re-render 组件中的没有依赖项的函数，useMome 主要用于缓存复杂的计算逻辑。</li><li>useCallback(fn, deps) 相等于 useMemo(() &#x3D;&gt; fn, deps)<br><a name="FkkUd"></a></li></ul><h1 id="是否需要优化"><a href="#是否需要优化" class="headerlink" title="是否需要优化"></a>是否需要优化</h1><p>通过记忆函数的原理，我们应该知道，<strong>创建记忆函数并不是没有代价的，我们需要创建闭包，占用更多的内存，用以解决计算上的冗余</strong>。</p><p>对于一个函数组件来说，我们在内部会创建许多函数，是否都有必要使用 useCallback 呢？思考下面代码</p><p><strong>useCallback 是否有必要包裹 setCount 函数？</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoAdd = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">setCount</span>(count++);</span><br><span class="line">&#125;, [count]);</span><br></pre></td></tr></table></figure><p><strong>存在依赖项时</strong>，如果 memoFn 不作为 props 传给子组件，仅做一个缓存函数的作用，这样是不是也有达到优化效果？</p><p>答案是<strong>没必要</strong>。创建函数的消耗很小，依赖项的对比反而有一定的性能开销。</p><p>当一个函数执行完毕，就会从函数调用栈被弹出，里面的内存也会被回收。对于函数组件来说也一样，当内部函数执行完毕后也会被释放掉。所以<strong>函数式组件的性能是非常快的。</strong><br />而当我们使用 useCallback 时，由于新增了对闭包的使用，新增了依赖项的对比逻辑，如果盲目使用他们，可能会让组件变得更慢。大多数情况下你不需要使用 useCallback&#x2F;useMemo。</p><p>那么，什么时候使用 useCallback 比较合适呢？<br><a name="efa0U"></a></p><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><p>当<strong>函数或计算的过程非常复杂时</strong>，才优先考虑使用<code>useCallback/useMemo</code>。<br><a name="yZ26k"></a></p><h3 id="当函数（或子组件）非常复杂时"><a href="#当函数（或子组件）非常复杂时" class="headerlink" title="当函数（或子组件）非常复杂时"></a>当函数（或子组件）非常复杂时</h3><p>默认情况下，父组件的重新渲染会导致子组件也重新渲染。如果子组件的 props 未发生变化时，子组件就没有重新渲染的必要。</p><p>所以当函数非常复杂时，我们可以将 useCallbak 的返回值”缓存函数”传给子组件，然后配合子组件使用 React.memo 解决子组件不必要的渲染问题。</p><p>案例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useCallback, useMemo &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Button</span> <span class="keyword">from</span> <span class="string">&quot;./Button&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">UseCallback</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count1, setCount1] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [count2, setCount2] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [count3, setCount3] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 未使用useCallback的情况下，handleClickButton1 函数引用每次都会变化</span></span><br><span class="line">  <span class="comment">// 这会破坏子组件 memo 效果</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClickButton1</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setCount1</span>(count1 + <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 缓存函数：只有在依赖项发生改变时，才返回新的函数，否则返回缓存函数</span></span><br><span class="line">  <span class="comment">// 子组件发现onClickButton属性没发生改变，就不会重新渲染，从而达到优化效果</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用useCallback，如果 count2 不变，handleClickButton2 引用不变</span></span><br><span class="line">  <span class="keyword">const</span> handleClickButton2 = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount2</span>(count2 + <span class="number">1</span>);</span><br><span class="line">  &#125;, [count2]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>未使用useCallback<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClickButton</span>=<span class="string">&#123;handleClickButton1&#125;</span>&gt;</span>Button1<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClickButton</span>=<span class="string">&#123;handleClickButton2&#125;</span>&gt;</span>Button2<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Button2 上的on函数使用了useCallback<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">onClickButton</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">            setCount3(count3 + 1);</span></span><br><span class="line"><span class="language-xml">          &#125;&#125;</span></span><br><span class="line"><span class="language-xml">        &gt;</span></span><br><span class="line"><span class="language-xml">          Button3</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>子组件要配合 React.memo 一起使用。</strong><br />Button 子组件，假设这个组件非常复杂</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Button.jsx</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设这个组件非常复杂</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Button</span> = (<span class="params">&#123; onClickButton, children, count &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onClickButton&#125;</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;Math.random()&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;count &amp;&amp; <span class="tag">&lt;<span class="name">span</span>&gt;</span>count: &#123;count&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，useCallback一定要配合React.memo一起使用，否则就是反向优化</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="title class_">Button</span>);</span><br></pre></td></tr></table></figure><p><a name="X5CtY"></a></p><h3 id="会多次re-render的组件中，且函数没有任何依赖时"><a href="#会多次re-render的组件中，且函数没有任何依赖时" class="headerlink" title="会多次re-render的组件中，且函数没有任何依赖时"></a>会多次<code>re-render</code>的组件中，且函数没有任何依赖时</h3><p>如果某组件一定会多次<code>re-render</code>，且函数没有任何依赖，可以考虑使用 useCallback 降低多次执行带来的重复创建同样方法的负担。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> onChange=&#123;inputChange&#125; /&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inputChange = <span class="title function_">useCallback</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">setValue</span>(e.<span class="property">target</span>.<span class="property">value</span>);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p>同样的场景，如果函数只会渲染一次，那么使用 useCallback 就完全没必要。<br><a name="fKmgS"></a></p><h1 id="闭包带来的问题"><a href="#闭包带来的问题" class="headerlink" title="闭包带来的问题"></a>闭包带来的问题</h1><p>通过前面的例子可以知道，<code>handleClickButton2</code>缓存函数仅在 <code>count</code>不变时保持稳定。<br />如果想要<strong>保持</strong><code>handleClickButton2</code><strong>引用一直稳定</strong>，要把依赖项移除，用空数组作为参数，这会<strong>导致访问到的</strong><code>count</code><strong>总是初始值</strong>，逻辑上引发了更大的问题，也就是闭包问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useCallback, useMemo &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Button</span> <span class="keyword">from</span> <span class="string">&quot;./Button&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">UseCallback</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count4, setCount4] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 缓存函数引用保持稳定时状态不更新问题</span></span><br><span class="line">  <span class="keyword">const</span> stableClickFn = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(count4);</span><br><span class="line">    <span class="comment">// 访问到的总是初始值</span></span><br><span class="line">    <span class="title function_">setCount4</span>(count4 + <span class="number">1</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>缓存函数引用保持稳定时状态不更新问题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClickButton</span>=<span class="string">&#123;stableClickFn&#125;</span>&gt;</span>stable button4<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>count 只会更新一次<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>count4: &#123;count4&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要解决这个问题，可以看<a href="https://www.yuque.com/weilun2023/nug9kz/dzbws5sqtoqg42g4"><strong>hooks 闭包陷阱</strong></a>中的解决办法。</p><p>react 团队为了解决这个问题，准备引入<code>useEvent</code>，它具备以下属性：</p><ul><li>每次重新渲染时都不会重新创建该函数</li><li>该函数将可以访问 props&#x2F;state 的最新值<br><a name="gX2OK"></a></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>useCallback/useMemo</code>的作用在于利用记忆函数减少无效的<code>re-render</code>，来达到性能优化的作用。记忆函数的原理，是创建闭包，但创建闭包是有代价的，会占用更多的内存，用以解决计算上的冗余。所以我们需要根据场景来权衡是否有必要使用<code>useCallback/useMemo</code>。</p><p>参考：<br /><a href="https://zhuanlan.zhihu.com/p/56975681">https://zhuanlan.zhihu.com/p/56975681</a><br /><a href="https://mp.weixin.qq.com/s/MnkycB8D9kCRrsXaLBfgXg">https://mp.weixin.qq.com/s/MnkycB8D9kCRrsXaLBfgXg</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hooks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hooks-useState</title>
      <link href="/2024/02/27/Hooks-useState/"/>
      <url>/2024/02/27/Hooks-useState/</url>
      
        <content type="html"><![CDATA[<p>与 UI 更新相关的状态才使用 state 。如果只想要一个数据持久化，请使用 useRef<br><a name="mLb4r"></a></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = <span class="title function_">useState</span>(initialState);</span><br></pre></td></tr></table></figure><p>如果初始的 initialState 需要通过复杂计算获得，则可以传入一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = <span class="title function_">useState</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> initialState = <span class="title function_">someExpensiveComputation</span>(props);</span><br><span class="line">  <span class="keyword">return</span> initialState;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a name="niAz2"></a></p><h1 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SM</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> state = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">myUseState</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    state = state || value; <span class="comment">// 第一次调用没有初始值，因此使用传入的初始值赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">dispatch</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">      state = newValue;</span><br><span class="line">      <span class="comment">// 假设此方法能触发页面渲染</span></span><br><span class="line">      <span class="comment">// render()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [state, dispatch];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="NX8fu"></a></p><h1 id="异步还是同步"><a href="#异步还是同步" class="headerlink" title="异步还是同步"></a>异步还是同步</h1><p>useState 返回的 setCount 和 class 组件的 this.setState 一样，在事件处理函数内部执行的是异步的，在执行之后并不能获取到最新的值。</p><p><a name="Z4W1b"></a></p><h1 id="怎么获取最新的值"><a href="#怎么获取最新的值" class="headerlink" title="怎么获取最新的值"></a>怎么获取最新的值</h1><p>如果新的 state 需要通过先前的 state 计算得出，可以将<strong>函数</strong>传给 setState。该函数接收先前的 state，并返回一个更新后的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">setCount</span>(<span class="function">(<span class="params">prevCount</span>) =&gt;</span> prevCount + <span class="number">1</span>);</span><br><span class="line">  <span class="title function_">setCount</span>(<span class="function">(<span class="params">prevCount</span>) =&gt;</span> prevCount + <span class="number">1</span>);</span><br><span class="line">  <span class="title function_">setCount</span>(<span class="function">(<span class="params">prevCount</span>) =&gt;</span> prevCount + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 注意，这里不能获取到count最新值</span></span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p><strong>如果需要使用最新的 state，可以在 useEffect 里获取到</strong>。<br />当触发更新的函数（即<code>setCount</code>）接收一个函数时，会创建对应的<code>update</code>。这里调用了 3 次就会有 3 个<code>update</code>。所以<code>count</code>为 3。<br><a name="H3Ggw"></a></p><h1 id="为什么返回值是个数组"><a href="#为什么返回值是个数组" class="headerlink" title="为什么返回值是个数组"></a>为什么返回值是个数组</h1><p>数组解构时，变量可以命名为任意名称，取值由它的位置决定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = <span class="title function_">useState</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">const</span> [state2, setState2] = <span class="title function_">useState</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>对象解构时，变量必须与属性同名才能取到正确的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; state, setState &#125; = <span class="title function_">useState</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">state</span>: state2, <span class="attr">setState</span>: setState2 &#125; = <span class="title function_">useState</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>如果使用返回的是对象，当代码块中多次使用 useState 时，对象属性得重命名才不会冲突。相比之下数组代码显示的简洁。</p><p>但数组也有不足之处：</p><ul><li>返回值必须按顺序取</li><li>返回参数较多时，又不是所有返回值都需要的情况下，写法会比较奇怪。例如只使用 setState： <code>const [, setState] = useState(null)</code><br><a name="tjMLh"></a></li></ul><h1 id="避免不必要的-useState"><a href="#避免不必要的-useState" class="headerlink" title="避免不必要的 useState"></a>避免不必要的 useState</h1><p>案例来自波神的文章： <a href="https://mp.weixin.qq.com/s/nR9zczAZ5WZb1oG7w5cJDA">https://mp.weixin.qq.com/s/nR9zczAZ5WZb1oG7w5cJDA</a><br />截取文章的其中一段：<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-27/20240227104654.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> hooks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hooks闭包陷阱</title>
      <link href="/2024/02/27/Hooks%E9%97%AD%E5%8C%85%E9%99%B7%E9%98%B1/"/>
      <url>/2024/02/27/Hooks%E9%97%AD%E5%8C%85%E9%99%B7%E9%98%B1/</url>
      
        <content type="html"><![CDATA[<p><a name="fWl5z"></a></p><h1 id="闭包陷阱"><a href="#闭包陷阱" class="headerlink" title="闭包陷阱"></a>闭包陷阱</h1><p>以下两段代码，来自 <a href="https://github.com/hacker0limbo/my-blog/issues/6">https://github.com/hacker0limbo/my-blog/issues/6</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createIncrement</span>(<span class="params">i</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> value = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    value += i;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">    <span class="keyword">const</span> message = <span class="string">`Current value is <span class="subst">$&#123;value&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">logValue</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;value: &quot;</span>, value);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(message);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> increment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inc = <span class="title function_">createIncrement</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> log = <span class="title function_">inc</span>(); <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">inc</span>(); <span class="comment">// 2</span></span><br><span class="line"><span class="title function_">inc</span>(); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">log</span>(); <span class="comment">// &quot;Current value is 1&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createIncrementFixed</span>(<span class="params">i</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> value = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    value += i;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">logValue</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> message = <span class="string">`Current value is <span class="subst">$&#123;value&#125;</span>`</span>;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(message);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> increment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inc = <span class="title function_">createIncrementFixed</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> log = <span class="title function_">inc</span>(); <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">inc</span>(); <span class="comment">// 2</span></span><br><span class="line"><span class="title function_">inc</span>(); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">log</span>(); <span class="comment">// &quot;Current value is 3&quot;</span></span><br></pre></td></tr></table></figure><p>截取文章中的一段话，如下：<br /><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-27/20240227103752.png"><br /><br>对于这句话，我再做下解释：<br />在 value 变量修改值之后，message 变量保存的值仍旧是原始的值。这是因为<strong>基础数据类型的值是不可变的。</strong><br><a name="XVxXr"></a></p><h2 id="基础数据类型的值是不可变的"><a href="#基础数据类型的值是不可变的" class="headerlink" title="基础数据类型的值是不可变的"></a>基础数据类型的值是不可变的</h2><p>让我们举例说明，看下这段代码，思考 a 的值为多少？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line">b++;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br></pre></td></tr></table></figure><p><code>b++</code>，b 的值被改变了，但是 a 没被改变，依然为 1。这意味着 a b 的等价，并不表示他们是同一个值。也就是说，a 赋予 b 的时候，重新给 b 分配了一块内存空间。因此我们说，<strong>基础数据类型，是按值访问的。</strong> 用图表示<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-27/20240227103852.png"></p><p><strong>基础数据类型的比较，是值在比较</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">1</span>;</span><br><span class="line">a === b; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>当 a 和 b 在比较的时候，本质上是值在比较。所以我们说<strong>基础数据类型的值是不可变的。</strong><br><a name="gYWVk"></a></p><h2 id="出现闭包陷阱的原因"><a href="#出现闭包陷阱的原因" class="headerlink" title="出现闭包陷阱的原因"></a>出现闭包陷阱的原因</h2><p>为第一段代码第 6 行打上断点</p><ol><li>开始执行<code>createIncrement</code>函数，先定义<strong>基础数据类型 value</strong>并赋值为 0，然后返回<code>increment</code>函数并赋值给<code>inc</code>。</li><li>inc 执行，进入<code>increment</code>函数，执行到第 8 行，<code>value+=i</code>，变量<code>value</code>的值变成了 1，同时产生了闭包对象<code>Closure(createIncrement)</code>，该闭包对象存在<code>increment</code>作用域当中。</li></ol><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-27/20240227104106.png"></p><ol start="3"><li>接着执行到第 10 行，声明了<code>message</code>变量，并将<strong>基础数据类型 value</strong>的值赋给<code>message</code>，此时<code>value</code>为 1，所以<code>message = &quot;Current value is 1&quot;</code>，然后返回<code>logValue</code>函数，<code>increment</code>函数执行完毕，并赋值给<code>log</code>变量。因为闭包对象<code>Closure(createIncrement)</code>的产生，<code>log</code><strong>变量将会引用着</strong><code>increment</code><strong>函数第一次执行时创建的作用域。</strong>如图所示，作用域里的 Local 对象「活动对象」中的<code>message = &quot;Current value is 1&quot;</code>。</li></ol><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-27/20240227104124.png"></p><ol start="4"><li>解释第 25 行，执行<code>logValue</code>函数，寻找<code>message</code>变量。 先查找 Local 活动对象，没找到，发现作用域链中的闭包对象<code>Closure(increment)</code>中存在<code>message</code>，且值为<code>Current value is 1</code>，打印<code>message</code>，<code>logValue</code>函数执行完毕。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Local 活动对象：仅仅只有处于栈顶的执行上下文，才会生成 Local 对象。</span><br><span class="line">除了 Local 活动对象，作用域链中的其他几种变量对象（Closure/Module/Global）都能够在函数解析时确定</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-27/20240227104143.png"></p><p>虽然<code>Closure(createIncrement)</code>中的<code>value</code>已经变成了 3，但是并不影响<strong>基础数据类型 message 变量中的 value 值。</strong><br />那是不是只要将引用类型赋值给 message 变量，就可以解决闭包陷阱问题？<br><a name="Ttyu1"></a></p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>让我们稍微改下代码，将<code>value</code><strong>改为引用类型</strong>，再赋值给 message</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 闭包陷阱</span></span><br><span class="line"><span class="comment">// 参考: https://github.com/hacker0limbo/my-blog/issues/6</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Trap</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// debugger</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">createIncrement</span>(<span class="params">i</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = &#123;</span><br><span class="line">      <span class="attr">a</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">      value.<span class="property">a</span> += i;</span><br><span class="line">      <span class="keyword">const</span> message = value;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">logValue</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;value: &quot;</span>, value);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;message: &quot;</span>, message);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> increment;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> inc = <span class="title function_">createIncrement</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> log = <span class="title function_">inc</span>(); <span class="comment">// 1</span></span><br><span class="line">  <span class="title function_">inc</span>(); <span class="comment">// 2</span></span><br><span class="line">  <span class="title function_">inc</span>(); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">log</span>(); <span class="comment">// &quot;Current value is 3&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>闭包陷阱<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Trap</span>;</span><br></pre></td></tr></table></figure><p>第一次执行<code>increment</code>函数时，<code>value.a += 1</code>，所以<code>value = &#123; a: 1 &#125;</code>，<code>message = &#123; a: 1 &#125;</code>，<code>increment</code>函数执行完毕，并赋值给<code>log</code>变量。<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-27/20240227104204.png"></p><p>后面执行<code>logValue</code>时，虽然<code>createIncrement</code> <strong>函数第一次执行时创建的作用域</strong>中的<code>message = &#123; a: 1 &#125;</code>，但是<code>message</code>的引用指向着<code>value</code>，所以当<code>value = &#123; a: 3 &#125;</code>时，<code>message</code>也等于<code>&#123; a: 3 &#125;</code>。所以将引用类型赋值给<code>message</code>确实能解决闭包陷阱问题。<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-27/20240227104241.png"></p><p>小结：</p><ol><li><code>log</code>变量引用着<code>increment</code>函数第一次执行时创建的作用域，此时<code>message = &quot;Current value is 1&quot;</code>。</li><li>执行三次<code>increment</code>函数后，<code>value</code>变成了 3，然后执行<code>logValue</code>函数而<code>message</code>中的<code>value</code>依旧为 1 的原因是<code>value</code>变量是个基础数据类型。</li><li>想要拿到<code>value</code>变量的最新值，我们只需要把<code>value</code>变量从基础数据类型改为引用数据类，并让<code>message</code>指向<code>value</code>变量即可。</li></ol><p>思考以下三种不同赋值方式<code>message</code>的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createIncrement</span>(<span class="params">i</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> value = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    value.<span class="property">a</span> += i;</span><br><span class="line">    <span class="keyword">const</span> message = <span class="string">`Current value is <span class="subst">$&#123;value.a&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">logValue</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;value: &quot;</span>, value); <span class="comment">// &#123; a: 3 &#125;</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;message: &quot;</span>, message); <span class="comment">// Current value is 1</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> increment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createIncrement</span>(<span class="params">i</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> value = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    value.<span class="property">a</span> += i;</span><br><span class="line">    <span class="keyword">const</span> message = &#123;</span><br><span class="line">      <span class="attr">a</span>: value.<span class="property">a</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">logValue</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;value: &quot;</span>, value); <span class="comment">// &#123; a: 3 &#125;</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;message: &quot;</span>, message); <span class="comment">// &#123; a: 1 &#125;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> increment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createIncrement</span>(<span class="params">i</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> value = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    value.<span class="property">a</span> += i;</span><br><span class="line">    <span class="keyword">const</span> message = &#123;</span><br><span class="line">      <span class="attr">a</span>: value,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">logValue</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;value: &quot;</span>, value); <span class="comment">// &#123; a: 3 &#125;</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;message: &quot;</span>, message); <span class="comment">// &#123; a: &#123; a: 3 &#125; &#125;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> increment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hooks 出现的闭包陷阱，其实跟上面的问题是一样的。<br><a name="izedp"></a></p><h1 id="Hooks-中的闭包陷阱"><a href="#Hooks-中的闭包陷阱" class="headerlink" title="Hooks 中的闭包陷阱"></a>Hooks 中的闭包陷阱</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(fn, [deps]);</span><br></pre></td></tr></table></figure><p>在 react hook 中有个经典的闭包陷阱</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hooks 中的闭包陷阱</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">HookClosureTrap</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 获取到的count永远是0，这是因为闭包陷阱导致的问题</span></span><br><span class="line">    <span class="comment">// 当依赖项为空数组时，fn只会执行一次，useEffect永远引用着HookClosureTrap第一次执行时创建的作用域。第一次创建是count为0</span></span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hooks 中的闭包陷阱<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>count: &#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">HookClosureTrap</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们给<code>useEffect</code>第二个参数<code>deps</code>传了个<strong>空数组</strong>，并使用<code>setInterval</code>希望隔秒<code>count+1</code>，然而实际效果是首次渲染时页面中<code>count</code>为<code>0</code>，然后过了 1 秒页面中的<code>count</code>更新为<code>1</code>，之后一直保持为<code>1</code>不变，这就是<code>useEffect</code>的引起的闭包问题。<br />因为当依赖项为空数组时，<code>fn</code>(useEffect 的第一个参数)只会执行一次，而 useEffect 永远引用着 HookClosureTrap 第一次执行时创建的作用域。第一次创建时 count 为 0。<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-27/20240227104306.png"><br><a name="Q4i6F"></a></p><h2 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h2><p><a name="SlhwL"></a></p><h3 id="添加依赖项"><a href="#添加依赖项" class="headerlink" title="添加依赖项"></a>添加依赖项</h3><p>添加 count 依赖项，依赖项改变时 fn 重新执行，因为 setCount 会触发重新渲染，那么我们就能获取到 HookClosureTrap 最新的作用域，也就能获取到最新的 count</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解决办法1：添加依赖项</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;, [count]);</span><br></pre></td></tr></table></figure><p>虽然获取到了最新值，但是 count 显示结果却很混乱。<br />这是因为每次执行 useEffect 时就会创建一个定时器<code>timer</code>，下次执行时，也会执行上次创建的定时器。<br />所以我们需要在 useEffect 中返回一个回调函数，清除本次创建的定时器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> timer &amp;&amp; <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">&#125;, [count]);</span><br></pre></td></tr></table></figure><p><a name="tMcTg"></a></p><h3 id="setState-函数式更新"><a href="#setState-函数式更新" class="headerlink" title="setState 函数式更新"></a>setState 函数式更新</h3><p>setState 可以接收一个函数，函数的参数是上一次计算后该状态的值，可以理解为最新值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解决办法2：使用setState函数式更新</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里打印的count，依旧永远是0</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;count: &quot;</span>, count);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">setCount</span>(<span class="function">(<span class="params">prev</span>) =&gt;</span> prev + <span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> timer &amp;&amp; <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p><a name="SfV9h"></a></p><h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> refContainer = <span class="title function_">useRef</span>(initialValue);</span><br></pre></td></tr></table></figure><p>useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内持续存在。</p><p>也就是说，使用 useRef， 可以保持变量的引用不变。<br />这简直跟解决闭包陷阱的办法一模一样，就是把<code>value</code>变量改为了引用类型。</p><p>我们修改 ref 的值后，setState 触发更新，重新渲染时，拿到的虽然是 HookClosureTrap 第一次执行时创建的作用域，ref 引用地址不变，但是它的值已经被改变了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解决办法3：使用useRef</span></span><br><span class="line"><span class="keyword">const</span> countRef = <span class="title function_">useRef</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(++countRef.<span class="property">current</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还有一种不常见的写法</span></span><br><span class="line">    <span class="comment">// 对count使用前置自增运算符，也能得到正确的效果</span></span><br><span class="line">    <span class="comment">// setCount(++count)</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> timer &amp;&amp; <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p><a name="VWs6V"></a></p><h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><p>useReducer 同 useRef 类似，使用引用数据类型解决这个问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect, useRef, useReducer &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">countReducer</span>(<span class="params">state, &#123; type, payload &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;add&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">count</span>: state.<span class="property">count</span> + payload,</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hooks 中的闭包陷阱</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">HookClosureTrap</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(countReducer, &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解决办法4: 使用useReducer</span></span><br><span class="line">  <span class="comment">// useReducer 同 useRef 类似，使用引用数据类型解决这个问题</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&quot;add&quot;</span>, <span class="attr">payload</span>: <span class="number">1</span> &#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hooks 中的闭包陷阱<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>state.count: &#123;state.count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">HookClosureTrap</span>;</span><br></pre></td></tr></table></figure><p>除了<code>useEffect</code>，像<code>useMemo</code>、<code>useCallback</code>都有 deps 参数，在这些 hook 里用到某个 state 时，如果 deps 为空数组，虽然 state 变了，但是却没有执行新传入的函数，依旧引用的之前的 state。<br><a name="dyt8r"></a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>createIncrement</code>这段代码中，出现闭包陷阱的原因是，第一次执行<code>increment</code>后，该作用域被<code>log</code>变量保存（因为产生了闭包（Closure(createIncrement)）所以能被保存），作用域中的<code>Local</code>对象中<code>message = &quot;Current value is 1&quot;</code>，<code>message</code>是基础数据类型，所以后续打印<code>message</code>的值仍为第一次执行<code>increment</code>的值。如果希望<code>message</code>中的<code>value</code>为最新值，将<code>value</code>变量改为引用数据类型，并让<code>message</code>指向<code>value</code>变量即可。<br />react hooks 出现闭包陷阱的原因也是如此，采用添加依赖项、使用 setState 函数式更新、useRef、useReducer 都可以解决这个问题。</p><p>参考：<br /><a href="http://www.ferecord.com/react-hooks-closure-traps-problem.html">http://www.ferecord.com/react-hooks-closure-traps-problem.html</a><br /><a href="https://www.jianshu.com/p/6a512f78536a">https://www.jianshu.com/p/6a512f78536a</a><br /><a href="https://cloud.tencent.com/developer/article/2016207">https://cloud.tencent.com/developer/article/2016207</a><br /><a href="https://juejin.cn/post/6844904193044512782">https://juejin.cn/post/6844904193044512782</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hooks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hooks与闭包</title>
      <link href="/2024/02/27/Hooks%E4%B8%8E%E9%97%AD%E5%8C%85/"/>
      <url>/2024/02/27/Hooks%E4%B8%8E%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p><a name="IJ4Fn"></a></p><h1 id="设计动机"><a href="#设计动机" class="headerlink" title="设计动机"></a>设计动机</h1><ol><li>解决组件之间状态难以复用的问题</li><li>让组件更容易理解</li></ol><p>hooks 可以理解为更底层的实现，内部会自动帮我们管理状态，不用像<code>ClassComponent</code>组件一样在生命周期里写各种逻辑。</p><p><code>hooks</code>能够让函数式组件拥有内部状态的基本原理，就是利用闭包的特性「闭包对象持久存在」。这让函数组件下次执行时能够获取到上次函数执行结束时<code>state</code>的值。</p><p>回顾下闭包的定义：闭包是一个特殊的对象。它由两部分组件，执行上下文 A 以及 A 中创建的函数 B。当 B 执行时，如果访问了 A 中的变量，那么闭包就产生了。<br />在 chrome 中，执行上下文 A 的函数名代指闭包。<br><a name="iQNgZ"></a></p><h1 id="闭包与模块"><a href="#闭包与模块" class="headerlink" title="闭包与模块"></a>闭包与模块</h1><p>当我们定义一个 React 组件，并在其他模块在使用，这时候思考一下模块与闭包的关系：<br />在模 Counter.jsx 中定义一个 Counter 组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Counter.jsx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>然后在 App 模块中使用 Counter 组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.jsx</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Counter</span> <span class="keyword">from</span> <span class="string">&quot;./Counter&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Counter</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码转换成伪代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CounterModule</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AppModule</span> = (<span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Counter</span> = <span class="title class_">CounterModule</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> funtion <span class="title class_">App</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Counter</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>当 App 函数执行时，访问了 AppModule 中定义的变量对象 Counter，那么闭包「Closure[A]」就产生了。</p><p>也就说，<strong>每一个 JS 模块都可以认为是一个独立的作用域，当代码执行时，该词法作用域创建执行上下文，如果模块内部，创建了可供外部引用访问的函数时，就为闭包的产生提供了条件，只要该函数在外部执行访问了模块内部的其他变量，闭包就会产生</strong>。</p><p>函数组件本质上就是一个函数，当我们在一个函数组件 A 中导入另一个函数组件 B，并在 A 中执行时 B 时，闭包就会产生。<br><a name="l9qsr"></a></p><h1 id="hooks-与闭包"><a href="#hooks-与闭包" class="headerlink" title="hooks 与闭包"></a>hooks 与闭包</h1><p>这是一个很常规的组件，我们用伪代码来分析下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Demo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 使用数组解构的方式，定义变量</span></span><br><span class="line">  <span class="keyword">const</span> [counter, setCounter] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCounter(counter + 1)&#125;&gt;hello world, &#123;counter&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看 useState 的伪代码实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SM</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> state = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">myUseState</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    state = state || value; <span class="comment">// 第一次调用没有初始值，因此使用传入的初始值赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">dispatch</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">      state = newValue;</span><br><span class="line">      <span class="comment">// 假设此方法能触发页面渲染</span></span><br><span class="line">      <span class="comment">// render()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [state, dispatch];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo 模块转为伪代码，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hooks与闭包</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">HooksAndClosure</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 验证：myUseState执行时闭包产生了</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">StateModule</span> = (<span class="keyword">function</span> <span class="title function_">SM</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> state = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">myUseState</span>(<span class="params">value</span>) &#123;</span><br><span class="line">      state = state || value; <span class="comment">// 第一次调用没有初始值，因此使用传入的初始值赋值</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">function</span> <span class="title function_">dispatch</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">        state = newValue;</span><br><span class="line">        <span class="comment">// 假设此方法能触发页面渲染</span></span><br><span class="line">        <span class="comment">// render()</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> [state, dispatch];</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> myUseState = <span class="title class_">StateModule</span>;</span><br><span class="line">  <span class="keyword">debugger</span>;</span><br><span class="line">  <span class="keyword">const</span> [counter, setCounter] = <span class="title function_">myUseState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">addCounter</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 调用setCounter时也会产生闭包</span></span><br><span class="line">    <span class="keyword">debugger</span>;</span><br><span class="line">    <span class="title function_">setCounter</span>(counter + <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>状态是如何被保存的<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;addCounter&#125;</span>&gt;</span>add Counter<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">HooksAndClosure</span>;</span><br></pre></td></tr></table></figure><p>StateModule 返回 内部函数 myUseState 赋值给 myUseState，myUseState<strong>执行时</strong>（第 22 行）访问了 StateModule 的 state 变量(第 8 行)，此时<strong>闭包对象「Closure(SM)」就产生了</strong>。<br /><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-18/20240227093858.png"></p><p>现在我们知道了<strong>调用 useState 会产生闭包</strong>，那么调用 setState 会不会产生闭包呢？答案是会<br /><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-18/20240227093955.png"><br /><br>可以看到，调用 dispatch 时，闭包对象<code>Closure(SM)</code>产生了，这个闭包对象保存着上次的 state 结果。</p>]]></content>
      
      
      
        <tags>
            
            <tag> hooks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>umijs/max 设计师指南</title>
      <link href="/2024/02/07/umijs-max-%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%8C%87%E5%8D%97/"/>
      <url>/2024/02/07/umijs-max-%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="Ant-design"><a href="#Ant-design" class="headerlink" title="Ant design"></a>Ant design</h1><p><a href="https://ant.design/index-cn">ant design</a> 是蚂蚁集团开源的组件库，我们公司项目使用 ant design V5 。设计师在设计时尽量贴合该组件库设计风格，节省开发成本。<br>首页包括<strong>定制主题</strong>，还有<strong>与研发相结合</strong>的一些介绍，可以了解下。<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708325384489.png" alt="pic.1708325384489"><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708325394155.png" alt="pic.1708325394155"></p><h1 id="定制主题"><a href="#定制主题" class="headerlink" title="定制主题"></a>定制主题</h1><p>进入<a href="https://ant.design/theme-editor-cn#component-style">主题编辑器</a>，页面如下，解释下该页面的功能：</p><ul><li>左侧为可视化配置面板，右侧为预览面板</li><li><strong>全局</strong>表示该配置对所有组件生效，<strong>组件</strong>则只对当前组件生效</li><li><strong>颜色</strong>可修改主题色相关变量，<strong>尺寸</strong>修改文字大小、间距，<strong>风格</strong>修改圆角、阴影</li><li>设计师修改配置后，导出配置文件发给前端开发人员即可<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708325448524.png" alt="pic.1708325448524"><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708325454691.png" alt="pic.1708325454691"></li></ul><h1 id="用于设计"><a href="#用于设计" class="headerlink" title="用于设计"></a>用于设计</h1><p>确定好主题变量之后，设计师可以根据主题变量的值，设置一套变量用于自己喜欢的设计平台，保持风格统一。<br><strong>在设计平台上定义的变量名与 ant design 主题变量名保持一致</strong>，具体有哪些变量，参考主题编辑器左侧配置面板。</p><p>推荐设计工具： <a href="https://kitchen.alipay.com/">kitchen</a>，<a href="https://www.yuque.com/kitchen/doc">使用文档</a><br>大大提升设计师与工程师的协作效率：<a href="https://www.yuque.com/kitchen/doc/custom-token">https://www.yuque.com/kitchen/doc/custom-token</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>视频合成流程图</title>
      <link href="/2024/02/07/%E8%A7%86%E9%A2%91%E5%90%88%E6%88%90%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
      <url>/2024/02/07/%E8%A7%86%E9%A2%91%E5%90%88%E6%88%90%E6%B5%81%E7%A8%8B%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708334059416.png" alt="pic.1708334059416"><br /><br>CrossPage.js 是一个简单的页面间通信模块，包括 CrossPageExchangeItem 类和 CrossPageExchange 类。<br />CrossPageExchangeItem 类用于创建一个新的通信项 exchangeItem，CrossPageExchange 类拥有 createItem&#x2F;getItem&#x2F;deleteItem 静态方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单的页面间通信的模块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CrossPageExchangeItem</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">id</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = id;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">setDataHandler</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cancelHandler</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getId</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">id</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onSetData</span>(<span class="params">cb</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">setDataHandler</span> = cb;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setData</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span>.<span class="property">setDataHandler</span> === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setDataHandler</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onCancel</span>(<span class="params">cb</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cancelHandler</span> = cb;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">cancel</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span>.<span class="property">cancelHandler</span> === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">cancelHandler</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">remove</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">setDataHandler</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="title class_">CrossPageExchange</span>.<span class="title function_">deleteItem</span>(<span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CrossPageExchange</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> latestId = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">static</span> items = <span class="keyword">new</span> <span class="title class_">Object</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">createItem</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> newItem = <span class="keyword">new</span> <span class="title class_">CrossPageExchangeItem</span>(<span class="variable language_">this</span>.<span class="property">latestId</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">latestId</span>] = newItem;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">latestId</span>++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newItem;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getItem</span>(<span class="params">id</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>[id] || <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">deleteItem</span>(<span class="params">id</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">items</span>[id];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="title class_">CrossPageExchange</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>WaitObject 类，它通过 Promise 提供了一种等待的机制。<br />wait 方法是一个异步函数，它等待 this.p 的状态被解决（resolved）。通过 await this.p ，函数回暂停执行，直到 this.p 被解决，然后返回被解决的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WaitObject</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">p</span> = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">resolve</span> = resolve;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">reject</span> = reject;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">wait</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">p</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="title class_">WaitObject</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a name="WJdT0"></a></p><h3 id="小程序异步模型"><a href="#小程序异步模型" class="headerlink" title="小程序异步模型"></a>小程序异步模型</h3><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708334106626.png" alt="pic.1708334106626"><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708334112205.png" alt="pic.1708334112205"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>code review</title>
      <link href="/2024/02/07/code-review/"/>
      <url>/2024/02/07/code-review/</url>
      
        <content type="html"><![CDATA[<p>一直觉得我主管浩哥是个很强的技术大佬，正好他让我接手了一个小程序项目，那么就来学习一下他写的代码吧！</p><h3 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h3><p>data 应只包括渲染相关的数据，所以这里如果只是为了保存定时器 ID，没必要使用 setData</p><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708405990424.png" alt="pic.1708405990424"><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708405995750.png" alt="pic.1708405995750"></p><p>建议将定时器 ID 保存在 this 上即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">  <span class="attr">timerId</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">onLoad</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化定时器</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">timerId</span> = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;定时器在运行&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">onUnload</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; timerId &#125; = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (timerId) &#123;</span><br><span class="line">      <span class="comment">// 清除定时器</span></span><br><span class="line">      <span class="built_in">clearInterval</span>(timerId);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将定时器ID设置为null</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">timerId</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>wx.request 封装</p><p>为什么执行<code>reject()</code>之后，还要执行 <code>resolve()</code>？<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406004196.png" alt="pic.1708406004196"></p><p>看到这里时，我有点疑惑，为什么执行<code>reject()</code>之后，还要执行 <code>resolve()</code>？<br>执行<code>reject()</code>之后，Promise 状态已经被固定了，再执行<code>resolve()</code>也没有意义。打了个断点（**f11 **step into next function call ）看下，发现<code>resolve(res)</code>并没有执行。</p><p>为了不造成混淆，建议在<code>res.data.code !== 0</code>代码块末尾加个<code>return</code>，或者在<code>reject()</code>前面加个<code>return</code><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406013027.png" alt="pic.1708406013027"></p><p>错误处理：通过自定义的错误类 <strong>ErrorRequest</strong>、<strong>ErrorBiz</strong> 和 <strong>ErrorAuth</strong> 对不同类型的错误进行了分类<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406020699.png" alt="pic.1708406020699"></p><p>看下控制台：<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406026545.png" alt="pic.1708406026545"></p><p>并没有提示错误信息输出。父类构造函数<code>Error</code>起到了什么作用？</p><p>点击 Error，如图所示：<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406032344.png" alt="pic.1708406032344"></p><p>可以看到构造函数<code>ErrorConstructor</code>接收一个 message 参数，那我们把接口的错误消息传递进去看下，修改下代码<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406042041.png" alt="pic.1708406042041"></p><p>效果如下：<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406047672.png" alt="pic.1708406047672"></p><p>修改过后在控制台展示了更详细的错误信息。</p><p>将后端的数据复制给 this.data <code>this.data = data</code>这点挺好的，这样，在捕获到错误之后，可以通过<code>error.data</code>来获取后端给的信息。</p><p>但是我没看到他是怎么使用的，所以我在错误类上加了个获取 this.data 的方法，方便在业务层面获取到：如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ErrorBiz</span> <span class="keyword">extends</span> <span class="title class_ inherited__">ErrorRequest</span> &#123;</span><br><span class="line">  <span class="comment">// 添加一个方法，用于获取业务错误信息</span></span><br><span class="line">  <span class="title function_">getBizErrorData</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务中使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> age = <span class="keyword">await</span> api.<span class="title function_">getPhotoCheckAge</span>(phoneUrl);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="keyword">const</span> bizErrorData = err.<span class="title function_">getBizErrorData</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="css"><a href="#css" class="headerlink" title="css"></a>css</h3><p>指向特定元素，通过附加类的预选元素的选择器，中间没有空格。如<code>.title.active</code><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406055781.png" alt="pic.1708406055781"></p><p>适配刘海屏设备安全区域，保证内容不被遮挡。</p><ol><li><strong>padding-bottom: env(safe-area-inset-bottom);：</strong><ul><li><strong>env()</strong> 函数是 CSS 中的一个环境变量函数，用于获取设备环境变量的值。</li><li><strong>safe-area-inset-bottom</strong> 表示底部安全区域的大小。</li><li>这行样式代码的作用是设置底部内边距为底部安全区域的大小。</li></ul></li><li><strong>padding-bottom: constant(safe-area-inset-bottom);：</strong><ul><li><strong>constant()</strong> 函数是 CSS 中的一个函数，用于获取一个常量的值。</li><li><strong>safe-area-inset-bottom</strong> 同样表示底部安全区域的大小。</li><li>这行样式代码的作用也是设置底部内边距为底部安全区域的大小，但使用了 <strong>constant</strong> 函数。</li></ul></li></ol><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406115148.png" alt="pic.1708406115148"></p><p>任务进度条<br>后端提供任务总时长，过了多少时间除以总时间就可以算出当前进度，<code>Math.round((Date.now() - startTime) / totalTime * 100)</code><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406070351.png" alt="pic.1708406070351"></p><h3 id="Js"><a href="#Js" class="headerlink" title="Js"></a>Js</h3><p>列表滚动加载，判断是否已全部加载结束<br><code>const isLoadEnd = respList.length &lt; this.data.pageSize</code>，也就说，如果本次请求响应的条数小于本次请求的条数，就可以表示已全部加载结束<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406077622.png" alt="pic.1708406077622"><br>不需要后端给你总页数<code>pages/total</code>，再根据<code>const isLoadEnd = current &lt; pages </code>或者 <code>const isLoadEnd = showList.length &lt; total</code>判断是否已全部加载结束</p>]]></content>
      
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音标</title>
      <link href="/2024/02/07/%E9%9F%B3%E6%A0%87/"/>
      <url>/2024/02/07/%E9%9F%B3%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<h1 id="主要音标体系"><a href="#主要音标体系" class="headerlink" title="主要音标体系"></a>主要音标体系</h1><h2 id="国际音标"><a href="#国际音标" class="headerlink" title="国际音标"></a>国际音标</h2><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708334606737.png" alt="pic.1708334606737"></p><h2 id="英音音标"><a href="#英音音标" class="headerlink" title="英音音标"></a>英音音标</h2><h3 id="DJ-音标：-Daniel-Jones"><a href="#DJ-音标：-Daniel-Jones" class="headerlink" title="DJ 音标： Daniel Jones"></a>DJ 音标： Daniel Jones</h3><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708334613426.png" alt="pic.1708334613426"></p><h3 id="新版-DJ-音标，也被叫做-Gimson-音标"><a href="#新版-DJ-音标，也被叫做-Gimson-音标" class="headerlink" title="新版 DJ 音标，也被叫做 Gimson 音标"></a>新版 DJ 音标，也被叫做 Gimson 音标</h3><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708334620624.png" alt="pic.1708334620624"></p><p>IPA63:1963 年版本的 DJ 音标</p><p>IPA88(Gimson):1988 年版本的 DJ 音标</p><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708334639629.png" alt="pic.1708334639629"></p><h2 id="美式音标"><a href="#美式音标" class="headerlink" title="美式音标"></a>美式音标</h2><h3 id="KK-音标"><a href="#KK-音标" class="headerlink" title="KK 音标"></a>KK 音标</h3><p>在台湾地区被广泛使用，基本也只在台湾使用<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708334722865.png" alt="pic.1708334722865"></p><h1 id="美式英语学哪种音标？"><a href="#美式英语学哪种音标？" class="headerlink" title="美式英语学哪种音标？"></a>美式英语学哪种音标？</h1><p><strong>DJ 音标 。</strong> 虽然是用来标记英式英语的，但是用来标记美式英语也毫无压力<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708334742662.png" alt="pic.1708334742662"><br>元音：</p><table><thead><tr><th><a href="https://zh.wikipedia.org/wiki/%E9%96%89%E5%89%8D%E4%B8%8D%E5%9C%93%E5%94%87%E5%85%83%E9%9F%B3">i</a>ː</th><th><a href="https://zh.wikipedia.org/wiki/%E6%AC%A1%E9%96%89%E6%AC%A1%E5%89%8D%E4%B8%8D%E5%9C%93%E5%94%87%E5%85%83%E9%9F%B3">ɪ</a></th><th><a href="https://zh.wikipedia.org/wiki/%E5%8D%8A%E9%96%89%E5%89%8D%E4%B8%8D%E5%9C%93%E5%94%87%E5%85%83%E9%9F%B3">e</a></th><th><a href="https://zh.wikipedia.org/wiki/%E6%AC%A1%E9%96%8B%E5%89%8D%E4%B8%8D%E5%9C%93%E5%94%87%E5%85%83%E9%9F%B3">æ</a></th><th><a href="https://zh.wikipedia.org/wiki/%E9%96%8B%E5%BE%8C%E4%B8%8D%E5%9C%93%E5%94%87%E5%85%83%E9%9F%B3">ɑ</a>ː</th><th><a href="https://zh.wikipedia.org/wiki/%E5%8D%8A%E9%96%8B%E5%BE%8C%E5%9C%93%E5%94%87%E5%85%83%E9%9F%B3">ɔ</a>ː</th><th><a href="https://zh.wikipedia.org/wiki/%E9%96%8B%E5%BE%8C%E5%9C%93%E5%94%87%E5%85%83%E9%9F%B3">ɒ</a></th><th><a href="https://zh.wikipedia.org/wiki/%E5%8D%8A%E9%96%8B%E5%BE%8C%E4%B8%8D%E5%9C%93%E5%94%87%E5%85%83%E9%9F%B3">ʌ</a></th><th><a href="https://zh.wikipedia.org/wiki/%E5%8D%8A%E9%96%8B%E5%A4%AE%E4%B8%8D%E5%9C%93%E5%94%87%E5%85%83%E9%9F%B3">ɜ</a>ː</th><th><a href="https://zh.wikipedia.org/w/index.php?title=%E4%B8%AD%E5%A4%AE%E6%AF%8D%E9%9F%B3&action=edit&redlink=1">ə</a></th></tr></thead><tbody><tr><td><a href="https://zh.wikipedia.org/wiki/%E9%96%89%E5%BE%8C%E5%9C%93%E5%94%87%E5%85%83%E9%9F%B3">u</a>ː</td><td><a href="https://zh.wikipedia.org/wiki/%E6%AC%A1%E9%96%89%E5%BE%8C%E5%9C%93%E5%94%87%E5%85%83%E9%9F%B3">ʊ</a></td><td>eɪ</td><td>əʊ</td><td>aɪ</td><td>aʊ</td><td>ɔɪ</td><td>ɪə</td><td>eə</td><td>ʊə</td></tr></tbody></table><table><thead><tr><th>无声子音</th><th><a href="https://zh.wikipedia.org/wiki/%E6%B8%85%E9%9B%99%E5%94%87%E5%A1%9E%E9%9F%B3">p</a></th><th><a href="https://zh.wikipedia.org/wiki/%E6%B8%85%E9%BD%92%E9%BD%A6%E5%A1%9E%E9%9F%B3">t</a></th><th><a href="https://zh.wikipedia.org/wiki/%E6%B8%85%E8%BB%9F%E9%A1%8E%E5%A1%9E%E9%9F%B3">k</a></th><th><a href="https://zh.wikipedia.org/wiki/%E6%B8%85%E5%94%87%E9%BD%92%E6%93%A6%E9%9F%B3">f</a></th><th><a href="https://zh.wikipedia.org/wiki/%E6%B8%85%E9%BD%92%E9%BD%A6%E6%93%A6%E9%9F%B3">s</a></th><th><a href="https://zh.wikipedia.org/wiki/%E6%B8%85%E9%BD%92%E6%93%A6%E9%9F%B3">θ</a></th><th><a href="https://zh.wikipedia.org/wiki/%E6%B8%85%E9%A1%8E%E9%BD%A6%E6%93%A6%E9%9F%B3">ʃ</a></th><th><a href="https://zh.wikipedia.org/wiki/%E6%B8%85%E9%A1%8E%E9%BD%A6%E5%A1%9E%E6%93%A6%E9%9F%B3">tʃ</a></th></tr></thead><tbody><tr><td>有声子音</td><td><a href="https://zh.wikipedia.org/wiki/%E6%BF%81%E9%9B%99%E5%94%87%E5%A1%9E%E9%9F%B3">b</a></td><td><a href="https://zh.wikipedia.org/wiki/%E6%BF%81%E9%BD%92%E9%BD%A6%E5%A1%9E%E9%9F%B3">d</a></td><td><a href="https://zh.wikipedia.org/wiki/%E6%BF%81%E8%BB%9F%E9%A1%8E%E5%A1%9E%E9%9F%B3">g</a></td><td><a href="https://zh.wikipedia.org/wiki/%E6%BF%81%E5%94%87%E9%BD%92%E6%93%A6%E9%9F%B3">v</a></td><td><a href="https://zh.wikipedia.org/wiki/%E6%BF%81%E9%BD%92%E9%BD%A6%E6%93%A6%E9%9F%B3">z</a></td><td><a href="https://zh.wikipedia.org/wiki/%E6%BF%81%E9%BD%92%E6%93%A6%E9%9F%B3">ð</a></td><td><a href="https://zh.wikipedia.org/wiki/%E6%BF%81%E9%A1%8E%E9%BD%A6%E6%93%A6%E9%9F%B3">ʒ</a></td><td><a href="https://zh.wikipedia.org/wiki/%E6%BF%81%E9%A1%8E%E9%BD%A6%E5%A1%9E%E6%93%A6%E9%9F%B3">dʒ</a></td></tr><tr><td>其他子音</td><td><a href="https://zh.wikipedia.org/wiki/%E9%9B%99%E5%94%87%E9%BC%BB%E9%9F%B3">m</a></td><td><a href="https://zh.wikipedia.org/wiki/%E9%BD%92%E9%BD%A6%E9%BC%BB%E9%9F%B3">n</a></td><td><a href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E9%A1%8E%E9%BC%BB%E9%9F%B3">ŋ</a></td><td><a href="https://zh.wikipedia.org/wiki/%E9%BD%BF%E9%BE%88%E8%BE%B9%E8%BF%91%E9%9F%B3">l</a>， <a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E9%A2%9A%E5%8C%96%E9%BD%BF%E9%BE%88%E8%BE%B9%E9%9F%B3">ɫ</a></td><td><a href="https://zh.wikipedia.org/wiki/%E9%BD%92%E9%BD%A6%E8%BF%91%E9%9F%B3">r</a></td><td><a href="https://zh.wikipedia.org/wiki/%E6%B8%85%E5%A3%B0%E9%97%A8%E6%93%A6%E9%9F%B3">h</a></td><td><a href="https://zh.wikipedia.org/wiki/%E6%BF%81%E5%9C%93%E5%94%87%E8%BB%9F%E9%A1%8E%E8%BF%91%E9%9F%B3">w</a></td><td><a href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E9%A1%8E%E8%BF%91%E9%9F%B3">j</a></td></tr></tbody></table><h1 id="发音过程"><a href="#发音过程" class="headerlink" title="发音过程"></a>发音过程</h1><p>浊音：气流向上，振动声带发出的音<br>轻音：气流向上，不振动声带发出的音<br>元音：气流通过口腔时不受阻碍发出的音，也就是舌头不与任何口腔部位接触，嘴唇也不能闭拢<br>辅音：与元音相反<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708334772339.png" alt="pic.1708334772339"></p><h1 id="元音三要素"><a href="#元音三要素" class="headerlink" title="元音三要素"></a>元音三要素</h1><p><strong>圆唇度、舌位高低、舌位前后</strong><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708334782287.png" alt="pic.1708334782287"></p><p>元音图：以视觉的方式表现元音三要素。<br>能抽象地描述咱们“感知到”的元音<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708334790903.png" alt="pic.1708334790903"><br>四边形之所以上大下小，是因为区分<strong>高元音和低元音舌位横向（前后）差别</strong>的大小</p><h1 id="辅音"><a href="#辅音" class="headerlink" title="辅音"></a>辅音</h1><h2 id="辅音发音分为三阶段"><a href="#辅音发音分为三阶段" class="headerlink" title="辅音发音分为三阶段"></a>辅音发音分为三阶段</h2><p>成阻(catch)：气流被阻塞<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708334803619.png" alt="pic.1708334803619"></p><p>持阻(hold)：气流持续向外冲，但仍被阻塞<br>双唇闭拢，但仍向外吐气（从而形成气压）<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708334810242.png" alt="pic.1708334810242"></p><p>除阻(release)：阻塞被去除，气流冲出<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708334815988.png" alt="pic.1708334815988"></p><h2 id="影响辅音发音的三要素"><a href="#影响辅音发音的三要素" class="headerlink" title="影响辅音发音的三要素"></a>影响辅音发音的三要素</h2><p><strong>清浊、调音部位、调音方式</strong></p><h3 id="清浊"><a href="#清浊" class="headerlink" title="清浊"></a>清浊</h3><p>清浊，也就是声带是否振动<br><em>中文没有清浊之分</em></p><p>清音：发音时声带不振动的音<br>浊音：发音时声带振动的音</p><h3 id="调音部位-发音部位"><a href="#调音部位-发音部位" class="headerlink" title="调音部位&#x2F;发音部位"></a>调音部位&#x2F;发音部位</h3><p>调音部位&#x2F;发音部位，也就是发辅音的时候，阻碍气流所用到的主要发音器官<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708334825883.png" alt="pic.1708334825883"><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708334831822.png" alt="pic.1708334831822"></p><h3 id="调音方式"><a href="#调音方式" class="headerlink" title="调音方式"></a>调音方式</h3><p>也可以叫做发音方式&#x2F;发音方法，可以理解为发音器官怎么阻挡气流（成阻），以及怎么释放气流（除阻）而发出辅音的</p><h4 id="塞音-爆破音"><a href="#塞音-爆破音" class="headerlink" title="塞音&#x2F;爆破音"></a>塞音&#x2F;爆破音</h4><p>如&#x2F;b&#x2F; 在成阻时完全阻塞气流再释放而发出的音，一般被称作“塞音”（stop;读 se，即阻塞的“塞”），或爆破音（plosive;学术界也称“爆发音”）</p><h4 id="擦音-摩擦音-fricative"><a href="#擦音-摩擦音-fricative" class="headerlink" title="擦音&#x2F;摩擦音(fricative)"></a>擦音&#x2F;摩擦音(fricative)</h4><p>如 “斯”的拼音[si]，用舌尖和牙齿形成一个缝隙，让气流通过，从而发出响声</p><h4 id="鼻音-nasal"><a href="#鼻音-nasal" class="headerlink" title="鼻音(nasal)"></a>鼻音(nasal)</h4><p>如“呢”的拼音[ne]，需要我们把气流送入鼻腔才能发出，这种称为“鼻音”(nasal)</p><p>还有其他音，如：颤音、闪音、近音、边近音（边音）等</p><h2 id="音标"><a href="#音标" class="headerlink" title="音标"></a>音标</h2><h3 id="p-清辅音"><a href="#p-清辅音" class="headerlink" title="&#x2F;p&#x2F; 清辅音"></a>&#x2F;p&#x2F; 清辅音</h3><p>调音方式属于“塞音”<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708334840624.png" alt="pic.1708334840624"><br>p 的三种常见情况（音位变体）：</p><ul><li>送气：单词如 peak</li><li>不送气：如 speak ，p 读 ‘b’，“斯比克”</li><li>无声除阻：如 trapdoor</li></ul><p>要想明确属于哪种情况，可以查看国际音标的严式注音，**[]**表示国际音标<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708334900568.png" alt="pic.1708334900568"></p><h3 id="b-浊辅音"><a href="#b-浊辅音" class="headerlink" title="&#x2F;b&#x2F; 浊辅音"></a>&#x2F;b&#x2F; 浊辅音</h3><p>调音方式属于“塞音”<br>&#x2F;b&#x2F; 声带不振动。<br>感觉声带有振动，是&#x2F;b&#x2F;后面的元音振动</p><h3 id="t-清辅音"><a href="#t-清辅音" class="headerlink" title="&#x2F;t&#x2F; 清辅音"></a>&#x2F;t&#x2F; 清辅音</h3><p>调音方式属于“塞音”<br>音位变体：</p><table><thead><tr><th>送气</th><th>t + 元音</th><th>top &#x2F;tɑːp&#x2F;</th></tr></thead><tbody><tr><td>不送气</td><td>s + t</td><td>stop &#x2F;stɑːp&#x2F; 和拼音”du”的声母”d”一样</td></tr><tr><td>无声除阻</td><td>t + 某些辅音</td><td>setback forget me t 不发音</td></tr><tr><td>闪音（flap）</td><td>元音之间的字母 t 在非重读音节</td><td>water better a lot of</td></tr><tr><td>鼻音除阻</td><td>&#x2F;t&#x2F; + &#x2F;n&#x2F;</td><td>eaten button certain</td></tr><tr><td>省略</td><td>&#x2F;n&#x2F; + &#x2F;t&#x2F;</td><td>t 可省略不读。winter 听上去像 winner。不省略也行</td></tr></tbody></table><h3 id="d-浊辅音"><a href="#d-浊辅音" class="headerlink" title="&#x2F;d&#x2F; 浊辅音"></a>&#x2F;d&#x2F; 浊辅音</h3><p>调音方式属于“塞音”<br>音位变体</p><table><thead><tr><th>无声除阻</th><th>landmine</th></tr></thead><tbody><tr><td>闪音</td><td>me<strong>d</strong>al</td></tr><tr><td>鼻音除阻</td><td>sudden</td></tr><tr><td>边音除阻</td><td>ba<strong>d</strong>ly</td></tr></tbody></table><h3 id="k-清辅音"><a href="#k-清辅音" class="headerlink" title="&#x2F;k&#x2F; 清辅音"></a>&#x2F;k&#x2F; 清辅音</h3><p>调音方式属于“塞音”<br>调音部位为“软腭”<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708334984742.png" alt="pic.1708334984742"><br>音位变体</p><table><thead><tr><th>送气</th><th>k + 元音</th><th>kite &#x2F;kaɪt&#x2F; 和”开”的声母一样</th></tr></thead><tbody><tr><td>不送气</td><td>s + k</td><td>sky &#x2F;skaɪ&#x2F; 和”该”的声母一样</td></tr><tr><td>无声除阻</td><td>k + 某些辅音</td><td>doctor &#x2F;‘dɑːktər&#x2F;</td></tr></tbody></table><h3 id="g-浊辅音"><a href="#g-浊辅音" class="headerlink" title="&#x2F;g&#x2F; 浊辅音"></a>&#x2F;g&#x2F; 浊辅音</h3><p>&#x2F;k&#x2F; &#x2F;g&#x2F; 中国人最常见的错误就是在末尾加元音<br>pick &#x2F;pɪk&#x2F; <del>匹克</del><br>pig &#x2F;pɪg&#x2F; <del>逼格</del></p><h3 id="m-浊辅音"><a href="#m-浊辅音" class="headerlink" title="&#x2F;m&#x2F; 浊辅音"></a>&#x2F;m&#x2F; 浊辅音</h3><p>常见错误发音:<br>很多人在&#x2F;m&#x2F;后加一个不存在的元音&#x2F;<a href="https://zh.wikipedia.org/wiki/%E9%96%89%E5%BE%8C%E5%9C%93%E5%94%87%E5%85%83%E9%9F%B3">u</a>ː&#x2F;或者&#x2F;<a href="https://zh.wikipedia.org/wiki/%E6%AC%A1%E9%96%89%E5%BE%8C%E5%9C%93%E5%94%87%E5%85%83%E9%9F%B3">ʊ</a>&#x2F;，如：<br>room &#x2F;r<a href="https://zh.wikipedia.org/wiki/%E9%96%89%E5%BE%8C%E5%9C%93%E5%94%87%E5%85%83%E9%9F%B3">u</a>ːm&#x2F; <del>乳母</del><br>home &#x2F;ho<a href="https://zh.wikipedia.org/wiki/%E6%AC%A1%E9%96%89%E5%BE%8C%E5%9C%93%E5%94%87%E5%85%83%E9%9F%B3">ʊ</a>m&#x2F; <del>后母</del><br>room &#x2F;t<a href="https://zh.wikipedia.org/wiki/%E9%96%89%E5%BE%8C%E5%9C%93%E5%94%87%E5%85%83%E9%9F%B3">u</a>ːm&#x2F; <del>兔母</del></p><h3 id="n-浊辅音"><a href="#n-浊辅音" class="headerlink" title="&#x2F;n&#x2F; 浊辅音"></a>&#x2F;n&#x2F; 浊辅音</h3><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708335132190.png" alt="pic.1708335132190"><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708335140937.png" alt="pic.1708335140937"><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708335150867.png" alt="pic.1708335150867"><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708335157571.png" alt="pic.1708335157571"><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708335163474.png" alt="pic.1708335163474"></p><h3 id="ŋ-浊辅音"><a href="#ŋ-浊辅音" class="headerlink" title="&#x2F;ŋ&#x2F; 浊辅音"></a>&#x2F;ŋ&#x2F; 浊辅音</h3><p>注意后鼻音<br>错误发音：<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708335179080.png" alt="pic.1708335179080"></p><h3 id="f-清辅音-v-浊辅音"><a href="#f-清辅音-v-浊辅音" class="headerlink" title="&#x2F;f&#x2F; 清辅音 &#x2F;v&#x2F; 浊辅音"></a>&#x2F;f&#x2F; 清辅音 &#x2F;v&#x2F; 浊辅音</h3><h3 id="s-清辅音-z-浊辅音"><a href="#s-清辅音-z-浊辅音" class="headerlink" title="&#x2F;s&#x2F; 清辅音 &#x2F;z&#x2F; 浊辅音"></a>&#x2F;s&#x2F; 清辅音 &#x2F;z&#x2F; 浊辅音</h3><h3 id="θ-清辅音-ð-浊辅音"><a href="#θ-清辅音-ð-浊辅音" class="headerlink" title="&#x2F;θ&#x2F; 清辅音 &#x2F;ð&#x2F; 浊辅音"></a>&#x2F;<a href="https://zh.wikipedia.org/wiki/%E6%B8%85%E9%BD%92%E6%93%A6%E9%9F%B3">θ</a>&#x2F; 清辅音 &#x2F;<a href="https://zh.wikipedia.org/wiki/%E6%BF%81%E9%BD%92%E6%93%A6%E9%9F%B3">ð</a>&#x2F; 浊辅音</h3><p>发<a href="https://zh.wikipedia.org/wiki/%E6%B8%85%E9%BD%92%E6%93%A6%E9%9F%B3">θ</a>时，舌尖在上下齿之间（被轻轻咬住）<br>&#x2F;<a href="https://zh.wikipedia.org/wiki/%E6%B8%85%E9%A1%8E%E9%BD%A6%E6%93%A6%E9%9F%B3">ʃ</a>&#x2F; 清辅音 &#x2F;<a href="https://zh.wikipedia.org/wiki/%E6%BF%81%E9%A1%8E%E9%BD%A6%E6%93%A6%E9%9F%B3">ʒ</a>&#x2F; 浊辅音<br>&#x2F;<a href="https://zh.wikipedia.org/wiki/%E6%B8%85%E9%A1%8E%E9%BD%A6%E6%93%A6%E9%9F%B3">ʃ</a>&#x2F; 上下齿不闭合。拼音“史”的调音部位更后一点，更接近硬腭，可以理解为更卷舌<br>&#x2F;<a href="https://zh.wikipedia.org/wiki/%E6%BF%81%E9%A1%8E%E9%BD%A6%E6%93%A6%E9%9F%B3">ʒ</a>&#x2F; 可以理解为声带振动的 &#x2F;<a href="https://zh.wikipedia.org/wiki/%E6%B8%85%E9%A1%8E%E9%BD%A6%E6%93%A6%E9%9F%B3">ʃ</a>&#x2F;<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708335220344.png" alt="pic.1708335220344"><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708335225855.png" alt="pic.1708335225855"></p><h3 id="tʃ-清辅音-dʒ-浊辅音"><a href="#tʃ-清辅音-dʒ-浊辅音" class="headerlink" title="&#x2F;tʃ&#x2F; 清辅音 &#x2F;dʒ&#x2F; 浊辅音"></a>&#x2F;<a href="https://zh.wikipedia.org/wiki/%E6%B8%85%E9%A1%8E%E9%BD%A6%E5%A1%9E%E6%93%A6%E9%9F%B3">tʃ</a>&#x2F; 清辅音 &#x2F;<a href="https://zh.wikipedia.org/wiki/%E6%BF%81%E9%A1%8E%E9%BD%A6%E5%A1%9E%E6%93%A6%E9%9F%B3">dʒ</a>&#x2F; 浊辅音</h3><p>&#x2F;<a href="https://zh.wikipedia.org/wiki/%E6%B8%85%E9%A1%8E%E9%BD%A6%E5%A1%9E%E6%93%A6%E9%9F%B3">tʃ</a>&#x2F; 属于“塞擦音”（阻塞+摩擦）<br>“吃”的调音部位更后一点，可以理解为更卷舌</p><p>&#x2F;<a href="https://zh.wikipedia.org/wiki/%E6%BF%81%E9%A1%8E%E9%BD%A6%E5%A1%9E%E6%93%A6%E9%9F%B3">dʒ</a>&#x2F; 可以理解为声带振动版的 &#x2F;<a href="https://zh.wikipedia.org/wiki/%E6%B8%85%E9%A1%8E%E9%BD%A6%E5%A1%9E%E6%93%A6%E9%9F%B3">tʃ</a>&#x2F;</p><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708335235178.png" alt="pic.1708335235178"><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708335239059.png" alt="pic.1708335239059"></p><p>&#x2F;h&#x2F; 清辅音<br>调音部位为声门</p><h3 id="w-浊辅音"><a href="#w-浊辅音" class="headerlink" title="&#x2F;w&#x2F; 浊辅音"></a>&#x2F;w&#x2F; 浊辅音</h3><p>和普通话“我”的声母一样</p><h3 id="r-浊辅音"><a href="#r-浊辅音" class="headerlink" title="&#x2F;r&#x2F; 浊辅音"></a>&#x2F;r&#x2F; 浊辅音</h3><p>音位变体：</p><table><thead><tr><th>齿龈近音</th><th>r + 元音</th><th>浊辅音 right &#x2F;raɪt&#x2F;</th></tr></thead><tbody><tr><td>r 化</td><td>元音 + r</td><td>这也是美音最大特征之一</td></tr><tr><td>car &#x2F;k<a href="https://zh.wikipedia.org/wiki/%E9%96%8B%E5%BE%8C%E4%B8%8D%E5%9C%93%E5%94%87%E5%85%83%E9%9F%B3">ɑ</a>ːr&#x2F; her &#x2F;h<a href="https://zh.wikipedia.org/wiki/%E5%8D%8A%E9%96%8B%E5%A4%AE%E4%B8%8D%E5%9C%93%E5%94%87%E5%85%83%E9%9F%B3">ɜ</a>ːr&#x2F;</td><td></td><td></td></tr></tbody></table><h3 id="j-浊辅音"><a href="#j-浊辅音" class="headerlink" title="&#x2F;j&#x2F; 浊辅音"></a>&#x2F;j&#x2F; 浊辅音</h3><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708335252017.png" alt="pic.1708335252017"><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708335258358.png" alt="pic.1708335258358"><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708335261737.png" alt="pic.1708335261737"><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708335265971.png" alt="pic.1708335265971"></p><p>&#x2F;l&#x2F;<br>3 种音位变体：<br>清晰 L：舌边音，是个浊辅音<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708335279609.png" alt="pic.1708335279609"><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708335283717.png" alt="pic.1708335283717"><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708335287884.png" alt="pic.1708335287884"><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708335292155.png" alt="pic.1708335292155"><br>不发音 L：没规律</p><p>&#x2F;ts&#x2F; 清辅音 &#x2F;dz&#x2F;<br>&#x2F;dz&#x2F;是浊辅音，可以理解为声带振动板的 &#x2F;ts&#x2F;</p><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708335304594.png" alt="pic.1708335304594"><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708335308829.png" alt="pic.1708335308829"><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708335314157.png" alt="pic.1708335314157"><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708335318842.png" alt="pic.1708335318842"></p><p>&#x2F;tr&#x2F; 清辅音 &#x2F;dr&#x2F; 浊辅音<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708335326300.png" alt="pic.1708335326300"><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708335331928.png" alt="pic.1708335331928"><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708335339170.png" alt="pic.1708335339170"><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708335347923.png" alt="pic.1708335347923"><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708335353758.png" alt="pic.1708335353758"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BEM规范</title>
      <link href="/2024/02/07/BEM%E8%A7%84%E8%8C%83/"/>
      <url>/2024/02/07/BEM%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="BEM-规范是什么"><a href="#BEM-规范是什么" class="headerlink" title="BEM 规范是什么"></a>BEM 规范是什么</h1><p>BEM 是 块(block) 、元素（element）、修饰符（modifier）的简写，由 Yandex 团队提出的一种 css 类命名约定。</p><ul><li>连字符：表示某个块或块子元素的多单词之间的连接符号</li></ul><p>__ 双下划线：连接块和块子元素</p><p>– 双连字符：作为块或块子元素的修饰符号</p><p>以这段 html 为例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;article&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;article__body&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;article__body-left&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;article__body-logo&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;icon&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;button button--primary&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;button button--default&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;article__footer article__footer--primary&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="block"><a href="#block" class="headerlink" title="block"></a>block</h2><p>block 表示组件的顶级抽象，它仅仅作为一个边界，<strong>不应该在 block 上添加样式和修饰</strong>。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="selector-class">.article</span> &#123;</span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-tag">__body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="selector-class">.article</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="element"><a href="#element" class="headerlink" title="element"></a>element</h2><p>element 表示 block 下的子元素，该元素依赖于块。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.article</span> &#123;</span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-tag">__body</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-tag">__footer</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<strong>元素下还嵌套子元素，均可用 <strong><code>**-**</code></strong> 连接</strong>，这样可以清楚的知道该元素的父级。</p><p><strong>像 <strong><code>**.icon**</code><strong>、</strong><code>**.button**</code></strong> 这种可以独立存在的子元素，避免创建不必要的父级。</strong><br>假如把 <code>.button</code> 命名为 <code>.article__body-button</code> ，后续的开发人员要在** **<code>.article__footer</code> 里用 <code>.article__body-button</code> 的样式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;article&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;article__body&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;article__body-left&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;article__body-logo&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;icon&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;article__body-button button--primary&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;article__body-button button--default&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;article__footer article__footer--primary&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 假设这里要用到article__body-button的样式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;article__body-button&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，<code>.article__body-button</code> 在 <code>.article__footer</code> 下，这会使代码变得混乱和不一致，应该避免这种情况的出现。</p><h2 id="modifier"><a href="#modifier" class="headerlink" title="modifier"></a>modifier</h2><p>修饰符，改变块或元素的样式。<br>如 <code>.button--primary</code>、<code>.article__footer--primary</code></p><h1 id="BEM-规范的优点"><a href="#BEM-规范的优点" class="headerlink" title="BEM 规范的优点"></a>BEM 规范的优点</h1><ol><li>当想要创建新组件时，我们可以容易的知道哪些修饰符和子组件已存在</li><li>从 html 结构上，能快速知道元素的依赖关系，如，我们用连接符 <code>-</code> 表示元素下的嵌套</li><li>统一的命名方式，方便团队成员的阅读</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>推荐用法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;article&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;article__body&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;article__body-left&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;article__body-logo&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;icon&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;button button--primary&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;button button--default&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;article__footer article__footer--primary&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.article</span> &#123;</span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-tag">__body</span> &#123;</span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-tag">-left</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-tag">-logo</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.icon</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.button</span> &#123;</span><br><span class="line">      <span class="selector-tag">&amp;</span><span class="selector-tag">--primary</span> &#123;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="selector-tag">&amp;</span><span class="selector-tag">--default</span> &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-tag">__footer</span> &#123;</span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-tag">--primary</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>block 不要添加修饰符和样式</li><li>element 下，子元素均用连接符 <code>-</code> 连接</li><li>element 下，没有后代的元素可用单个单词表示，方便复用</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BTC数据结构</title>
      <link href="/2024/02/07/BTC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/02/07/BTC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="hash-pointer-哈希指针"><a href="#hash-pointer-哈希指针" class="headerlink" title="hash pointer(哈希指针)"></a>hash pointer(哈希指针)</h1><p>在传统链表里，通过指针将各个节点串联起来。<br><strong>指针</strong>指的是一个节点对象在内存中的首地址。</p><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708405846740.png" alt="pic.1708405846740"></p><p>顾名思义，区块链也是一种链表结构，节点为区块。不过区块链并未采用指针，而是使用了<strong>哈希指针。</strong><br>如下图所示，该节点有两个指针指向这个节点（实际上为一个），其中 p 为该节点的地址，H()为该节点的哈希值，该值与节点中内容有关。当节点（区块）中内容发生变化，该哈希值也会发生改变，从而保证了区块内容不能被篡改。</p><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708405882862.png" alt="pic.1708405882862"></p><p>在比特币系统中，其最基本的数据结构便是一个个区块形成的<strong>区块链</strong>。</p><p>如图所示，每个区块根据自己的内容生成自己的哈希值，此外，每个区块（除创世纪块）都保存有前一个区块的哈希值。这保证了区块内容不被篡改。</p><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708405909365.png" alt="pic.1708405909365"></p><p>如果我们篡改 A 的值，而 B 中保存有 A 的哈希值，所以 B 也得进行修改，同样 B 后的区块也得修改。<br>这就是区块链区别与普通链表的区别：普通链接修改节点不会影响其他节点，而区块链牵一发而动全身，后面的节点都得跟着改。</p><p>所以用户只需要保存最后一个区块的哈希值，就可以检测出区块链上内容是否被篡改过。</p><p>由于这个特性，那么对于个人节点而言，就不需要完整的保存链上的所有的节点内容，只需要保存常用的父级几千个节点即可。</p><h1 id="merkle-tree-默克尔树"><a href="#merkle-tree-默克尔树" class="headerlink" title="merkle tree(默克尔树)"></a>merkle tree(默克尔树)</h1><p>merkle tree 是比特币系统中一个重要的数据结构。区别于 binary tree，merkle tree 用哈希指针代替了普通指针。<br>一个简单的 merkle tree：</p><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708405931818.png" alt="pic.1708405931818"></p><p>tree 中，A B C D 表是一个个交易(tx)，A 和 B 各有一个哈希值 H(1)和 H(2)，将其合并放在一个节点中，C 和 D 同理，然后针对得到的两个节点又可以得到新的哈希值，即为图中根节点。实际中，会对图中的根节点再取一次哈希，也就是 root hash。<br>该数据机构的优点在于：<strong>只需要记住 root hash，便可以检测出对树中任何部位的修改。</strong></p><p><strong>区块：</strong><br>每个区块分为两部分，包括块头(block header)和块身(block body)。<br>block header 中存储的是 root hash，但是 block header 没有交易的具体内容，block body 里存储的是交易列表。</p><p>merkle tree 的实际用途：可以用于提供 <strong>merkle proof。</strong></p><p>区块链中的节点分为<strong>轻节点</strong>和<strong>全节点</strong>。全节点保存整个区块的内容（block header 和 block body），而轻节点仅保存区块的块头信息（block header）。<br>那么就存在一个问题，轻节点想知道某个交易是否被写入到区块链上，该怎么办？打个比方，你向我转钱，我是个轻节点，我怎么知道这个交易已经被写到区块链里呢？</p><p>轻节点没有 block body，只有 root hash，那怎么证明某笔交易包含在这个 merkle tree 里呢？这就用到了 merkle proof。</p><h2 id="merkle-proof"><a href="#merkle-proof" class="headerlink" title="merkle proof"></a>merkle proof</h2><p>从交易一直到根节点的路径，就属于 merkle proof。</p><p>有了 merkle proof，轻节点就可以算出 merkle tree 里是否包含某笔交易。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过 merkle proof，可以验证计算得到的 root hash 是否与轻节点 block hader 里的 root hash 是否一致，如果一致说明该交易包含在 merkle tree 上。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> web3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ETH-以太坊概述</title>
      <link href="/2024/02/07/ETH-%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/02/07/ETH-%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p>BTC 和 ETH 是最主要的两种加密货币，BTC 称为区块链 1.0，以太坊称为区块链 2.0。<br>以太坊对比特币设计中的某些不足进行了改进，比例：出块时间、共识协议、mining puzzle(对内存要求高，反 ASIC 芯片使用) ，并且用权益证明（POS）替代工作量证明（POW）。除此之外，以太坊还增加了对<strong>智能合约（smart contract）</strong>的支持。</p><h1 id="为什么要开发智能合约"><a href="#为什么要开发智能合约" class="headerlink" title="为什么要开发智能合约"></a>为什么要开发智能合约</h1><p>BTC 是一种去中心化的货币，在比特币取得成功之后，很多人开始思考：如果货币可以去中心化，还有什么可以去中心化。<br>以太坊的一个特性就是增加了对去中心化合约的支持。</p><blockquote><p>BTC 货币中的最小单位为“聪”，Satoshi。ETH 的最小单位为“Wei”.</p></blockquote><h1 id="去中心化的合约"><a href="#去中心化的合约" class="headerlink" title="去中心化的合约"></a>去中心化的合约</h1><p>去中心化货币本身由政府发行，政府公信力为其背书，<strong>BTC 通过技术手段取代了政府的职能</strong>。<br>现实生活中，我们经常提到的“契约”或“合约”，其有效性也是需要政府进行维护的，如果产生纠纷，政府合法性合同进行判决。<strong>ETH 的设计目的就是，通过技术手段取代政府对于合约的职能</strong>。</p><p>去中心化的合同有什么好处：<br>若合同签署方并非一个国家，需要跨国转账，没有统一的司法管辖权（如：众筹）。如果可以编写无法修改的合约，一旦发布到区块链上，所有人（包括写智能合约的作者）只能按照制定的规则执行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> web3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BTC-共识协议</title>
      <link href="/2024/02/07/BTC-%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE/"/>
      <url>/2024/02/07/BTC-%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="数字货币存在的问题"><a href="#数字货币存在的问题" class="headerlink" title="数字货币存在的问题"></a>数字货币存在的问题</h1><p>数字货币本身为带有签名的数据文件，可以进行复制。即：对用户来说，可以将同一货币花费两次。这就是“双花攻击”。<br>如何解决：对货币添加唯一编号（不可篡改），每次支付向货币发行单位查询真伪。该方法每次交易都依赖于第三方机构来判断货币真伪且防止双花攻击。这是一个典型的第三方中心化方案。<br>现实中，我们的交易往往依赖于一个可信的第三方机构（支付宝、微信），这个机构具有较高的可信度，有政府背书，所以可以采用这种方案。<br>但是，很多场景下，并不存在这样一个可信赖的第三方机构。基于这个背景，以去中心化思想为核心的比特币系统便吸引了人们的注意力。</p><h1 id="去中心化需要解决的问题"><a href="#去中心化需要解决的问题" class="headerlink" title="去中心化需要解决的问题"></a>去中心化需要解决的问题</h1><ul><li>货币由谁发行，如何发行，什么时候发行？</li></ul><p>在比特币系统中由挖矿来决定货币发行权的发行量</p><ul><li>如何验证交易是否有效？如何防止双花攻击？</li></ul><p>该问题的解决，依赖于系统中维护的一个数据结构，记录货币的使用情况（是否被花过，被谁花过？）。该数据结构由系统中全体用户共同维护，保证了交易的有效性。该数据结构，便是区块链。<br>该数据结构中，有两种哈希指针，一种指向前面的区块，使得形成区块链，第二种(<strong>红色部分</strong>)则是为了说明比特币的来源。说明比特币的来源非凭空捏造，可以防止双花攻击。</p><p>如下，假如 A 获得<strong>铸币权</strong>，并发布了 10 个比特币（该交易称为铸币交易）。<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708405674927.png" alt="pic.1708405674927"></p><p>在进行交易时，A 给 B 转账，需要付款人的签名和收款人的地址（公钥的哈希）。收款方需要知道付款方的公钥（为了<strong>验证签名是否有效</strong>。实际上其他节点都需要知道付款方的公钥，<strong>验证交易合法性</strong>）。</p><p>这里存在一个问题：<br>:::info<br>假设 B 的同伙 B’，B’ 伪造一笔 A 到 B 的转账交易，用自己的公钥说是 A 的公钥，然后用假造的私钥签个名，别的节点收到这笔交易后，要假造的公钥去验证这个签名。验证结果肯定是对的，这让别的节点以为这个交易是合法的，这就出问题了。相当于把 A 账上的钱偷走了。<br>:::</p><p>解决这个问题的关键，就是第二种哈希指针。虽然 B’伪造了 A 到 B 的交易，但是实际中 A 转账的时候提供的公钥需要和铸币交易中的公钥对的上，如果对不上，说明该交易不合法。</p><h1 id="比特币区块信息"><a href="#比特币区块信息" class="headerlink" title="比特币区块信息"></a>比特币区块信息</h1><p>区块信息可以分为两部分：block header 和 block body<br>block header 由以下信息：</p><ul><li>version（版本协议）</li><li>hash of previous block header（指向前一个区块指针）</li><li>merkle root hash（默克尔树根哈希值）</li><li>target（挖矿难度目标阈值）</li><li>nonce（随机数）</li></ul><p>hash of previous block header 只计算区块头部部分的哈希（merkle root hash 保证了 block body 内容不被篡改，所以只需要计算 block header 即可保证整个区块内容不会被篡改）。<br>区块链中，轻节点（只存储区块 block header 信息）只利用区块链，并不参与区块链系统的维护和构造。</p><h1 id="比特币共识协议"><a href="#比特币共识协议" class="headerlink" title="比特币共识协议"></a>比特币共识协议</h1><p>投票方案：可行的投票方案前提是系统中的大多数节点时“好”的节点，在这种情况下进行共识协议设置。<br>比特币系统中，若直接投票，将某节点打包交易到区块，将其发给其他节点，其他节点检查该候选区块，检查若正确投赞成票，若票数过半，则加入区块链。存在以下问题：</p><ol><li>恶意节点不断打包不合法区块，导致一直无法达成共识</li><li>无强迫投票收到，某些节点可以不投票（行政不作为）</li><li>网络延迟未知，投票需要等待多久？</li><li>最重要的问题，比特币系统中任何人都可以创建账户，且建账户及其简单，若黑客使用计算机专门生成大量公私钥对，当其产生超过系统中一半数目，就可以获得支配地位（女巫攻击）</li></ol><p>所以比特币系统并没采用这种简单的账户数目方案，而是<strong>依据算力进行投票</strong>。每个节点都可以自行组装一个候选区块，然后尝试各种 nonce 值，这就是<strong>挖矿。</strong>当某个节点找到符合要求的 nonce<code>h(block header)&lt;=target</code>，便获得了<strong>记账权</strong>，从而可以将区块发布到系统中。其他节点收到区块后，验证区块合法性，如果绝大多数节点验证通过，则接口该区块为最新区块并加入到区块链。</p><h1 id="比特币激励机制"><a href="#比特币激励机制" class="headerlink" title="比特币激励机制"></a>比特币激励机制</h1><p>节点为什么要提供算力和电力成本去竞争记账权？<br>比特币引入奖励机制，通过设置<strong>出块奖励</strong>来解决该问题。<br>一个获得合法区块的节点，可以在去区块中加入一个特殊交易（铸币交易）。这也是唯一一种产生新比特币的途经。</p><blockquote><p>比特币系统规定，起初每个区块可以获得 50 个比特币，但之后每隔 21 万个区块，奖励减半</p></blockquote><p>区块中保存交易记录，如果仅仅设置出块奖励，那么，会不会存在节点只想发布区块获得出块奖励而不想打包交易？<br>比特币系统设计了 Tranction fee（交易费），对于获得记账权节点来说，除了出块奖励之外，还可以得到打包交易的交易费。但目前来说，交易费远远小于出块奖励。等到未来出块奖励变少，可能区块链的维护便主要依赖于交易费了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> web3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BTC密码学原理</title>
      <link href="/2024/02/07/BTC%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/"/>
      <url>/2024/02/07/BTC%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>比特币(bitcion)：基于去中心化，以区块链作为底层技术的加密货币。</p><h1 id="hash-哈希"><a href="#hash-哈希" class="headerlink" title="hash(哈希)"></a>hash(哈希)</h1><p>hash，可以简单理解为对某一事物的投影操作，即<code>A--&gt;Hash(A)</code>。<br>哈希函数(cryptographic hash function)主要有三个特性：</p><ul><li>collision resistance（碰撞反抗）</li><li>hiding（隐秘性）</li><li>puzzle friendly（谜题友好）</li></ul><p><strong>哈希碰撞：</strong><br>给定一个哈希函数，不同的输入，得到相同的输出，则称为 hash 碰撞。<br>如：给定 x 和 y，且 x!&#x3D;y，可以得到 Hash(x)&#x3D;Hash(y)。</p><h2 id="collision-resistance"><a href="#collision-resistance" class="headerlink" title="collision resistance"></a>collision resistance</h2><p>collision resistance(碰撞反抗)：表示对哈希碰撞具有<strong>抗碰撞性</strong>。<br>在实际应用中，哈希碰撞基本上难以避免，我们只要保证给定 x，很难找到一个 y，能够在 x!&#x3D;y 的前提下，使得 Hash(x)&#x3D;Hash(y)，就认为其是 collision resistance 的。</p><p>用处：如果我们自己有一条信息 x，我们希望别人知道我有 x 但不想让别人知道 x 具体是什么，就可以通过告诉其 Hash(x)，由于该性质，保证了 x!&#x3D;y 时，Hash(x)和 Hash(y)是不相等的。我们只需要告诉别人 Hash(x)即可，对方可以通过 Hash(x)知道你确实知道 x 这个信息，但他无法（很难）通过 Hash(x)反推出 x。</p><h2 id="hiding"><a href="#hiding" class="headerlink" title="hiding"></a>hiding</h2><p>我们认为，给定 x 和 Hash(),可以很容易得到 Hash(x),但没有办法在已知 Hash(x)和 Hash()的情况下，反推出 x 的具体取值，当然这也是一个理想的情况。</p><p><strong>digital commitment(数据保证)：collision resistance + hiding</strong><br>在视频中，肖老师提到关于股市预 测的案例，某个人对某个股票进行涨停预测，我们如何保证能够知晓其预测是否准确？最简单的是提前公布， 等待实际结果出现后验证。但实际中，当提前发布预测后，可能会由于预测者本身对股市实际结果造成影响。 所以，应该将提前将其写于纸上并密封，交给第三方机构保管，等到实际结果出现后开启密封与实际对比，这 就是 digital commitment。而第三方机构需要能够使人信服，在实际生活中，有很多场景并不存在一个这样的 第三方机构，而区块链技术正为此提供了一个很好的解决方法。 我们把预测结果看作 x，提前公布 Hash(x)，等 到预测结果发生时间来临后，公布 x，如果根据 x 可以得到公布的 Hash(x)，则说明公布的 x 确实为所预先预测的 内容。从而，我们可以实际进行判断预测是否准确。实际使用中，为了 x 足够大，会对 x 进行“加盐”，对 x 拼接一 个 nonce，对其整体取 Hash## puzzle friendly<br>在比特币系统中，还需要第三个性质 Puzzle friendly。该性质要求哈希值计算事先不可预测， 仅仅根据输入很难预测出输出。例如：我们需要一个哈希值，存在于某一个范围内，只能通过不停运算查找出来。<br>该性质保证了比特币系统中，只能通过“挖矿”获得比特币。<br>:::info<br>挖矿：试图通过暴力手段不断尝试，直到得到一个符合约定规则的 hash 值。这也是为什么挖矿是一个非常消耗算力的过程。<br>:::<br>也就是说，该性质保证了工作量证明(POW)机制 可以运行下去【“挖矿难，但验证易”】。</p><p><strong>SHA-256：</strong><br>在比特币系统中采用 SHA-256 哈希函数。该函数具备以上三个特性。<br>sha256 具有极强的抗碰撞性。目前为止，世界上最强的超级计算机也不具备人为制作碰撞的能力。</p><h1 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h1><p>比特币中账户管理 在第三方中心化系统中，账户开通依赖于第三方。但去中心化的比特币系统中，很明显不能 进行“申请账户”。<br>在比特币系统中，申请账户是用户自己来处理的，即自己创建一个公钥-私钥对（来自于非对称加密体系 asymmetric encryption algorithm）。公钥和私钥的应用保证了“签名”的应用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对称加密体系：提前商量好一个秘钥，加密和解密采用同一个秘钥。</span><br><span class="line">存在问题：秘钥显然不能以明文的方式在网络上传输，容易被盗取。</span><br></pre></td></tr></table></figure><p><strong>非对称加密体系：</strong><br><strong>用接收方的公钥加密，接收方的私钥解密</strong>。这就解决了对称加密体系中<strong>秘钥分发的问题</strong>。<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708405707415.png" alt="pic.1708405707415"></p><p>当在比特币网络中进行转账时，通过 <strong>“签名”可以明确是由哪个账户转出的，从而防止不良分子对其他账户比特币的盗取</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">加密，解决的是秘钥分发的问题；签名，解决的是明确由哪个账户转出的问题</span><br></pre></td></tr></table></figure><p>在发布交易时，<strong>通过发起方私钥签名</strong>，其他人可以<strong>根据发起方公钥进行验证</strong>，从而<strong>保证该交易由发起方发起</strong>。</p><p>也就是说，只有拥有私钥，才能将该账户中的比特币转走。 【注意：比特币系统中，很难通过生成大量公私钥对来获取他人私钥】</p>]]></content>
      
      
      
        <tags>
            
            <tag> web3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K线图</title>
      <link href="/2024/02/07/K%E7%BA%BF%E5%9B%BE/"/>
      <url>/2024/02/07/K%E7%BA%BF%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="技术难点"><a href="#技术难点" class="headerlink" title="技术难点"></a>技术难点</h1><h3 id="value-对应的纵坐标"><a href="#value-对应的纵坐标" class="headerlink" title="value 对应的纵坐标"></a>value 对应的纵坐标</h3><p>已知数据里的最大值<code>maxValue</code>、最小值<code>minValue</code>、y 轴的高度<code>yAxisHeight</code>，那么就可以得到 value 与<code>yAxisHeight</code>的比例<code>ratio</code>。想要得到刻度对应的数值，只需要将<strong>最小值+刻度间距<em>i</em>ratio</strong>即可。<br>比如最大值 1000，最小值 500，y 轴高度为 100px，那么 1px 所代表<code>(1000 - 500) / 100</code>，即 5。<br>如果 y 轴刻度间距为 30px，那么对应的数值为<code>500 + 30*i*ratio</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算Y轴刻度对应的数值：根据最大最小值动态变化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; i 刻度对应下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; maxValue 最大值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; minValue 最小值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; yAxisHeight y轴高度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; yAxisTickSpace y轴刻度间距</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> number 刻度对应的数值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">yAxisTickText</span> = (<span class="params"></span></span><br><span class="line"><span class="params">  i,</span></span><br><span class="line"><span class="params">  maxValue,</span></span><br><span class="line"><span class="params">  minValue,</span></span><br><span class="line"><span class="params">  yAxisHeight,</span></span><br><span class="line"><span class="params">  yAxisTickSpace</span></span><br><span class="line"><span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ratio表示value 与 y轴高度的比例</span></span><br><span class="line">  <span class="keyword">const</span> ratio = (maxValue - minValue) / yAxisHeight;</span><br><span class="line">  <span class="keyword">const</span> value = (minValue + yAxisTickSpace * i * ratio).<span class="title function_">toFixed</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="x-轴元素动态隔点展示"><a href="#x-轴元素动态隔点展示" class="headerlink" title="x 轴元素动态隔点展示"></a>x 轴元素动态隔点展示</h3><p>x 轴元素的数量是处于变化的，但 x 轴宽度是已知的，这样我们就能算出元素之间的间距<code>xAxisItemSpace</code>是多少。知道了<code>xAxisItemSpace</code>，那我们就能知道 x 轴刻度横坐标。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求x轴刻度横坐标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; i 下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; xAxisPointX x轴原点横坐标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; xAxisItemSpace x轴刻度间距</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> number x轴刻度横坐标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">xAxisTickPointX</span> = (<span class="params">i, xAxisPointX, xAxisItemSpace</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> xAxisPointX + i * xAxisItemSpace;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>缩放时，考虑当元素太多时，如果展示所有的元素，会出现拥挤的情况。所以我们只能展示部分元素。<br>隔点展示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绘制x轴刻度与文字</span></span><br><span class="line"><span class="keyword">const</span> xAxisItemMaxShowNumber = <span class="number">4</span>; <span class="comment">// 展示个数</span></span><br><span class="line"><span class="keyword">const</span> remainder = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(xAxisItemLength / (xAxisItemMaxShowNumber - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; xAxisItemLength; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> xAxisTickX = <span class="title function_">xAxisTickPointX</span>(i, originalPointX, xAxisItemSpace);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 隔点展示</span></span><br><span class="line">  <span class="keyword">if</span> (i % remainder === <span class="number">0</span> || i === xAxisItemLength - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="title function_">renderText</span>(</span><br><span class="line">      ctx,</span><br><span class="line">      xAxisTickX,</span><br><span class="line">      yAxisOriginPointY + tickWidth + <span class="number">10</span>,</span><br><span class="line">      myDataSource.<span class="property">current</span>.<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> x.<span class="property">date</span>)[i],</span><br><span class="line">      <span class="string">&quot;center&quot;</span>,</span><br><span class="line">      <span class="variable constant_">TEXT_COLOR</span>.<span class="property">PRIMARY</span></span><br><span class="line">    );</span><br><span class="line">    <span class="title function_">renderLine</span>(</span><br><span class="line">      ctx,</span><br><span class="line">      xAxisTickX,</span><br><span class="line">      yAxisOriginPointY,</span><br><span class="line">      xAxisTickX,</span><br><span class="line">      yAxisOriginPointY + tickWidth,</span><br><span class="line">      <span class="variable constant_">COLOR</span>.<span class="property">LINE</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三次贝塞尔曲线前后控制点"><a href="#三次贝塞尔曲线前后控制点" class="headerlink" title="三次贝塞尔曲线前后控制点"></a>三次贝塞尔曲线前后控制点</h3><p>受前后元素纵坐标影响，由前后两个点和当前点的纵坐标构成一个平行四边形，即可得到当前元素的前后控制点。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/12749457/1678068079434-6fc82755-de32-4c8e-b9d4-f7114edf76fc.jpeg"></p><p>还需要考虑首尾元素没有前后控制点的边界问题，所以要加入两个虚拟点。</p><h3 id="辅助线"><a href="#辅助线" class="headerlink" title="辅助线"></a>辅助线</h3><p>在 canvas 里，更新画布既是重选渲染整个画布，所以辅助线的绘制采用分层处理，创建一个新的画布覆盖上去，独立开来，不影响展示画布。</p><ol><li>监听鼠标移动事件<code>mousemove</code></li><li>清除画布</li><li>如果在 gird 区域，绘制辅助线和提示框</li></ol><h3 id="拖拽"><a href="#拖拽" class="headerlink" title="拖拽"></a>拖拽</h3><ol><li>监听鼠标按下事件<code>mousedown</code>，并创建拖动元素。可以做记忆化处理（优化手段）</li><li>监听开始拖动目标元素事件<code>dragstart</code>，并记录光标位置，即<code>event.offsetX</code></li><li>监听拖动事件<code>drag</code>，拖动过程中，达到一定距离，清除画布(clearRect)，然后更新要展示的数据，重新渲染即可</li><li>拖动结束时，需要隐藏拖动元素，并且如果左侧临时集合数据小于页数<code>pageSize</code>，<strong>请求接口数据</strong></li></ol><h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><ol><li>监听滚轮事件<code>wheel</code></li><li>放大<code>event.deltaY &gt; 0</code>时，删除展示集合<code>dataSource</code>前后数据，并分别扔到存储被删除数据的临时集合里，直到最小展示条数</li><li>缩小时「尽可能多的展示数据」，分两个情况，<ol><li>当已展示条数大于最大展示条数时 或 左侧临时集合条数小于最小展示条数时，<strong>请求接口</strong>并将请求数据合并到左侧临时集合中</li><li>删除临时集合的数据，并扔到展示集合中</li></ol></li><li>处理完数据，清除画布，重新渲染</li></ol><h1 id="应用层的思考"><a href="#应用层的思考" class="headerlink" title="应用层的思考"></a>应用层的思考</h1><p><strong>数据如何来：</strong><br><strong>初始时</strong>，默认展示为 10 条<code>pageSize=10</code>，最大展示条数为 20 条<code>maxShowSize = pageSize*2</code>，所以需要预准备 30 条数据<code>pageSize+maxShowSize</code>，也就是首次加载 30 条数据。<br><strong>更新时</strong></p><ol><li>拖拽什么时候请求新数据：拖拽结束后请求新数据</li></ol><p>因为一次最多拖<code>maxShowSize</code>，<strong>当左侧临时集合数据小于</strong><code>**maxShowSize**</code><strong>时</strong>，请求接口数据，请求<code>maxShowSize</code>条</p><ol start="2"><li>缩放什么时候请求新数据：缩放结束后，<strong>当左侧临时集合数据小于</strong><code>**maxShowSize**</code><strong>时</strong></li></ol><p>因为没有缩放结束事件，我们可以观察下缩放时的时间间隔，在<code>wheel</code>事件里打印<code>Date.now()</code>，发现滚动时间间隔在 200ms 以内，保险起见我们取个 500ms。<br>当滚动时间超过了 500ms，我们就判断为滚动结束：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">kWrapNode.<span class="title function_">addEventListener</span>(<span class="string">&quot;wheel&quot;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 先判断是否停止 2.停止后做什么</span></span><br><span class="line">  <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 模拟缩放结束事件</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">wheelStop</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 滚动停止时执行的代码</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&quot;wheelStop&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (leftDataSource.<span class="property">length</span> &lt; maxShowSize) &#123;</span><br><span class="line">      <span class="comment">// 请求数据</span></span><br><span class="line">      <span class="title function_">loadData</span>(maxShowSize, dataSource[<span class="number">0</span>].<span class="property">date</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        leftDataSource = [...res, ...leftDataSource];</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  timer = <span class="built_in">setTimeout</span>(wheelStop, <span class="number">500</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 项目场景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Map和Set、Map和Object的区别</title>
      <link href="/2024/02/07/Map%E5%92%8CSet%E3%80%81Map%E5%92%8CObject%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2024/02/07/Map%E5%92%8CSet%E3%80%81Map%E5%92%8CObject%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="Map-和-Object-的区别"><a href="#Map-和-Object-的区别" class="headerlink" title="Map 和 Object 的区别"></a>Map 和 Object 的区别</h1><p><strong>特性上的区别：</strong></p><p>Map 更适合”键值对”这种数据结构。Object 的键只能是 string、整数、Symbol 类型，Map 的键可以是任意类型。</p><p>Map 实现了迭代协议，可用 for…of 遍历，而 Object 不行, Object 是不可迭代的。</p><p>Map 可用 size 属性获取长度，而 Object 没有获取长度的属性。</p><p>Map 遍历顺序可以保证，按插入时输出。<br>而 Object 无法保证，Object 的遍历顺序为：</p><ul><li>当 key 类型为<code>Number</code>，按 key 从小到大排序</li><li>当 key 类型为<code>String</code>，会被转为<code>Number</code>类型，按 key 从小到大排序</li><li>当 key 类型为<code>Symbol</code>，按创建的时间升序排序</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">obj[<span class="string">&quot;jack&quot;</span>] = <span class="number">1</span>;</span><br><span class="line">obj[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">obj[<span class="string">&quot;4&quot;</span>] = <span class="number">3</span>;</span><br><span class="line">obj[<span class="number">5</span>] = <span class="number">3</span>;</span><br><span class="line">obj[<span class="string">&quot;2&quot;</span>] = <span class="number">3</span>;</span><br><span class="line">obj[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">obj[<span class="string">&quot;tom&quot;</span>] = <span class="number">4</span>;</span><br><span class="line">obj[<span class="string">&quot;toni&quot;</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//填入Object的元素key是自动按照字符串排序的，数字排在前面，且升序拍戏，字符串在后</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(k); <span class="comment">// 0 1 2 5 jack tom toni</span></span><br><span class="line">  <span class="comment">// console.log(typeof k); // 都是string，因为都会调用对象的toString()方法, key.toString()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>当数据量大（长度为十几万以上）的时候，Map 的读入、写入、删除会比 Object 更快，数据量小的时候差别不多，object 稍微好一点点点</strong></p><p><strong>Map 的使用场景：</strong></p><ul><li>聊天内容与聊天列表<ul><li>数据量大、频繁的写入、更新、对写入顺序有要求</li></ul></li><li>策略模式<ul><li>用于储存多个键值对应一个规则的情况</li></ul></li></ul><h1 id="Map-和-Set-的应用"><a href="#Map-和-Set-的应用" class="headerlink" title="Map 和 Set 的应用"></a>Map 和 Set 的应用</h1><p>set:</p><ol><li>去重</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>]))<span class="comment">// [1,2,3,4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line">[...<span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>])] <span class="comment">// [1,2,3,4]</span></span><br></pre></td></tr></table></figure><ol start="2"><li>取并集、交集、差集</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"><span class="keyword">const</span> arr2 = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//并集</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Set</span>([...arr1, ...arr2]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Set</span>([...arr1].<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> arr2.<span class="title function_">has</span>(item)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Set</span>([...arr1].<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> !arr2.<span class="title function_">has</span>(item)));</span><br></pre></td></tr></table></figure><p>map:<br>可以使用任意的数据类型作为键，比对象更合适</p><h1 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a>Array.from</h1><p>可以将类数组和可遍历（iterator）对象转换为真正的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>])); <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure><h1 id="Map-和-Set-的区别"><a href="#Map-和-Set-的区别" class="headerlink" title="Map 和 Set 的区别"></a>Map 和 Set 的区别</h1><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><p>Set 结构类似于数组，成员唯一，没有排序的概念。Map 结构它保存的是键值对的集合。</p><p>添加成员的方法不同：<br>Set 使用 add 方法 ，如：set.add(6)，Map 使用 set 方法，如 map.set(‘key’, ‘value’)</p><p>获取成员的方法不同：<br>Set 结构没有排序的概念，无法获取单个成员。Map 结构使用 map.get(‘key’) 获取成员的值。</p><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><p>Map 和 Set 都是 es 的新增的数据结构。</p><p>拥有同样的遍历方法：<br>keys()、values()、entries()、forEach()</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise</title>
      <link href="/2024/02/07/Promise/"/>
      <url>/2024/02/07/Promise/</url>
      
        <content type="html"><![CDATA[<h1 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h1><p>同步是指发起一个请求时，如果未得到请求结果，代码逻辑将会等待，直到结果出来才会继续执行之后的代码。</p><p>异步是指当发起一个请求时，不会等待请求结果，直接继续执行后面的代码。请求结果的处理逻辑，会添加一个监听，等到反馈结果出来后，在回调函数中处理对应的逻辑。</p><p>使用 Promise 模拟一个发起请求的函数，该函数在 1s 之后返回数值 30。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="number">30</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res)); <span class="comment">// 输出 30</span></span><br></pre></td></tr></table></figure><p>在该函数的基础上，我们可以使用 async&#x2F;await 来模拟同步的效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> res = <span class="keyword">await</span> <span class="title function_">fn</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;next code&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// 30</span></span><br><span class="line"><span class="comment">// next code</span></span><br></pre></td></tr></table></figure><p>而异步效果则会有不同的输出</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">fn</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;next code&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// next code</span></span><br><span class="line"><span class="comment">// 30</span></span><br></pre></td></tr></table></figure><h1 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h1><p>ajax 是网页与服务端进行数据交互的一种技术。<br>我们可以通过服务端提供的接口，利用 ajax 向服务端请求需要的数据</p><p>整个过程的简单实现如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&quot;http: www.demo.com/user/info&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">XHR</span> = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="variable constant_">XHR</span>.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, url, <span class="literal">true</span>);</span><br><span class="line"><span class="variable constant_">XHR</span>.<span class="title function_">send</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">XHR</span>.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable constant_">XHR</span>.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; <span class="variable constant_">XHR</span>.<span class="property">state</span> == <span class="number">200</span>) &#123;</span><br><span class="line">    result = <span class="variable constant_">XHP</span>.<span class="property">reponse</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这看起来没什么麻烦的，但是这时候，如果我们还需要做另一个 ajax 请求，这个请求的参数是从上一个 ajax 请求中获取的，那么我们就不得不如下这么做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&quot;http: www.demo.com/user/info&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">XHR</span> = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line"><span class="variable constant_">XHR</span>.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, url, <span class="literal">true</span>)</span><br><span class="line"><span class="variable constant_">XHR</span>.<span class="title function_">send</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">XHR</span>.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable constant_">XHR</span>.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; <span class="variable constant_">XHR</span>.<span class="property">state</span> == <span class="number">200</span>) &#123;</span><br><span class="line">    result = <span class="variable constant_">XHP</span>.<span class="property">reponse</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 伪代码2</span></span><br><span class="line">    <span class="keyword">var</span> url2 = <span class="string">&#x27;http:xxx.yyy.com/zzz?ddd=&#x27;</span> + result.<span class="property">someParams</span>;</span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">XHR2</span> = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    <span class="title class_">XHR2</span>.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, url, <span class="literal">true</span>);</span><br><span class="line">    <span class="title class_">XHR2</span>.<span class="title function_">send</span>();</span><br><span class="line">    <span class="title class_">XHR2</span>.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当出现第三个（甚至更多）仍然依赖上一个请求的时候，代码就变成了一场灾难。</p><p>我们需要不停的嵌套回调函数。这样的灾难，我们称之为 <strong>回调地狱。</strong></p><p>**Promise **可以帮助我们解决这个问题。</p><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>我们知道，如果要确保代码在谁之后执行，可以利用函数调用栈，将想要执行的代码放入回调函数中。<br>如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">want</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这是你想要执行的代码&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">want</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这里表示执行了一大堆其他代码&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其他代码执行完后，最后执行回调函数</span></span><br><span class="line">  want &amp;&amp; <span class="title function_">want</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>(want);</span><br></pre></td></tr></table></figure><p>或者可以利用任务队列</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">want</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这是你想要执行的代码&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">want</span>) &#123;</span><br><span class="line">  <span class="comment">// 根据事件循环的机制，我们就不用非得将代码放在最后面了，由你自由选择</span></span><br><span class="line">  want &amp;&amp; <span class="built_in">setTimeout</span>(want, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这里表示执行了一大堆其他代码&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>(want);</span><br></pre></td></tr></table></figure><p>与 setTimeout 类似， Promise 也可以认为是一种任务分发器，它将任务分发到 PromiseJobs 执行队列中。通常的用法是，我们发起一个请求，然后等待并处理请求结果。</p><p>简单用法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (tag) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Promise 是一个对象，保存着未来某一时刻才会执行的事件。</p><p>我们常使用 Promise 来解决反馈结果需要等待的场景。</p><p>例如</p><ul><li>前端向服务端发送一个接口请求。请求结果不会马上返回，而是需要等待一段时间。</li><li>加载图片，需要等待一段时间</li><li>弹窗中，等待用户点击确认或者取消</li></ul><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="创建-Promise-实例"><a href="#创建-Promise-实例" class="headerlink" title="创建 Promise 实例"></a>创建 Promise 实例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>();</span><br></pre></td></tr></table></figure><p>Promise 函数中的第一个参数为一个回调函数，我们可以称之为 <strong>executor</strong> 。通常情况下，在这个函数中，我们将会执行发起请求操作，并修改结果的状态值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="title function_">reject</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>状态有三种</p><ol><li>pending：等待结果状态</li><li>fulfilled：已出结果，结果符合预期完成状态</li><li>rejected：已出结果，结果未符合预期完成状态</li></ol><p>promise 表达的就是从发起请求开始，从没有结果 padding 到有结果 fulfilled&#x2F;rejected 的一个过程。</p><p>在 executor 函数中，我们可以分别使用 resolve 与 reject 将状态修改为对应的 fulfilled 与 rejected.</p><p>resolve&#x2F;reject 是 executor 函数的两个参数。他们能够将请求结果的具体数据传递出去。</p><ol><li>Promise 实例拥有 <code>then</code> 方法，用来处理请求结果变为 fulfilled 状态时的逻辑。<code>then</code>的第一个参数也是一个回调函数，该函数的参数则是 resolve 传递出来的数据。第二个参数用来处理 rejected 状态时的逻辑。</li><li>Promise 实例拥有 <code>catch</code>方法，用来处理请求结果变为 rejected 时的逻辑。<code>catch</code>的第一个参数也是一个回调函数，该函数的参数则是 reject 传递出来的数据。</li></ol><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>写个例子感受一下 Promise 的用法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">// 模拟一个请求，2s 后得到结果</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> num == <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(num);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> err = num + <span class="string">&quot; is not a number&quot;</span>;</span><br><span class="line">        <span class="title function_">reject</span>(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(resp);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意观察该语句的执行顺序</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;next code&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>then</code>方法可以接收两个参数，第一个参数用来接收 fulfilled 状态的逻辑，第二个参数用来处理 rejected 状态的逻辑。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fn</span>(<span class="string">&quot;abc&quot;</span>).<span class="title function_">then</span>(</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">resp</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(resp);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>因此 <code>catch</code> 方法其实与下面的写法等价。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fn</span>(<span class="string">&quot;abc&quot;</span>).<span class="title function_">then</span>(<span class="literal">null</span>, <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(er);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>then</code>方法返回的仍然是一个 Promise 实例对象，因此 then 方法可以链式调用，通过在内部 return 的方式，能够将数据持续往后传递。</p><h3 id="封装-ajax"><a href="#封装-ajax" class="headerlink" title="封装 ajax"></a>封装 ajax</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&quot;http://www.demo.com/user/info&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装一个get请求的方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getJSON</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">// 利用ajax发送一个请求</span></span><br><span class="line">    <span class="keyword">var</span> <span class="variable constant_">XHR</span> = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    <span class="variable constant_">XHR</span>.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, url, <span class="literal">true</span>);</span><br><span class="line">    <span class="variable constant_">XHR</span>.<span class="title function_">send</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待结果</span></span><br><span class="line">    <span class="variable constant_">XHR</span>.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable constant_">XHR</span>.<span class="property">readyState</span> == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable constant_">XHR</span>.<span class="property">status</span> == <span class="number">200</span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> response = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable constant_">XHR</span>.<span class="property">responseText</span>);</span><br><span class="line">            <span class="comment">//  得到正确的结果修改状态并将数据传递出去</span></span><br><span class="line">            <span class="title function_">resolve</span>(response);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 得到错误结果并抛出异常</span></span><br><span class="line">          <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable constant_">XHR</span>.<span class="property">statusText</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装好之后，使用就很简单了</span></span><br><span class="line"><span class="title function_">getJSON</span>(url).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(resp);</span><br><span class="line">  <span class="comment">// 之后就是处理数据的具体逻辑</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p>当有一个 ajax 请求，它的参数需要另外 2 个甚至更多请求都有了结果之后才能确定，那么这个时候，就需要 Promise.all 来帮助我们应该这个场景。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>Promise.all 接收一个由 Promise 对象组成的数组作为参数，当 Promise 对象状态都变成 fulfilled 的时候，才会去调用 then 方法。</p><p>如果其中一个 Promise 对象状态变成 rejected，那么 p 的状态就会变成 rejected，第一个被 reject 的实例的返回值会传递给回调函数。</p><p>如果作为参数的 Promise 实例，自己定义了 catch 方法，那么它一旦被 rejected，并不会触发 Promise.all() 的 catch() 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p5 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p6 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;报错了&quot;</span>);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p5, p6])</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// [&quot;hello&quot;, Error: 报错了]</span></span><br></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>与 Promise.all 相似的是，Promise.race 也是接收一个 Promise 对象组成的数组作为参数，不同的是，只要当数组中的一个 Promise 状态变为 fulfilled 或者 rejected 时，就可以调用 .then 方法了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>Promise.race 可以理解为 Promise 实例赛跑，哪个实例有了状态就返回哪个，通常用于处理规定时间内请求超时的情况。</p><p>如果 5 秒之内请求无法返回结果，变量 p 的状态就会变为 rejected，从而触发 catch 方法指定的回调函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 模拟请求，10秒后返回数据</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">10000</span>, <span class="string">&quot;my name is a&quot;</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理请求超时</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(reject, <span class="number">5000</span>, <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;超时了&quot;</span>));</span><br><span class="line">  &#125;),</span><br><span class="line">])</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err: &quot;</span>, err);</span><br><span class="line">    <span class="title function_">alert</span>(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="all-和-race-的区别"><a href="#all-和-race-的区别" class="headerlink" title="all 和 race 的区别"></a>all 和 race 的区别</h3><p>all 接受一个数组，数组成员是 promise 实例对象，如果 promise 的状态都为成功，则返回一个数组，如果其中一个失败，那么就会执行 catch</p><p>race 表示赛跑，参数和 all 一样，race 返回的是状态最先完成的 promise 的结果，不管成功还是失败<br>我们一般用 race 处理接口超时的情况。</p><p>以下代码，如果 5 秒之内请求无法返回结果，promise 状态就会变为 rejected，从而触发 catch 方法指定的回调函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 模拟请求，10秒后返回数据</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">10000</span>, <span class="string">&quot;my name is a&quot;</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理请求超时</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(reject, <span class="number">5000</span>, <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;超时了&quot;</span>));</span><br><span class="line">  &#125;),</span><br><span class="line">])</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err: &quot;</span>, err); <span class="comment">// err:  Error: 超时了</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="async-await"><a href="#async-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h3><p>异步问题除了使用 Promise 来解决之外，还可以使用 ES7 中新增的语法 async&#x2F;await 来搞定。</p><p>在函数声明前面，加上关键字 <code>async</code>，这就是 async 的具体使用了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">30</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后我们查看一下 fn 的运行结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// result</span></span><br><span class="line"><span class="title class_">Promise</span> = &#123;</span><br><span class="line">  <span class="attr">__proto__</span>: <span class="title class_">Promise</span>,</span><br><span class="line">  [[<span class="title class_">PromiseStatus</span>]]: <span class="string">&quot;resolved&quot;</span>,</span><br><span class="line">  [[<span class="title class_">PromiseValue</span>]]: <span class="number">30</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>发现 fn 函数运行返回的是一个标准的 Promise 对象。也就是说 async 其实就是 Promise 的一个语法糖，目的是为了让写法更加简单。于是，我们可以使用 Promise 的相关语法来处理后续的逻辑</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fn</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// 30</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>await</strong> 含义为等待，意思就是需要等待 await 后面函数运行完了，并且有了返回结果，才能继续执行下面的代码。这正是同步的效果。</p><p>需要注意的是，await 关键字只能在 async 函数中使用。并且 await 后面的函数运行后必须返回一个 Promise 对象才能实现同步的效果。</p><p>当我们使用一个变量去接收 await 的返回值时，该返回值为 Promise 中 resolve 传递出来的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="number">30</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> t = <span class="keyword">await</span> <span class="title function_">fn</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;t&quot;</span>, t);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;next code&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// t: 30</span></span><br><span class="line"><span class="comment">// next code</span></span><br></pre></td></tr></table></figure><p>从例子中我们可以看出，在 async 函数中，遇到 await 时，就会等待 await 后面的函数运行完毕，而不会直接执行 next code。</p><p>如果我们直接使用 then 方法，就不得不把后续的逻辑写在 then 方法中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fn</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">t</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;t: &quot;</span>, t);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;next doce&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure><p>很明显，如果使用 async&#x2F;await 的话，代码会更简洁，逻辑也更清晰。</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>在 Promise 中，我们使用 catch 方法来捕获异常，而不是使用 then 的第二个参数。因为：</p><ol><li>更接近同步的语法（try&#x2F;catch）</li><li>then 中的错误也会被 catch 捕获</li></ol><p>使用 then 的第二个参数，并不能捕获到第一个参数内部抛出的错误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">123</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p3.<span class="title function_">then</span>(</span><br><span class="line">  <span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;is err&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;error&quot;</span>, error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// 123</span></span><br><span class="line"><span class="comment">// Uncaught (in promise) Error: is err</span></span><br></pre></td></tr></table></figure><p>使用 catch ，则可以捕获到上一个 then 内部抛出的错误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">123</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p3.<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;is err&quot;</span>);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;error&quot;</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// 123</span></span><br><span class="line"><span class="comment">// error Error: is err</span></span><br></pre></td></tr></table></figure><p>而使用 async 时，我们使用 try&#x2F;catch 来捕获异常。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="string">&quot;some error&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">fn</span>();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;e: &quot;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure><p>如果有多个 await ，只会捕获到第一个异常</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="string">&quot;some error fn1&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="string">&quot;some error fn2&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">fn1</span>();</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">fn2</span>();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;e: &quot;</span>, e); <span class="comment">// some error fn1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>如何封装与使用息息相关。</p><h2 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h2><p>封装一个加载图片的函数，Promise 的使用如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">imageLoad</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">  img.<span class="property">src</span> = url;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    img.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">&quot;图片加载成功&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    img.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="string">&quot;图片加载失败&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们就可以使用 imageLoad 来执行图片加载完成之后的逻辑。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">imageLoad</span>(<span class="string">&quot;xxx.png&quot;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(res);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>封装的核心关键是： Promise 的最终目的是，为了执行 then 中的回调函数，我们称它为 <code>then_cb</code>。</p><p>所以在封装的时候，我们就应该思考如何在 Promise 内部，让 <code>then_cb</code>执行。</p><h2 id="简易版-MyPromise"><a href="#简易版-MyPromise" class="headerlink" title="简易版 MyPromise"></a>简易版 MyPromise</h2><p>显而易见，Promise 包含原型方法 then，构造函数需要传递回调函数 <code>executor</code>，该回调函数包含两个参数，resolve 与 reject 。</p><p>根据这些特点，我们得出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  construcotr (executor) &#123;</span><br><span class="line">    <span class="title function_">executor</span>(<span class="variable language_">this</span>.<span class="property">_resolve</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="variable language_">this</span>.<span class="property">_reject</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _resolve (value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  _reject () &#123;&#125;</span><br><span class="line"></span><br><span class="line">  then (then_cb) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>目的是为了调用 then_cb ，通过封装加载图片可以发现，调用 resolve 时，then_cb 才会执行，所以可以得出结论， <strong>then_cb 的执行需要被 resolve 触发</strong>。</p><p>我们可以通过保存 then_cb 引用的方式来解决。所以代码就变成了这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">thenCallback</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">executor</span>(<span class="variable language_">this</span>.<span class="property">_resolve</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="variable language_">this</span>.<span class="property">_reject</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">_resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">thenCallback</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">_reject</span>(<span class="params">value</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">then</span>(<span class="params">then_cb</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">thenCallback</span> = then_cb;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，再解决 catch 回调函数的执行问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">thenCallback</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">rejectCallback</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="title function_">executor</span>(<span class="variable language_">this</span>.<span class="property">_resolve</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="variable language_">this</span>.<span class="property">_reject</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">_resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">thenCallback</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">_reject</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">rejectCallback</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">then</span>(<span class="params">then_cb, onRejected</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">thenCallback</span> = then_cb;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">rejectCallback</span> = onRejected;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">null</span>, onRejected);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不追求别的特性，我们的 Promise 对象就已经封装好了，并且可以使用了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// resolve(&#x27;123&#x27;)</span></span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&quot;some err&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// p.then(res =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   console.log(res);</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">p.<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> [<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err&quot;</span>, err)]);</span><br></pre></td></tr></table></figure><p>再模拟将 then_cb 放入队列中执行，简单调整如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">thenCallback</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">rejectCallback</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="title function_">executor</span>(<span class="variable language_">this</span>.<span class="property">_resolve</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="variable language_">this</span>.<span class="property">_reject</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">_resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="comment">// this.thenCallback(value)</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">thenCallback</span>(value);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">_reject</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="comment">// this.rejectCallback(value)</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">rejectCallback</span>(value);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">then</span>(<span class="params">then_cb, onRejected</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">thenCallback</span> = then_cb;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">rejectCallback</span> = onRejected;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">null</span>, onRejected);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加入队列机制后，就可以在 executor 中直接执行 resolve ，否则会报错 <code>this.thenCallback is not a function</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Promise-all-1"><a href="#Promise-all-1" class="headerlink" title="Promise.all"></a>Promise.all</h2><p>Promise.all 返回的是一个数组，我们要将参数 array 内的每个 Promise 的执行结果放在一个数组 result 里，并且 result 数组成员的顺序要与传入时的 array 成员顺序保持一一对应。</p><p>实现 Promise.all 的重点在于对 all 参数内 Promise 实例全部执行完毕时机的判断。</p><p>因为 Promise 是异步的，我们不能保证 Promise 实例完成的时机与数组顺序一样。也就是说我们不能使用数组的 length 属性来表达 Promise 全都执行完毕。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">delay</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(data);</span><br><span class="line">    &#125;, <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">_all</span> = <span class="function">(<span class="params">array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = array.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">      array[i].<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        result[i] = data;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">// 因为 array[i] 的执行是异步的，所以这种判断是错误的</span></span><br><span class="line">        <span class="comment">// 如果 i===2 的 promise 先执行完毕,result[2] 导致 result.length === 3</span></span><br><span class="line">        <span class="keyword">if</span> (result.<span class="property">length</span> === array.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, reject);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="title function_">delay</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="title function_">delay</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="title function_">delay</span>(<span class="number">3</span>);</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">_all</span>([<span class="title function_">delay</span>(<span class="number">2</span>), <span class="title function_">delay</span>(<span class="number">1</span>), <span class="title function_">delay</span>(<span class="number">3</span>)]).<span class="title function_">then</span>(</span><br><span class="line">  <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res: &quot;</span>, res); <span class="comment">// [2, 1, 3]</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err: &quot;</span>, err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面的代码，如果最后一个 Promise 先执行完毕，赋值时 <code>result[2] = data</code>，那么 <code>result.length</code>等于 3， 满足 <code>result.length === array.length</code>的判断条件，就会提前执行 resolve 。</p><p>所以，我们可以参考垃圾回收机制的引用计数法，在内部添加一个计数变量 count 来判断是否所有 Promise 都已执行完毕。当 count 等于传入的 Promise 数组长度时，表示所有 Promise 都有了结果，然后我们再执行 resolve 将结果传递出去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property">_all</span> = <span class="function">(<span class="params">array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = array.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">      array[i].<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        result[i] = data;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">// 因为array[i]的执行是异步的，所以这种判断是错误的</span></span><br><span class="line">        <span class="comment">// 如果i===2的promise先执行完毕,result[2]导致result.length === 3</span></span><br><span class="line">        <span class="comment">// if (result.length === array.length) &#123;</span></span><br><span class="line">        <span class="comment">//   resolve(result)</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">if</span> (count === array.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, reject);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>V8引擎如何工作的</title>
      <link href="/2024/02/07/V8%E5%BC%95%E6%93%8E%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"/>
      <url>/2024/02/07/V8%E5%BC%95%E6%93%8E%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p>v8 是谷歌开源的 JS 引擎，用于执行 JS 代码。清楚 JS 代码的执行顺序，有助于我们了解函数调用栈、事件循环等概念。</p><h1 id="V8-的工作流程图"><a href="#V8-的工作流程图" class="headerlink" title="V8 的工作流程图"></a>V8 的工作流程图</h1><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406473535.png" alt="pic.1708406473535"><br>主要了解其中 4 个重要的概念</p><h1 id="1-Scanner"><a href="#1-Scanner" class="headerlink" title="1.Scanner"></a>1.Scanner</h1><p>scanner 表示扫描器，用于对纯文本 JS 代码进行词法分析。它会将代码分析为 tokens。tokens 表示不能再分割的最小单位，可能是单是字符，可能是一串字符串。<br>例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>会被转为 token 集合，如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;Keyword&quot;</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&quot;const&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;Punctuator&quot;</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&quot;=&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;Numeric&quot;</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&quot;20&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h1 id="2-Parser"><a href="#2-Parser" class="headerlink" title="2.Parser"></a>2.Parser</h1><p>parser 表示解析器。解析过程是一个语法分析的过程，它会将 tokens 转换为抽象语法树「Abstract Syntax Tree」,同时验证语法，有问题就抛出错误。</p><p>继续上个例子，tokens 被解析为 AST 后的样子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Program&quot;</span>,</span><br><span class="line">  <span class="string">&quot;body&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;VariableDeclaration&quot;</span>,</span><br><span class="line">      <span class="string">&quot;declarations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;VariableDeclarator&quot;</span>,</span><br><span class="line">          <span class="string">&quot;id&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;a&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&quot;init&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Literal&quot;</span>,</span><br><span class="line">            <span class="string">&quot;value&quot;</span>: <span class="number">20</span>,</span><br><span class="line">            <span class="string">&quot;raw&quot;</span>: <span class="string">&quot;20&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;const&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;sourceType&quot;</span>: <span class="string">&quot;script&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析分为两种情况，预解析与全量解析。</p><h2 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h2><p>在实际应用中，有大量代码，声明了函数，但未被执行。因此，如果全部都做全量解析的话，就会产生很多无用功。</p><p>预解析有以下特点</p><ul><li>预解析会跳过未被使用的代码</li><li>不会生成 AST，会产生 scopes 信息</li><li>解析速度快</li><li>根据规范抛出特点的错误</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;foo1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;foo2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo2</span>();</span><br></pre></td></tr></table></figure><p>对于 foo1 来说，函数并没有声明，那么生成 ATS 并没有意义。所以 foo1 采用的就是预解析，可以观察到 foo1 函数作用域的信息已经生成了。也就是说，<strong>作用域的范围信息，在预解析阶段就已经确定了。</strong><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406487925.png" alt="pic.1708406487925"></p><h2 id="全量解析"><a href="#全量解析" class="headerlink" title="全量解析"></a>全量解析</h2><p>全量解析会解析当前作用域的所有代码。会生成 AST，并且进一步明确更多的信息。</p><ul><li>解析给使用的代码</li><li>生成 AST</li><li>构建具体的 scopes 信息，变量引用，声明等。</li><li>抛出所有的语法错误</li></ul><p>需要区分的是，<strong>作用域和作用域链的信息在预解析阶段就确定了</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明时未调用，因此会被认为是不被执行的代码，进行预解析</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明时未调用，因此会被认为是不被执行的代码，进行预解析</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数立即执行，只进行一次全量解析</span></span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 foo，那么需要重新对 foo 函数进行全量解析，此时 foo 函数被解析了两次</span></span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure><h1 id="3-Lgnition"><a href="#3-Lgnition" class="headerlink" title="3.Lgnition"></a>3.Lgnition</h1><p>Lgnition 是 V8 提供的一个解释器。它会将 AST 转为字节码「bytecode」。我们可以把这个过程理解为预编译。</p><h1 id="4-TurboFan"><a href="#4-TurboFan" class="headerlink" title="4.TurboFan"></a>4.TurboFan</h1><p>TurboFan 是 V8 引擎的编译器模块。他会将 lgnition 收到的信息转为汇编代码。汇编语言可以理解为，表达了对寄存器的一个交互过程。</p><p>汇编代码就是对机器代码的封装，让人勉强能读懂。比如计算机一条加法指令为 10001010，汇编语言可用 add 表示。</p><p>汇编入门：</p><table><thead><tr><th><strong>寄存器</strong></th><th><strong>概述</strong></th></tr></thead><tbody><tr><td>eax</td><td>累加器，可用于加减乘除等操作，使用频率高</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax, <span class="number">5</span>; <span class="comment">// 将数字5，传送到寄存器 eax 中</span></span><br><span class="line">add eax, <span class="number">6</span>; <span class="comment">// eax 寄存器加6，此时 eax 得到新的结果</span></span><br></pre></td></tr></table></figure><p>汇编就是使用约定好的指令，对寄存器进行各种操作。</p><p>lgnition + turboFan ，也就是「边解释边执行」。</p><h1 id="5-Orinoco"><a href="#5-Orinoco" class="headerlink" title="5.Orinoco"></a>5.Orinoco</h1><p>Orinoco 是 V8 的垃圾回收器。</p><p>垃圾回收器会定期执行以下任务</p><ol><li>标记活动对象和非活动对象「标记阶段」</li><li>回收&#x2F;重用非活动对象所占用的空间「清理阶段」</li><li>整理内存「整理阶段」</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6常用特性</title>
      <link href="/2024/02/07/es6%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7/"/>
      <url>/2024/02/07/es6%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="keyword">function</span> (<span class="params">width, height</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> width = width || <span class="number">50</span>;</span><br><span class="line">  <span class="keyword">var</span> height = height || <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>没有默认参数之前，一切没有问题，知道遇到参数 0 时，就有问题了。0 为假值，就无法变为参数本身的值。在 es6 中，修复了这一缺陷。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="keyword">function</span> (<span class="params">width = <span class="number">50</span>, height = <span class="number">100</span></span>) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h1><p>模板字符串是增强版的字符串，用反引号&#96;&#96;&#96;&#96;标识。<br>如果要在模板字符串中嵌入变量，将变量名写在<code>$&#123;&#125;</code>中。<br>模板字符串会保留所有的空格和换行。</p><h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><p>es5 写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;yy&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> age = obj.<span class="property">age</span>;</span><br><span class="line"><span class="keyword">var</span> name = obj.<span class="property">name</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> item1 = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> item2 = arr[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>解构赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;yy&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; age, name &#125; = obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果你想自定义变量名，可用冒号重命名，如myage</span></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">age</span>: myage, name &#125; = obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> [item1, item2] = arr;</span><br></pre></td></tr></table></figure><h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>箭头函数内部的 this 是词法作用域，由上下文确定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _this = <span class="variable language_">this</span>;</span><br><span class="line">$(<span class="string">&quot;.btn&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  _this.<span class="title function_">sendData</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>有了箭头函数，就不必使用 that&#x3D;this、_this&#x3D;this、.bind(this)…，它总是可以按我们预期使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;.btn&quot;</span>).<span class="title function_">click</span>(<span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">sendData</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>更简洁的语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  dosomething;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果返回结果是单个语句，可以省了<code>&#123;&#125;</code> 和 <code>return</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果返回的是对象，需要用()包裹</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; (&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;);</span><br></pre></td></tr></table></figure><h1 id="let-和-const"><a href="#let-和-const" class="headerlink" title="let 和 const"></a>let 和 const</h1><p>使用 <code>let</code> 和 <code>const</code> 生命的变量，只在代码块里有效。代码块可以理解为大括号<code>&#123;&#125;</code>。</p><p>如果你在 if，for 里面使用 <code>let</code> 和 <code>const</code>，那么只能再块里使用，在外部访问会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// Uncaught ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure><h2 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h2><p>在使用<code>let</code>声明变量之前，对变量进行访问会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">tmp = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(tem)<span class="title class_">Uncaught</span> <span class="title class_">ReferenceError</span>: <span class="title class_">Cannot</span> access <span class="string">&#x27;tmp&#x27;</span> before initialization</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar); <span class="comment">// ReferenceError: bar is net defined</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h2 id="不能重复声明"><a href="#不能重复声明" class="headerlink" title="不能重复声明"></a>不能重复声明</h2><p>不能在布局相同作用域重复声明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">2</span>; <span class="comment">// SyntaxError: Identifier &#x27;x&#x27; has already been declared</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">2</span>; <span class="comment">// SyntaxError: Identifier &#x27;x&#x27; has already been declared</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局作用域可以，后者覆盖前者</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> x = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><code>const</code>声明一个只读的常量，一旦声明，常量的值就不能改变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">x = <span class="number">2</span>; <span class="comment">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure><p>如果<code>const</code>声明的是一个对象，可对这个对象下的属性进行增删改操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加</span></span><br><span class="line">o.<span class="property">z</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="keyword">delete</span> o[<span class="string">&quot;z&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">o.<span class="property">x</span> = <span class="number">11</span>; <span class="comment">// o = &#123; x: 11, y: 1 &#125;</span></span><br></pre></td></tr></table></figure><p>如果不希望 const 生命的对象被修改，可用 <code>defineProperty</code>定义属性的权限。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(o, <span class="string">&quot;x&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">o.<span class="property">x</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o); <span class="comment">// &#123; x: 1 &#125;</span></span><br></pre></td></tr></table></figure><h1 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h1><p>为了语法更接近传统的面向对象语言（java 和 c++），引入了 Class 类的概念，作为对象的模板。</p><p>通过 class 关键字定义类:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = age; <span class="comment">// this指向实例对象</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义方法，方法名前面不需要function，挂载在原型上</span></span><br><span class="line">  <span class="title function_">printName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h2><p>extends 关键字用于继承父类</p><h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>super 可当做函数使用，也可当做对象使用。</p><p>作为函数时，只能在子类构造函数里调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>super</code>代表的是父类的构造函数，但是返回的是子类的实例。 相当于 <code>A.prototype.construcor.call(this)</code>。也就是说，<code>super()</code>内部的 this 指向的是子类 B。</p><p>作为对象时，在普通方法中，指向的是父类的原型对象；在静态方法中，指向父类。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">myMethod</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;static&quot;</span>, msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">myMethod</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;instance&quot;</span>, msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">myMethod</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">myMethod</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">myMethod</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">myMethod</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// super在静态方法中，指向父类</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="title function_">myMethod</span>(<span class="number">1</span>); <span class="comment">// static 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// super在普通方法中，指向父类的原型</span></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">child.<span class="title function_">myMethod</span>(<span class="number">2</span>); <span class="comment">// instance 2</span></span><br></pre></td></tr></table></figure><h1 id="链判断运算符"><a href="#链判断运算符" class="headerlink" title="链判断运算符 ?."></a>链判断运算符 ?.</h1><p>如果一个对象为<code>undefined</code>或<code>null</code>，我们试着去访问该对象下的属性时就会抛出异常</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="literal">undefined</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>); <span class="comment">// Uncaught TypeError: Cannot read properties of undefined (reading &#x27;name&#x27;)</span></span><br></pre></td></tr></table></figure><p>使用链判断运算符，就不会抛出异常</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj?.<span class="property">name</span>); <span class="comment">// undefined</span></span><br><span class="line">等价于;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj == <span class="literal">undefined</span> ? <span class="literal">undefined</span> : obj.<span class="property">name</span>);</span><br></pre></td></tr></table></figure><p>还有一个常用的错误使用，链运算不能应用于赋值运算符左侧</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj?.<span class="property">name</span> = <span class="string">&quot;tom&quot;</span>; <span class="comment">// The left-hand side of an assignment expression may not be an optional property access.ts(2779</span></span><br></pre></td></tr></table></figure><p><strong>ts 非空断言</strong><br>在有些情况下，你如果明确 obj 对象不为<code>null</code>或<code>undefined</code>，你可以使用非空断言符</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj!.<span class="property">name</span> = <span class="string">&quot;tom&quot;</span>;</span><br></pre></td></tr></table></figure><p>这是 TypeScript 中的非空断言操作符，用来告诉编译器您已经检查过属性是否为非空，并且可以放心地访问它。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html和css的布局规则</title>
      <link href="/2024/02/07/html%E5%92%8Ccss%E7%9A%84%E5%B8%83%E5%B1%80%E8%A7%84%E5%88%99/"/>
      <url>/2024/02/07/html%E5%92%8Ccss%E7%9A%84%E5%B8%83%E5%B1%80%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h2 id="html-css-的布局规则："><a href="#html-css-的布局规则：" class="headerlink" title="html&#x2F;css 的布局规则："></a>html&#x2F;css 的布局规则：</h2><p>想了解 html&#x2F;css 的布局规则，重要的不是规则是什么，而是什么因素会影响你使用对应的规则。当你理解了这些因素，那么相同场景下，你自然而然会想到使用什么规则。</p><h3 id="场景（场景和关联）"><a href="#场景（场景和关联）" class="headerlink" title="场景（场景和关联）"></a>场景（场景和关联）</h3><p>举个例子：</p><ol><li>土地：大小，价格，建什么东西</li></ol><p>一句话概括就是：<strong>往容器放东西</strong>，怎么放。<br>土地：容器<br>大小和价格： 因素<br>东西：元素<br>怎么放：规则</p><p>那么，应用到浏览器中：<br>容器：也就是我们的浏览器视口（viewport）<br>因素：矩形、坐标系、边界<br>元素：盒模型<br>规则：文档流、定位、浮动、BFC、flex 等等</p><p>前面提到，要了解布局规则，重要的不是规则是什么，而是什么因素会影响你使用对应的规则，那么我们分别介绍下容器、因素、元素、规则，并从中建立关联。</p><h3 id="容器（viewport）"><a href="#容器（viewport）" class="headerlink" title="容器（viewport）:"></a>容器（viewport）:</h3><p>web 浏览器视口指的是我们可见的区域，不包括浏览器菜单。移动设备的视口默认值为 980px，一般情况下这比移动设备要大，那么内容就会显示不完全，如果直接缩放那会导致字体变小。<strong>为了让视口的值等于移动设备的宽度</strong>，我们会在 html 的头部添加以下标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="因素："><a href="#因素：" class="headerlink" title="因素："></a>因素：</h3><ol><li>矩形：可缩放 -&gt; 响应式布局</li><li>坐标系：拖拽、视差 -&gt; 定位、滚动条、层叠上下文元素</li><li>边界：视口有边界、坐标系无边界</li></ol><p>可见，<strong>容器的不同因素直接影响着我们在实现某种效果时使用哪些规则</strong>。接下来看看元素。</p><h3 id="元素："><a href="#元素：" class="headerlink" title="元素："></a>元素：</h3><ul><li>标准盒模型：块模型、行内模型</li><li>怪异盒模型</li><li>弹性盒模型</li></ul><p>先了解下盒模型的结构，从里到外：content → padding → border → margin，各个部分组合在一起就是我们页面上看到的内容<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406175712.png" alt="pic.1708406175712"></p><h4 id="标准盒模型："><a href="#标准盒模型：" class="headerlink" title="标准盒模型："></a>标准盒模型：</h4><p>我们常说的盒模型指的是 W3C 标准盒模型</p><ul><li>元素的<code>width</code>、<code>height</code>只包含 content 区域</li><li>盒子实际大小等于<code>width</code>+<code>padding</code>+<code>border</code></li></ul><p><em>盒子的实际宽度我们可以看做是总宽度，和元素本身设置的 width 不是一个概念</em></p><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406185130.png" alt="pic.1708406185130"></p><p>我们布局中广泛应用的模型，分为块模型和行内模型，我们叫做块元素和行内元素。<br><strong>块元素</strong><br><code>display: block</code>可以将元素设置为块元素，它拥有以下行为：</p><ul><li>它占据父元素的所有宽度，绝大数情况下（不包含行内块元素）</li><li>独占一行</li><li>拥有<code>width</code>和<code>height</code>属性</li><li>它的<code>margin</code>、<code>border</code>、<code>padding</code> 属性会将盒子周边的元素给“推开”</li></ul><p>行内<strong>元素</strong><br><code>display: inline</code>可以将元素设置为行内元素，也叫行内元素，它拥有以下行为：</p><ul><li>盒子不会独占一行</li><li><code>width</code> 和 <code>height</code> 属性不起作用</li><li>水平方向的外边距、内边距、边框会被应用，且会把其它 <code>inline</code> 状态的盒子推开</li><li>垂直方向的外边距、内边距、边框会被应用，但不会把其它 <code>inline</code> 状态的盒子推开</li></ul><p>默认为行内元素有：a、span、em、strong</p><p>除了标准盒模型，还有怪异盒模型，也可以称 IE 盒模型。因为 IE8 之前，IE 默认使用怪异盒模型，并且没有可用的机制来切换。</p><h4 id="怪异盒模型"><a href="#怪异盒模型" class="headerlink" title="怪异盒模型"></a>怪异盒模型</h4><ul><li>元素的<code>width</code>、<code>height</code>不仅包括<code>content</code>，还包括<code>padding</code>和<code>border</code></li><li>盒子实际的大小取决于 width</li></ul><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406192021.png" alt="pic.1708406192021"></p><p>图中我们给盒子设置了<code>width: 200px</code>，<code>padding: 10px</code>，那么 content 就会被挤压为 180px（200 - padding * 2）。</p><p>应用：使用怪异盒模型能解决 1px 边框线问题。</p><h4 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h4><p><code>box-sizing</code> 属性可以切换盒模型模式，默认值是<code>content-box</code>，可选择有<code>border-box</code>、<code>inherit</code><br><code>content-box</code>：w3c 标准盒模型<br><code>border-box</code>：IE 盒模型<br><code>inherit</code>：从父元素集成 <code>box-sizing</code> 属性的值</p><h4 id="弹性盒模型"><a href="#弹性盒模型" class="headerlink" title="弹性盒模型"></a>弹性盒模型</h4><p>对于一些特殊布局，如水平垂直居中，采用传统布局不容易实现，采用弹性盒模型就很方便实现。</p><p>推荐阮一峰老师的文章：<a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex 布局教程</a>，再补充容易忽视的几点：</p><p><strong>作用在 flex 容器上</strong><br>display: flex:<br>默认: align-items: stretch、flex-direction: row<br>align-content:<br>指定如何在纵轴上 项目之间和周围 分配空间。单轴下（flex-wrap: nowrap）此属性不生效<br>align-items:<br>初始值：stretch<br>stretch：表示 flex 项目会被拉伸至最高的项目高度的高度<br>flex-flow: row wrap &#x3D;&#x3D;&#x3D; flex-direction: row + flex-wrap: wrap</p><p><strong>作用在 flex 项目上</strong><br>flex-grow:<br>初始值：0<br>flex-shrink:<br>初始值：1<br>flex-basic:<br>初始值：auto，即项目本身的大小<br>指定了 flex 项目在<strong>主轴上</strong>的初始大小（如果主轴是水平轴，那就是 flex 项目的宽，否则是高）<br>flex: 1 200px &#x3D;&#x3D;&#x3D; flex: 1 + flex-basic: 200px<br>指定了 flex 项目在主轴上初始化（width: 200px）后，按比例分配剩余空间</p><p><strong>flex 缩写</strong><br>flex &#x3D;&#x3D;&#x3D; flex-grow flex-shrink flex-basic</p><p><strong>flex: 1</strong><br>flex: 1，此属性可以按同等比例分配项目的大小，那么它的完整写法是什么呢？</p><p><strong>不等于 1 1 auto</strong><br>重点理解下缩写下 flex-basic 的作用：<br>在按比例分配项目之前，计算项目是否有多余的空间，默认为 auto，即项目自身的大小。<br>如果<strong>设置为 auto，那么按照项目自身大小初始化后等比例分配剩余空间，也就会出现项目大小不一样的情况，所以不是 1 1 auto。</strong></p><p><strong>等于 1 1 带单位的长度值</strong><br>假设我们设置为 1 1 0px，按照 0px 初始化后等比例分配剩余空间，那每个项目的大小就会相同。</p><h4 id="flex-常用布局"><a href="#flex-常用布局" class="headerlink" title="flex 常用布局"></a>flex 常用布局</h4><p>需求：同一行内，如果有一个标题占两行，整行标题都占两行，否则默认一行。标题超出两行时用省略号表示，效果如下：<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406202621.png" alt="pic.1708406202621"><br>这个需求的难点在于卡片的高度不是固定的。有什么办法可以让同行内的标题高度保持统一？</p><p>先看一个两行超出隐藏的实现</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">word-break</span>: break-all;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">  -webkit-line-clamp: <span class="number">2</span>;</span><br><span class="line">  -webkit-box-orient: vertical;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.title2</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span></span><br><span class="line">  翁翁翁翁翁翁翁翁翁翁翁翁翁翁翁翁翁翁翁翁翁翁翁翁翁翁翁翁翁</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;title title2&quot;</span>&gt;</span>请请请请请请请请请<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406216076.png" alt="pic.1708406216076"><br>先来重点理解<code>display: flex</code>和 flex 下的<code>height: 100%</code></p><ul><li>当我们给容器设置 display: flex 时，那么 align-items 属性的值为 stretch，即同一行内的 flex 项目会被拉伸至最高的项目高度的高度</li><li>给 flex 项目设置 height: 100%，会填充容器剩余高度。</li></ul><p><strong>实现：</strong></p><ol><li>把容器设置为弹性盒子<code>display: flex</code></li><li>给标题设置<code>height: 100%</code></li><li>给标题兄弟元素设置<code>flex-shrink: 0</code></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;section&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card-content&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card-title&quot;</span>&gt;</span></span><br><span class="line">      请问请问群翁群翁群翁群问请问群翁群翁群翁群问请问群翁群翁群翁群</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card-content&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card-title&quot;</span>&gt;</span>2222222222<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card-content&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card-title&quot;</span>&gt;</span>3333<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card-content&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card-title&quot;</span>&gt;</span>444<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.section</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex; // 同一行内的<span class="attribute">flex</span>项目会被拉伸至最高的项目高度的高度</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.section</span> <span class="selector-class">.card</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.section</span> <span class="selector-class">.card</span> <span class="selector-class">.card-content</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">0</span>; // 防止被标题<span class="attribute">height</span>: <span class="number">100%</span>属性挤压</span><br><span class="line"></span><br><span class="line">  width: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.section</span> <span class="selector-class">.card</span> <span class="selector-class">.card-title</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>; // 填充容器剩余高度</span><br><span class="line"></span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">20px</span>; // 加上行高样式更稳定</span><br><span class="line">  <span class="attribute">word-break</span>: break-all;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">  -webkit-line-clamp: <span class="number">2</span>;</span><br><span class="line">  -webkit-box-orient: vertical;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>下面介绍文档流、定位、浮动、BFC 等布局规则。</p><h4 id="文档流："><a href="#文档流：" class="headerlink" title="文档流："></a>文档流：</h4><p>在不对页面元素进行任何控制的情况下，浏览器默认的布局方式。从上到下，从左到右。</p><h4 id="定位（position）："><a href="#定位（position）：" class="headerlink" title="定位（position）："></a>定位（position）：</h4><p>解决某个元素随页面发生变化而固定位置，它不作为一种主要布局方式，而是用于管理和微调页面中一些特殊项的位置</p><ul><li>静态定位：默认值，不做任何</li><li>相对定位：相对自己定位，不会脱离文档流</li><li>绝对定位：相对于 html，会脱离文档流，或相对于最近被定位的祖先元素定位。多配个相对定位使用</li><li>固定定位：相对于浏览器视口固定定位</li><li>粘性定位：初始像静态定位，当它的位置相对视口达到预设值时，就会想固定定位一样被固定住</li></ul><h4 id="浮动（float）"><a href="#浮动（float）" class="headerlink" title="浮动（float）"></a>浮动（float）</h4><p>在传统布局里，信息是纵向排列（从上到下）的，浮动可使信息横向排列。浮动会脱离文档流，正常文档流的元素会围绕着浮动元素。</p><ul><li>left：左浮</li><li>right：右浮</li><li>none：不浮动</li><li>inherit：继承父元素浮动属性</li></ul><p>在使用浮动时，我们得清楚的知道我们要把元素摆放在哪个位置。因为使用浮动时，可能会存在可视化布局与源顺序不同。</p><p>假设现源顺序布局为如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div1 div2 div3</span><br></pre></td></tr></table></figure><p>我们给 div2 和 div3 同时设置 <code>float: right</code>，那么视觉效果就为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div1 div3 div2</span><br></pre></td></tr></table></figure><p>这是因为 div2 在源顺序上比 div3 等级更高（在 DOM 上，div2 先出现，并声明了 <code>float: right</code>），所以在视觉上更靠右。</p><h4 id="BFC：块级格式化上下文（block-format-context-）"><a href="#BFC：块级格式化上下文（block-format-context-）" class="headerlink" title="BFC：块级格式化上下文（block format context ）"></a>BFC：块级格式化上下文（block format context ）</h4><p>定义：可以看作是一块独立的区域空间，拥有普通盒子没有的一些特性。<strong>它解决个体之间的位置交互问题。</strong></p><p>触发 BFC 的方法：</p><ul><li>html 根元素</li><li>position: absolute、fixed</li><li>display: flex、inline-block、table-cell</li><li>overflow: 除 visibility</li><li>float: 除 none</li></ul><p>来看下元素间的交互问题以及解决方法：</p><ul><li>同一块 BFC 下，相邻垂直方向盒子外边距会发生重叠：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blueviolet;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406228923.png" alt="pic.1708406228923"><br>我们给每个 child 设置了<code>margin: 50px</code>，但它们的间距不是 100px，而是 50px，如果我们想让间距变成 100px，那么只要给其中一个盒子设置为 BFC，这样就不再同一块 BFC 下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blueviolet;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrap</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406235633.png" alt="pic.1708406235633"></p><ul><li>浮动问题：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid #000;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px;height: 100px;background: #eee;float: left;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406243403.png" alt="pic.1708406243403"><br>为外层 div 添加<code>overflow: hidden</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid #000;overflow: hidden;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px;height: 100px;background: #eee;float: left;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406250328.png" alt="pic.1708406250328"></p><ul><li>元素被浮动元素覆盖的问题</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;height: 400px;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;height: 100px;width: 100px;float: left;background: lightblue&quot;</span>&gt;</span></span><br><span class="line">    我是一个左浮动的元素</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 200px; height: 200px;background: #eee;&quot;</span>&gt;</span></span><br><span class="line">    我是一个没有设置浮动, 也没有触发 BFC 元素, width: 200px; height:200px;</span><br><span class="line">    background: #eee;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406257409.png" alt="pic.1708406257409"><br>给被浮动元素覆盖的元素添加<code>overflow: hidden</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;height: 400px;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;height: 100px;width: 100px;float: left;background: lightblue&quot;</span>&gt;</span></span><br><span class="line">    我是一个左浮动的元素</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 200px; height: 200px;background: #eee;overflow: hidden;&quot;</span>&gt;</span></span><br><span class="line">    我是一个没有设置浮动, 也没有触发 BFC 元素, width: 200px; height:200px;</span><br><span class="line">    background: #eee;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406277606.png" alt="pic.1708406277606"><br>小结：<br>解决塌陷：给其中一个盒子设置为 BFC，这样就不再同一块 BFC 下<br>清除浮动：给浮动元素父元素设置为 BFC<br>防止元素被浮动元素覆盖：给元素设置 BFC，就不会被浮动元素覆盖</p><h4 id="IFC：行内格式化上下文（inline-formatting-context）"><a href="#IFC：行内格式化上下文（inline-formatting-context）" class="headerlink" title="IFC：行内格式化上下文（inline formatting context）"></a>IFC：行内格式化上下文（inline formatting context）</h4><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406355114.png" alt="pic.1708406355114"><br>让块水平居中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.p</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;p&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>12<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406370175.png" alt="pic.1708406370175"></p><h3 id="总结（对-html-css-规则）"><a href="#总结（对-html-css-规则）" class="headerlink" title="总结（对 html&#x2F;css 规则）"></a>总结（对 html&#x2F;css 规则）</h3><p>抽象点来说，容器就是一个可以容纳个体的空间，当我们把一个个个体放到容器时，容器的因素决定了我们使用什么规则来存放从而更加合理。<br>具体点来说，视口就是我们的容器，元素就是个体，视口的因素（矩形、坐标系和边界等）决定了我们使用什么规则来布局。元素分为标准盒模型、IE 盒模型和弹性盒模型，规则分为文档流、定位、浮动、BFC 等等。</p><p>参考：<br><a href="https://zhuanlan.zhihu.com/p/183050328">https://zhuanlan.zhihu.com/p/183050328</a><br><a href="https://blog.csdn.net/weixin_41682025/article/details/110343448">https://blog.csdn.net/weixin_41682025&#x2F;article&#x2F;details&#x2F;110343448</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中的重要概念</title>
      <link href="/2024/02/07/js%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5/"/>
      <url>/2024/02/07/js%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p><strong>在当前函数中，要寻找到变量的值是从哪里来的，就首先会从当前执行上下文中查找，如果没有找到，则会去作用域链中查找。这里需要注意的是，作用域链本身就是存在于函数对象中的一个属性 [[Scopes]]，因此不是一层一层的往上查找「这里经常理解有误」，该属性是在代码预解析阶段就已经确认好的。</strong></p><p>作用域：作用域是规定变量与函数可访问范围的一套规则。</p><p>作用域的范围信息，是在预解析阶段就已经确定的</p><p>执行上下文：执行上下文包含了跟踪对应可执行代码执行进度所需要的所有状态，每个执行上下文中都有特定的实体对象用于记录这些特定状态。</p><p>函数调用栈：管理所有的执行上下文</p><p>运行时上下文：只能有一个，且处于栈顶。当代码执行过程中，有新的函数调用，新的执行上下文会被创建，入栈，并且成为新的运行时上下文</p><p><strong>完整的作用域链：</strong></p><p>都具备一个属性 [[Scopes]]，该属性中存储了当前函数可访问的所有变量对象</p><ul><li><strong>Global 全局对象</strong>：不会做任何优化，会包含全局对象中的所有属性与方法</li><li><strong>Script 对象</strong>：在全局环境下，由 let 和 const 声明的变量对象</li><li><strong>Closure 对象</strong>：我们讨论比较多的闭包对象，嵌套函数生成，仅会保存当前作用域能够访问的变量属性</li><li><strong>Local 对象</strong>：以上的几种变量对象，都会存在于函数的 [[Scopes]]属性之中，因为他们都能够在函数解析时确认，而 Local 对象则不行，需要在函数的<strong>执行过程中才能确定</strong>，并且在执行过程中，该对象中的属性是随时会发生变化的，该对象除了会存储当前函数上下文中所有的变量与函数声明，还会额外记录 this 的指向。</li></ul><p>Local: 活动对象</p><p>由 <strong>函数参数，var 声明的变量，let&#x2F;const 声明的变量，function 声明的变量，class 声明的变量，this 指向等</strong>共同组成。<br>仅仅只有处于栈顶的执行上下文，才会生成 Local 对象。并且 Local 对象的具体内容会在执行上下文的生命周期中不断变化。也就意味着，在执行上下文的创建阶段，只有函数参数、function 声明的变量、this 指向 能够明确具体的值，其他变量的初始值都为 undefined，然后在代码执行过程中逐步明确赋值。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web3综述</title>
      <link href="/2024/02/07/web3%E7%BB%BC%E8%BF%B0/"/>
      <url>/2024/02/07/web3%E7%BB%BC%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p>区块链：去中心化记账系统</p><h1 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h1><p>基于区块链这一技术的一种加密货币（还有以太币、莱特币等等）</p><ul><li>密码学基础</li><li>比特币的数据结构</li><li>共识协议和系统实现</li><li>挖矿算法和难度调整</li><li>比特币脚本</li><li>软分叉和硬分叉</li><li>匿名和隐私保护</li></ul><h1 id="以太坊"><a href="#以太坊" class="headerlink" title="以太坊"></a>以太坊</h1><ul><li>基于账户的分布式账本</li><li>数据结构：状态树、交易树、收据树</li><li>GHOST 协议</li><li>挖矿：memory-hard mining puzzle</li><li>挖矿难度调整</li><li>权益证明</li><li>智能合约</li></ul><p><strong>以太坊生态：</strong></p><ol><li>去中心化应用（DApps Decentralized Applications）：<ol><li>数字金融服务（去中心化交易所、借贷平台、稳定币）</li><li>数字身份验证</li><li>去中心化游戏</li><li>去中心化社交媒体</li></ol></li><li>智能合约：以太坊是一个智能合约平台。智能合约应用场景包括：代币发行、投票、众筹等</li><li>钱包：以太坊生态系统有各种钱包应用程序，用于存储、管理和交易以太坊资产和代币</li><li>基础设备和开发工具：开发者可以通过这些工具构建和部署智能合约和 DApps。如 Solidity、以太坊虚拟机（EVM）</li><li>NFT（Non-Fungible Token 非同质化代币）市场：以太坊是最著名的 NFT 平台之一。支持各种数字艺术、虚拟土地、链上凭证等 NFT 的发行和交易</li><li>去中心化金融（DeFi Decentralized Finance）：以太坊生态系统中最受欢迎和发展最快的领域之一。DeFi 应用提供了一系列金融服务，如去中心化交易所 DEX、链上借贷等，旨在提供更开放、透明和无需信任的金融体系。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> web3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>z轴的学习规则</title>
      <link href="/2024/02/07/z%E8%BD%B4%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%99/"/>
      <url>/2024/02/07/z%E8%BD%B4%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>html 元素沿着相对其用户的一条虚构的 z 轴排开，层叠上下文就是对这些 html 元素的三维构想。<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406510231.png" alt="pic.1708406510231"></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在 z 轴上，存在层叠上下文，他们有着遮挡关系的先后顺序，我们可以称之为层叠顺序，学习层叠上下文主要就是学习层叠顺序。在学习前，我们先来了解背景，我们试想一下，页面上为什么需要有 z 轴的存在？</p><p>举个例子：<br>常见的“顶部固定不动，内容区域向上滚动”的效果，我们给顶部设置<code>position: fixed</code>，内容区域设置<code>overflow: auto</code>。假设我们的内容在第一层，那顶部就在第一层之上，它不随第一层的滚动而滚动，因为 z 轴上的每一层都是相互独立的，这样轻而易举的达到了我们想要的效果。</p><p>如果不存在 z 轴，他们处在同一层，有可能实现这种效果吗？答案是有。内容向上滚动的同时，滚了多少距离，我们的顶部就向下滚动多少距离，这也可以实现相同的效果。但是这个过程的计算过程巨复杂，它使不变的元素（顶部）也进行了重新的计算，那么 GUI 渲染线程会重新计算 render tree，然后重新绘制页面元素。这将导致我们的页面性能非常差。</p><p>再举个常见的例子，比如视差、canvas，也是同个道理，都是为了更少的计算，让不变的保持不变。而这背后的原理，就是为了迎合浏览器的规则，减少回流。</p><p>所以答案就是：<strong>z 轴的存在，其实是网页性能优化的一种手段。使不变的元素保持不变，减少回流。</strong></p><h2 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h2><p>我们可以把它们看做成一个个独立的空间，它们在 z 轴上存在顺序上的层叠关系。<br>层叠上下文存在以下特性</p><ul><li>层叠上下文可以包含在其他层叠上下文当中，形成一个嵌套层级</li><li>每个层叠上下文完全独立于其他兄弟元素</li></ul><h2 id="层叠等级"><a href="#层叠等级" class="headerlink" title="层叠等级"></a>层叠等级</h2><p>层叠等级，也可以叫层叠级别&#x2F;层叠水平，在同一个层级上下文中，等级越高，越靠近用户。</p><ul><li>普通元素的层叠等级由所处层叠上下文决定</li><li>在同一个层叠上下文中，等级越高，越靠近用户</li><li>不在同一个上下文中的层叠等级比较是没有意义的</li></ul><p>用代码验证一下第三点：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;yellow&quot;</span>&gt;</span></span><br><span class="line">  1</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;blue&quot;</span>&gt;</span>999<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.yellow</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.blue</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">999</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.red</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406521813.png" alt="pic.1708406521813"></p><p><code>.yellow</code>的层叠等级为 1，<code>.red</code>的层叠等级为 2，<code>.blue</code>为 999，<code>.yellow</code>和<code>.red</code>在同一个根层叠上下文下。<br>但是由图可见，<code>.blue</code>在<code>.red</code>下面，这是因为<code>.yellow</code>的层叠等级比<code>.red</code>小，也证明了不在同一个上下文中的比较是没有意义的。</p><h2 id="创建层叠上下文"><a href="#创建层叠上下文" class="headerlink" title="创建层叠上下文"></a>创建层叠上下文</h2><ul><li><code>html</code>为根层叠上下文</li><li><code>position</code>属性为<code>absolute</code>或<code>relative</code>并设置了<code>z-index</code>属性为具体数值</li><li><code>position</code>值为<code>fixed</code>或<code>sticky</code>的元素</li><li>css3 的一些属性（文章后面介绍）</li></ul><h2 id="层叠顺序"><a href="#层叠顺序" class="headerlink" title="层叠顺序"></a>层叠顺序</h2><p>层叠规则，表示元素在发生层叠时，有着特定的层叠顺序。<strong>层叠上下文和层叠等级是概念，而层叠顺序是规则。</strong><br>层叠上下文的 background&#x2F;border &lt; z-index 负值 &lt; block 元素 &lt; float 元素 &lt; inline-block&#x2F;inline &lt; z-index: 0 &#x2F; z-index: auto &lt; z-index: 正值<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12749457/1634485327259-1b8e0194-bf03-42d8-8d0e-6211a51742d5.png#clientId=u794edf10-67e5-4&from=ui&id=u6b450d55&originHeight=379&originWidth=581&originalType=binary&ratio=1&size=17946&status=done&style=none&taskId=u2c1e605c-0929-41a1-b416-8fa2bce6ad6" alt="层叠顺序图.png"></p><h2 id="DOM-顺序和层叠顺序"><a href="#DOM-顺序和层叠顺序" class="headerlink" title="DOM 顺序和层叠顺序"></a>DOM 顺序和层叠顺序</h2><p>从图中可以看出，层叠低的在层级高的下面，就像往容器里面放东西一样。它其实<strong>迎合栈的层叠规则</strong>，先进后出。所以浏览器会优先渲染层叠等级低的元素，再渲染比它高的。</p><p>所以结合实际的应用，在编码时，我们应该自然而然的把层叠等级低的写在最前面，让渲染更流畅。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;z-index: -100&quot;</span>&gt;</span>div1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;z-index: 0&quot;</span>&gt;</span>div2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;z-index: 1&quot;</span>&gt;</span>div3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果层级高的在下面会怎样？看个例子<br>我们先往容器（html）里放了一个 div1，在放 div2，div3，假设 3 个 div 都是层叠元素，div1 层叠等级最高，并且在最下面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;z-index: 1&quot;</span>&gt;</span>div1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;z-index: 0&quot;</span>&gt;</span>div2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;z-index: -100&quot;</span>&gt;</span>div3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上代码，假设先渲染等级高的（div1），那渲染等级低的元素时，是不是还要把它上面的元素先拿出来。</p><p>万能公式</p><ul><li>同一个层叠上下文，谁的层叠等级大，谁再上面。</li><li>不在同一个层叠上下文，找到它们的父级为兄弟节点，再比较。</li><li>当层叠等级和层叠顺序相同时，后来居上。</li></ul><p>下面我们来验证一下层叠顺序和万能公式是否准确。<br><strong>例子 1：z-index: 负值 &lt; block 元素：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    parent</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>child<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#168bf5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#32d19c</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406544047.png" alt="pic.1708406544047"></p><p>.parent 是个普通的块元素，.child 是带负值的 z-index 层叠上下文元素，.parent 在.child 上面，所以 z-index: 负值 &lt; block 元素成立。</p><p><strong>例子 2： 层叠上下文的 background&#x2F;border &lt; z-index 负值</strong><br>继续上个例子，我们给.parent 添加 position: relative 和 z-index: 0，其余代码不变</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    parent</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>child<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#168bf5</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#32d19c</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406555021.png" alt="pic.1708406555021"></p><p>这时候.parent 变成了带 background 的层叠上下文元素，.child 依然是带负值的 z-index 层叠上下文元素。网上的很多文章拿这个例子来验证 background&#x2F;border &lt; z-index 负值，其实是不正确的。.child 在.parent 上，是因为.child 嵌套在.parent 里面，所以.child 在上面。也就是说他们不在用一个层叠上下文之下，所以他们的比较是没有意义的。</p><p>关于 background&#x2F;border &lt; z-index 负值，我还没想到如何验证。</p><p><strong>例子 3：block 元素 &lt; float 元素 &lt; inline-block&#x2F;inline</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../../images/js1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是重要的内容，我的等级很高的哦<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406566018.png" alt="pic.1708406566018"></p><p>.box 是块元素，img 是浮动元素，span 是 inline 元素，inline 在最上面，img 在中间，所以<strong>block 元素 &lt; float 元素 &lt; inline-block&#x2F;inline</strong>成立。</p><p><strong>例子 4：同一个层叠上下文，谁的层叠等级大</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 盲僧 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../../images/ms.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 剑圣 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../../images/js1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box1</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">z-index</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box1</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box2</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">z-index</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box2</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406574167.png" alt="pic.1708406574167"></p><p>.box1 和 .box2 的 z-index 值为 auto，此时不是层叠上下文元素，两张图片都属于在根层叠上下文下，因为盲僧在剑圣上面，所以同一个层叠上下文，谁的层叠等级大成立</p><p><strong>例子 5：层叠等级和层叠顺序相同时，后来居上</strong><br>在例子 4 的基础上，我们把.box1 和.box2 的 z-index: auto 改为 z-index: 0</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 盲僧 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../../images/ms.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 剑圣 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../../images/js1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box1</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box1</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box2</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box2</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406589649.png" alt="pic.1708406589649"></p><p>此时.box1 和.box2 都变成了层叠等级为 0 的层叠上下文元素，并且在同个层叠上下文下。剑圣在盲僧上面，所以<strong>层叠等级和层叠顺序相同时，后来居上</strong>成立。</p><h2 id="css3-中的属性对层叠上下文的影响"><a href="#css3-中的属性对层叠上下文的影响" class="headerlink" title="css3 中的属性对层叠上下文的影响"></a>css3 中的属性对层叠上下文的影响</h2><p>介绍几个比较常用的，如下：</p><ol><li>父元素的 display 属性值为 flex | inline-flex，子元素的 z-index 属性值不为 auto，子元素为层叠上下文元素</li><li>元素的 opacity 值不为 1</li><li>元素的 filter 属性值不是 none</li><li>元素的 transform 属性值不是 none</li></ol><p><strong>例子 6：父元素 display: flex | inline-flex 与层叠上下文</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    parent</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>child<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#168bf5</span>;</span><br><span class="line">  <span class="comment">/* 虽然设置了z-index，但是没有设置position，z-index无效，.parent还是普通元素，没有产生层叠上下文 */</span></span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#32d19c</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406603779.png" alt="pic.1708406603779"><br>继续例子 6，我们把.parent 变成层叠上下文元素，<br><strong>例子 7：层叠上下文的 background&#x2F;border &lt; z-index 负值</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    parent</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>child<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#168bf5</span>;</span><br><span class="line">  <span class="comment">/* .box设置了display: flex; 这时候.parent变成了层叠上下文 */</span></span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#32d19c</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406621323.png" alt="pic.1708406621323"></p><p>.child 跑到了上面，所以<strong>层叠上下文的 background&#x2F;border &lt; z-index 负值</strong>成立。</p><p><strong>例子 8：元素的 opacity 值不为 1</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../../images/js1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#168bf5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406632213.png" alt="pic.1708406632213"><br>因为 z-index: 负值 &lt; 块元素，所以图片在蓝色背景下。然后我们给 div 添加 opacity: 0.5，其余不变</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../../images/js1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#168bf5</span>;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406639748.png" alt="pic.1708406639748"></p><p>添加 opacity 后，div 变成了层叠上下文元素，图片跑到了上面，所以<strong>层叠上下文的 background&#x2F;border &lt; z-index 负值</strong>成立。</p><p><strong>例子 9：元素的 filter 属性值不是 none</strong><br>在例子 8 上，我们给 div 添加 filter: blur(5px)，其余不变</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../../images/js1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#168bf5</span>;</span><br><span class="line">  <span class="attribute">filter</span>: <span class="built_in">blur</span>(<span class="number">5px</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406650744.png" alt="pic.1708406650744"></p><p>同理，结论成立。</p><p><strong>例子 10：元素的 transform 属性值不是 none</strong><br>在例子 8 上，我们给 div 添加 transform: rotate(45deg)，其余不变</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../../images/js1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#168bf5</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406659567.png" alt="pic.1708406659567"></p><p>同理，结论成立。</p><p>开发调试工具<br>可以用过 layers 来查看页面的层叠布局，检查遮挡关系<br>More tools -&gt; Layers<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708406666079.png" alt="pic.1708406666079"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>z 轴的存在，其实是网页性能优化的一种手段。使不变的元素保持不变，减少回流。</li><li>因为浏览器优先渲染层叠等级低的元素，所以编码时，我们应该自然而然的把层叠等级低的元素写在前面，让渲染更为流畅。</li><li>查看层叠等级时，先查看是否在同个层叠上下文下，如果是，层叠等级越高越在上面，层叠等级和层叠顺序相同时，后来居上。如果不是，那么判断所处层叠上下文的等级。</li><li>避免滥用 z-index。现在我们知道 inline &gt; float，那么我们只需要把元素变成行内元素即可覆盖在浮动元素之上。过渡使用定位元素会使页面变复杂。</li><li>定位或者 css3 属性 display: flex | inline-flex 下，z-index: auto 所在的元素是普通元素，z-index: 0 是层叠元素。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件循环机制</title>
      <link href="/2024/02/07/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/"/>
      <url>/2024/02/07/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="同步于异步"><a href="#同步于异步" class="headerlink" title="同步于异步"></a>同步于异步</h1><p>同步：按函数调用栈执行</p><p>异步：分发器分发一个任务，被通知后执行</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>负责 JS 执行环境的代码执行顺序的问题。如果没有异步事件，函数调用栈几乎可以解决所有执行顺序问题。而事件循环机制，就是异步事件代码执行顺序的解决方案。</p><p>那么，浏览器中有哪些异步事件，以及它们各自有哪些特点呢？</p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>许多异步事件，都是由线程负责处理。<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708327092141.png" alt="pic.1708327092141"><br>JS 是单线程的，但是 JS 的执行环境是由多个线程协同工作的。不同的线程，对应着不同的异步事件。</p><h2 id="五个线程"><a href="#五个线程" class="headerlink" title="五个线程"></a>五个线程</h2><p><strong>GUI 线程</strong></p><p>负责 HTML 的解析与渲染。DOM 结构的修改是同步的，但是 <strong>DOM 的渲染过程是异步的</strong>。</p><p><strong>JS 引擎线程</strong></p><p>负责 JS 代码的运行。<br>每一个网页，只会启动一个 JS 线程来配合完成页面的交互。</p><p><strong>定时器线程</strong></p><p>专门负责 setTimeout&#x2F;setInterval 的逻辑。<br>回调函数中的逻辑并不会马上执行，即使将时间设置为 0，这也是异步的。</p><p><strong>I&#x2F;O 时间触发线程</strong></p><p>当我们鼠标点击与滑动、键盘的输入等都会触发一些事件，而这些事件的触发逻辑的处理，就是依靠事件触发线程来帮助浏览器完成。</p><p>该线程也会把事件的逻辑放入队列中，等待 JS 引擎的处理。</p><p><strong>http 线程</strong></p><p>使用无状态短链接的 http 请求，在应用层基于 http 协议的基础之上，达到与服务端进行通信的目的。</p><p>该线程的触发逻辑，不是在 JS 引擎线程中，这个过程是异步的。</p><p>小结：除了 JS 引擎线程，其他四个线程分别处理与之对应的异步任务。比如定时器线程，由任务分发器 setTimeout &#x2F;setInterval 分发异步任务进入定时器执行队列。</p><h2 id="与-UI-render-紧密相关的-raf-ric"><a href="#与-UI-render-紧密相关的-raf-ric" class="headerlink" title="与 UI render 紧密相关的 raf&#x2F;ric"></a>与 UI render 紧密相关的 raf&#x2F;ric</h2><p><strong>requestAnimationFrame</strong> 简称「raf」,它是动画的重要实现手段。他跟前面介绍的异步方式大有不同，跟 UI render 紧密相关。</p><p>结合浏览器的渲染机制共同理解。<br>常规的显示器的刷新率为 60 Hz，也就是说，1 秒钟把页面刷新了 60 次，是最合理的频率。</p><p>这也是浏览器在进行 UI render 的合理频率。因此，每一次的渲染时间，控制在 1000 &#x2F; 60 ms 以内。对浏览器来说才不会负荷工作。</p><p>requestAnimationFrame 是完成符合浏览器刷新频率的回调方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如果单次执行时间大于 <span class="number">16.</span>67ms，也就是刷新率低于 <span class="number">60</span> <span class="title class_">Hz</span>，会表现出卡顿；</span><br><span class="line"></span><br><span class="line">卡顿的理解：</span><br><span class="line">网络直播时，如果网络不好，会丢包导致卡帧。也就是说，下一秒的包还没发给你，自动刷新，刷新的还是上一次的老包，所以表现为卡顿，看起来就像刷新率低一样。</span><br><span class="line"></span><br><span class="line">会用掉帧策略（放弃某一帧的任务）来解决。而不使用任务堆积。</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果高于 60hz，浏览器会超负荷工作。raf 的回调函数为 <span class="number">1000</span> / <span class="number">60</span> 执行一次，刚刚好符合浏览器刷新频率</span><br></pre></td></tr></table></figure><p>我们通常喜欢将一次 UI render 描述为 一帧 「frame」。requsetAnimationFrame 只会在每一帧开始渲染之前执行。<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708327251065.png" alt="pic.1708327251065"></p><p><strong>requestIdleCallback</strong> 简称「ric」,图中的<code>idle</code>，通常将优先级不高的任务放在 ric 中执行。</p><p>它的执行频率也跟 UI render 的频率一样。但是它会在每一帧的最后执行。</p><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>在浏览器中，线程对应的事件，并不能覆盖所有的异步事件类型。Promise 就是一个特例。</p><p>Promise 是 JS 的内部逻辑。并非由浏览器额外的线程来处理。因此，Promise 的异步逻辑与线程对应的异步逻辑是不一样的。</p><p>在 JS 引擎的处理逻辑中，Promise 有自己的事件队列，并且该队列在所有 JS 代码执行完成后执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(f, r);</span><br></pre></td></tr></table></figure><h2 id="job"><a href="#job" class="headerlink" title="job"></a>job</h2><p>then 中的回调函数，就是一个 job。此处为 f 与 r。catch 同理。</p><h2 id="PromiseJobs-执行队列"><a href="#PromiseJobs-执行队列" class="headerlink" title="PromiseJobs 执行队列"></a>PromiseJobs 执行队列</h2><p>用于存储 Promise 异步逻辑。该队列在所有 JS 代码执行完之后执行。也可以说在 call stach 清空之后执行。</p><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>一个 promise 有三种状态</p><ul><li>pending: 等待结果状态</li><li>fulfilled: 已出结果，结果符合预期完成状态</li><li>rejected: 已出结果，结果未符合预期完成状态</li></ul><p>当一个 promise 实例在创建时，处于 pending 状态。<br>当 resolve 函数调用时， padding -&gt; fulfilled<br>当 reject 函数调动是， padding -&gt; rejected</p><p>当 promise 有了状态，不再是 padding ，那么我们称该 promise 的状态被固定: <strong>settled</strong></p><h2 id="何时进入-PromiseJobs"><a href="#何时进入-PromiseJobs" class="headerlink" title="何时进入 PromiseJobs"></a>何时进入 PromiseJobs</h2><p>调用 <code>p.then(f, r)</code>时，会将 <code>f</code> 放入 <code>[[PromiseFulfillReactions]]</code>队列尾部，将 <code>r</code>放入 <code>[[PromiseRejectReactions]]</code>队列尾部。</p><p>这两个队列，是<strong>临时中间队列</strong>（准确的说，应该叫临时存储地方，出队时是无序的）。该队列中的 job 只会移入到 PromiseJobs 队列中而不会有自己的执行过程。 PromiseJobs 才有执行 job 的逻辑。</p><p>当 <code>resolve/reject</code>函数调用时，promise 产生了结果。此时，根据不同的结果，<code>p.then(f, r)</code>将不同的 job 「f &#x2F; r」加入到 PromiseJobs 队列中。</p><p>如果在创建时，就已经 settled ，那么 job 会直接进入 PromiseJobs 队列中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(); <span class="comment">// 直接敲定状态</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>链式调用时，后续的 then 如何将 job 加入到 PromiseJobs 队列，需要根据上一个 then 的返回结果来决定。</p><ul><li>当不确定返回结果时，且 then 已调用，对应的 job 进入临时队列中。</li><li><strong>确定了返回结果之后，才会将 job 移入到 PromiseJobs 队列中</strong>。</li></ul><h2 id="PromiseJobs-队列如何执行"><a href="#PromiseJobs-队列如何执行" class="headerlink" title="PromiseJobs 队列如何执行"></a>PromiseJobs 队列如何执行</h2><p>先进入的先执行。但是有一点要注意，当 job 执行时，可能会产生新的 job 进入到该队列。因此 <strong>PromiseJobs 在执行过程中会动态变化</strong>。</p><p>PromiseJobs 的执行规则</p><ul><li>当所有 JS 代码执行完毕，PromiseJobs 队列开始出队执行</li><li>PromiseJobs 处于动态变化中，只有当 PromiseJobs 队列为空时，才会结束执行</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">PromiseJobs</span> = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入 job1</span></span><br><span class="line"><span class="title class_">PromiseJobs</span>.<span class="title function_">push</span>(job1);</span><br><span class="line"><span class="comment">// 加入 job2</span></span><br><span class="line"><span class="title class_">PromiseJobs</span>.<span class="title function_">push</span>(job2);</span><br><span class="line"></span><br><span class="line"><span class="title class_">PromiseJobs</span> = [job1, job2];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> job;</span><br><span class="line"><span class="comment">// 将先进入队列的 job 移除队列，并执行</span></span><br><span class="line"><span class="comment">// PromiseJobs 是处于动态变化的，所以只能用 while 来处理这种动态循环的场景。不能用 for 循环</span></span><br><span class="line"><span class="keyword">while</span> ((job = <span class="title class_">PromiseJobs</span>.<span class="title function_">shift</span>())) &#123;</span><br><span class="line">  <span class="title function_">job</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过两例子感受一下<br>例子一：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>();</span><br><span class="line">    &#125;)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">f3</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">f4</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出: 0 1 2 3 4</span></span><br></pre></td></tr></table></figure><p>Promise 在创建时，直接调用了 resolve ， Promise 有了结果，因此， f1 马上被加入 PromiseJobs 队列。f2 要等待 f1 的结果，所以只能被加入临时队列。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">PromiseJobs</span> = [f1];</span><br><span class="line"><span class="title class_">PromiseFulfillReactions</span> = [f2];</span><br></pre></td></tr></table></figure><p>输出 0, JS 所有代码执行结束, 开始执行 PromiseJobs 列队中的逻辑</p><p>** f1 出队执行**, 输出 1, 遇到一个新的 Promise 对象, 且直接调用了 resolve , f3 进入 PromiseJobs 队列，f4 需要等到 f3 的执行结果, 所以进入临时队列</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">PromiseJobs</span> = [f3];</span><br><span class="line"><span class="title class_">PromiseFulfillReactions</span> = [f2, f4];</span><br></pre></td></tr></table></figure><p><strong>f1 执行结束, 可以得知 f1 返回了 undefined, 等价于 resolve(undefined)</strong>. f1 有了结果, 所以 f2 进入 PromiseJobs 队列.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">PromiseJobs</span> = [f3, f2];</span><br><span class="line"><span class="title class_">PromiseFulfillReactions</span> = [f4];</span><br></pre></td></tr></table></figure><p>又开始执行 PromiseJobs 中的任务。</p><p>f3 出队执行, 输出 2<br>f3 执行完毕, 返回 undefined, 因此 f4 进入 PromiseJobs 队列</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">PromiseJobs</span> = [f2, f4];</span><br><span class="line"><span class="title class_">PromiseFulfillReactions</span> = [];</span><br></pre></td></tr></table></figure><p>开始执行 PromiseJobs 中的任务</p><p>依次执行 f2 f4, 没有产生新的 job, PromiseJobs 变为空, 当前循环结束。</p><p>例子二：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>();</span><br><span class="line">    &#125;)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">f3</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">f4</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">f5</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3.1</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1.1</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>();</span><br><span class="line">    &#125;)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">f6</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">resolve</span>();</span><br><span class="line">        &#125;)</span><br><span class="line">          .<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">f7</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">          &#125;)</span><br><span class="line">          .<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">f8</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">f9</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">f10</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出: 0 1 1.1 2 3 3.1 4 5 6</span></span><br></pre></td></tr></table></figure><p>Promise 在创建时, 直接调用了 resolve, 所以 f1 进入 PromiseJobs 队列. PromiseJobs &#x3D; [f1]<br>f2 需要等待 f1 的执行结果才能进入 PromiseJobs 队列中, f10 需要等待 f2, 所以 f2 f10 都进入临时队列. PromiseFulfillReactions &#x3D; [f2, f10]<br>输出 0, js 所有代码执行结束. 开始执行 PromiseJobs 队列中的逻辑</p><pre><code>f1 出队并执行, f1 执行过程中, 遇到了新的 Promise, 并直接调用了 resolve, 所以 f3 的状态直接被固定, 进入 PromiseJobs 队列. PromiseJobs = [f3]f4 和 f5 需要等待 f3 的结果才能入 PromiseJobs 队列. 所以只能进入临时队列. PromiseFulfillReactions = [f2, f10, f4, f5]f1 逻辑代码执行完毕, 相当于 resolve(undefined) , f2 进入 PromiseJobs 队列.  PromiseJobs = [f3, f2], PromiseFulfillReactions = [f10, f4, f5]. 开始执行 PromiseJobs 队列中的逻辑f3 出队并执行, 输出 1, 逻辑代码执行完毕, f3 返回 undefined, 因此 f4 进入 PromiseJobs 队列.  PromiseJobs = [f2, f4], PromiseFulfillReactions = [f10, f5]. 开始执行 PromiseJobs 队列中的逻辑f2 出队并执行, 输出 1.1, 遇到新的 Promise, 新的 Promise 直接调用了 resolve, f6 直接进入 PromiseJobs 队列.  PromiseJobs = [f4, f6], f9 进入临时队列, PromiseFulfillReactions = [f10, f5, f9]f2 代码执行完毕, 返回 undefined, f10 进入 PromiseJobs , PromiseJobs = [f4, f6, f10], PromiseFulfillReactions = [f5, f9]. 开始执行 PromiseJobs 队列中的逻辑f4 出队并执行, 输入 2, 返回 undefined, f5 进入 PromiseJobs, PromiseJobs = [f6, f10, f5], PromiseFulfillReactions = [f9]. 开始执行 PromiseJobs 队列中的逻辑f6 出队并执行, 遇到了新的 Promise, 新的 Promise 直接调用了 resolve, f7 进入 PromiseJobs 队列, PromiseJobs = [f10, f5, f7], f8 进入临时队列.  PromiseFulfillReactions = [f9, f8].f6 执行完毕, 返回 undefined, f9 进入 PromiseJobs . PromiseJobs = [f10, f5, f7, f9].  PromiseFulfillReactions = [f8]. 开始执行 PromiseJobs 队列中的逻辑f10 出队并执行, 输出 3, PromiseJobs = [f5, f7, f9], PromiseFulfillReactions = [f8].  开始执行 PromiseJobs 队列中的逻辑f5 出队并执行, 输出 3.1,  PromiseJobs = [f7, f9], PromiseFulfillReactions = [f8].  开始执行 PromiseJobs 队列中的逻辑f7 出队并执行, 输入 4, 返回了 undefined, f8 进入 PromiseJobs 队列.  PromiseJobs = [f9, f8], PromiseFulfillReactions = [].  开始执行 PromiseJobs 队列中的逻辑f9 出队并执行, 输出 5, PromiseJobs = [f8], PromiseFulfillReactions = [], 开始执行 PromiseJobs 队列中的逻辑f8 出队并执行, 输出 6, PromiseJobs = [], PromiseFulfillReactions = []. 循环结束</code></pre><h2 id="内循环的实现"><a href="#内循环的实现" class="headerlink" title="内循环的实现"></a>内循环的实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queue = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个事件分发器</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">rafx</span>(<span class="params">cb</span>) &#123;</span><br><span class="line">  queue.<span class="title function_">push</span>(cb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">rafx</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0.1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">rafx</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0.2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">rafx</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0.21</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">rafx</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0.3</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">rafx</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0.4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">rafx</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0.5</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cb;</span><br><span class="line"><span class="keyword">while</span> ((cb = queue.<span class="title function_">shift</span>())) &#123;</span><br><span class="line">  <span class="title function_">cb</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出: 0.1 0.2 0.3 0.4 0.5 0.21</span></span><br></pre></td></tr></table></figure><p>queue 队列为空时，才结束执行。</p><h1 id="事件循环到底是怎么回事"><a href="#事件循环到底是怎么回事" class="headerlink" title="事件循环到底是怎么回事"></a>事件循环到底是怎么回事</h1><p>我们已经知道，单纯依靠 call stask 不能完全覆盖所有代码的执行逻辑，call stask 的代码执行顺序永远都是同步的逻辑。对于许多线程引发的异步逻辑，需要依靠队列机制。<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708327269186.png" alt="pic.1708327269186"><br>每一个异步行为，都有对应的执行队列。</p><h2 id="执行队列"><a href="#执行队列" class="headerlink" title="执行队列"></a>执行队列</h2><p>会在一轮循环中，直接执行的队列。如 PromiseJobs 队列。</p><h2 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h2><p>不会马上执行，处于等待状态的队列。在 promise 中，有两个临时队列， PromiseFulfilledReactions 与 PromiseRejectedReactions 。<strong>在满足条件后，才会将该队列中的任务，移入到执行队列中</strong>。有的临时队列又被称为事件表 <strong>Event Table，</strong>或注册表。</p><p><strong>关于临时队列的理解</strong><br>通常，在代码中，setTimeout，事件 I&#x2F;O，http 请求，都会通过回调的方式编写代码的执行逻辑。<br>例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 点击之后执行的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">d.<span class="property">onclick</span> = foo;</span><br></pre></td></tr></table></figure><p>foo 就是回调函数。函调函数里的逻辑不会马上执行，而是要等到条件满足之后才会执行。</p><h2 id="执行队列有哪些"><a href="#执行队列有哪些" class="headerlink" title="执行队列有哪些"></a>执行队列有哪些</h2><ul><li><strong>scriptJobs</strong>：指的是 script 标签，更顶层的供任务，S 代码执行的起点</li><li><strong>rafs</strong>：requestAnimationFrame 对应的队列</li><li><strong>UI render</strong>：渲染 UI 的任务队列</li><li><strong>ric</strong>：requestIdleCallback 对应的队列</li><li><strong>event queue</strong>：I&#x2F;O 事件列队</li><li><strong>timer queue：</strong>定时器队列，由 setTimeout&#x2F;setInterval 分发</li><li><strong>http queue：</strong>http 队列</li><li><strong>PromiseJobs：</strong>Promise 队列，由 p.then 分发</li></ul><h3 id="宏任务队列与微任务队列"><a href="#宏任务队列与微任务队列" class="headerlink" title="宏任务队列与微任务队列"></a>宏任务队列与微任务队列</h3><p>每个队列都有各自鲜明的特点，如果非要区分这些异步队列是宏任务队列还是微任务队列，那么，除了 PromiseJobs ，其它的都可以理解为宏任务队列。</p><h2 id="一轮循环的起点"><a href="#一轮循环的起点" class="headerlink" title="一轮循环的起点"></a>一轮循环的起点</h2><p><strong>同一时间，不会存在两个任务同时执行的情况。</strong><br>UI 渲染也是一个任务，也不会与其它任务同时执行。所以我们常说，UI 渲染与 JS 代码时互斥的关系。</p><ul><li>我们知道，PromiseJobs 是内循环，所以永远不可能作为一轮循环的起点</li><li>UI render 的渲染，由 GUI 线程执行。所以 UI render 队列也不会是一轮循环的起点。</li></ul><p><em>UI render 队列，是纯粹的渲染任务队列。既然要渲染任务，那必须有分发任务的指令才知道如何渲染。发起一个 http 请求也算是一个指令。</em></p><p>除了 PromiseJobs 和 UI render，其他所有任务队列中的任务「称之为 task」，都有可能是一轮循环的起点。</p><h2 id="一轮循环完毕的标志"><a href="#一轮循环完毕的标志" class="headerlink" title="一轮循环完毕的标志"></a>一轮循环完毕的标志</h2><p><strong>当次循环所有的执行队列</strong>都清空之后，一轮循环完毕。<strong>一轮循环完毕的标志是最后一个 task 中的内循环 PromiseJobs 队列清空</strong>。</p><h2 id="事件循环的顺序"><a href="#事件循环的顺序" class="headerlink" title="事件循环的顺序"></a>事件循环的顺序</h2><p>从 script 开始第一次循环</p><ol><li>所有能作为起点的队列中的任务，都是进入主线程执行，借助函数调用栈依次执行，等调用栈清空，并且 PromiseJobs 为空，当次任务结束。PromiseJobs 是 task 的内循环</li><li>当次任务执行过程中，可能会产生新的任务，这些任务会放入临时队列或者下一次循环（比如定时器任务）的执行队列，当次循环的执行队列是执行一个少一个，直到清空为止。</li><li>任务分发时，多半都是进入临时队列，满足条件后，进入执行队列。</li><li>下一轮循环从执行队列中的第一个任务开始执行，直到当次执行队列清空为止</li><li>多个执行队列之间存在先后关系。raf -&gt; ui render -&gt; [event，http，timer] -&gt; ric</li><li>raf | ui render | ric 三个队列中的 task 不会每次循环都执行，他们的执行频率要和刷新率保持一致。因此多次循环中，他们都不会执行「执行队列为空」</li></ol><h2 id="任务进入执行队列的时机"><a href="#任务进入执行队列的时机" class="headerlink" title="任务进入执行队列的时机"></a>任务进入执行队列的时机</h2><p>以 setTimeout 为例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">onclick</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;s&quot;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5000000000</span>; i++);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;e&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击之后的输出结果</span></span><br><span class="line"><span class="comment">// 先立刻输出 s</span></span><br><span class="line"><span class="comment">// 10s 之后，依次快速输出</span></span><br><span class="line"><span class="comment">// e 0 1 2</span></span><br></pre></td></tr></table></figure><p>分析一下<br>setTimeout 执行时，三个 task 进入了临时队列。</p><p>但是 for 循环的执行时间非常长，超过了 3 秒，因此，在 for 循环执行的过程当中，定时器线程发现 timer 临时队列中的任务满足了条件，就之间放入到了 timer 执行队列。</p><p>等 for 循环结束时，就依次快速输出 e 1 2 3。</p><p>再说 setInterval</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">func</span>();</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>当 f1 的执行之间，会将 f1 放入临时队列。然后每隔 100 ms，会将 f1 这个任务重复的放入执行队列中。</p><p>这时候会有个问题，如果任务 f1 的执行时间超过 100 ms, 那么一轮循环里，执行队列里必然会多出一个 f1 任务，这就会让本次循环的时间拉长，后面队列的任务就会等待更多时间。</p><p>所以在 chrome 中，为了弱化这种情况的影响，timer 队列往往放在最后执行「仅比 ric 早」。</p><p>也正是这个原因，我们应该避免使用 setInterval, 不合理的使用可能会造成页面的严重卡顿。</p><p>所以我们常常使用 setTimeout 的递归调用方式来取代 setInterval .</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="comment">// 这句代码一定要放在最后</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(fn, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure><p>这种递归的方式，每次在 fn 执行完之后，才会 push 一个任务到临时队列中。然后临时队列满足 100 ms 的时间之后推入执行队列。也就是说，执行队列中的任务始终只会有一个，即使 fn 的执行时间超过了 100 ms，那它的影响也仅此而已，不会像 setInterval 那样累加。</p><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>最有，再通过一个例子分析下事件循环的执行顺序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">s1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line">&#125;, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">s2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    i == <span class="number">99</span> &amp;&amp; <span class="title function_">resolve</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">p1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 1 2 3 4 5 6</span></span><br></pre></td></tr></table></figure><p>事件循环从 script 开始, 在主线程, 此时只有 scriptJobs 队列中有任务</p><p>遇到第一个 setTimeout 函数, setTimeout 进入函数调用栈, setTimeout 分发一个 task s1 进入临时队列, 但是因为 1ms 时间太短, 因此 s1 直接进入 timer 执行队列, timer &#x3D; [s1], setTimeout 出栈</p><p><em>我们可能决定不立刻执行一个函数，而是在某时间之后执行，一般我们成为“调度执行”</em><br><em>因为调度的执行时间太短了，只有 1ms , 因此会立刻进入到执行队列。如果改成 2ms ,就可能不会这么快，就会先进入临时队列</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">s1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line">&#125;, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">s2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 输出: 5 6</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">s1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line">&#125;, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">s2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 输出: 6 5</span></span><br></pre></td></tr></table></figure><pre><code>又遇到 setTimeout, setTimeout 进入函数调用栈执行, setTimeout 分发一个 task s2, 因为延迟时间为 0, s2 直接进入 timer 执行队列队列, timer = [s1, s2] setTimeout 出栈接下来遇到 Promise 的创建, Promise 构造函数进入函数调用栈, Promise 的第一个参数我们称为 executor, executor 会在 Promise 内部直接执行, 所以 executor 进栈,又遇到 log 函数, log 进栈,输出 1, log 出栈. 在 for 循环时 遇到了 resolve 函数, resolve 进栈执行, Promise 状态被固定. log 进栈, 输出 2, log 出栈, resolve 出栈, executor 出栈, Promise 出栈Promise 执行完, 接着执行 then 方法, 因此 then 进栈. then 方法时 Promise 的异步分发器. 本来 p1 应该直接进入 Promise 的临时队列, 但是 resolve 已经直接执行过了, 状态被固定, 因此已经知道了该如何执行, 所以 p1 直接进入 PromiseJobs 执行队列.p1 进入执行队列后, then 执行完毕, 出栈.然后遇到 log, log 进栈, 输出 3, log 出栈.到这里, 主线程中的代码执行完毕, 调用栈也被清空了, 因此接下来就要执行 PromiseJobs 内循环. 发现 PromiseJos 队列中有任务, 开始执行 PromiseJobs 队列中的逻辑p1 出队, 进入调用栈, p1 开始执行, log 进栈, 输出 4, log 出栈. p1 逻辑执行完毕, 出栈. 至此, PromiseJobs 执行队列已经清空, 内循环执行完毕. 当轮产生的 setTimeout 的任务, 应该放在下一轮执行. 至此第一轮循环结束开始第二轮循环, 发现 timer 执行队列中有任务, s1 出队并进入函数调用栈, log 进栈, 输出 5, log 出栈, s1 出栈, timer = [s2]s2 出队并进入函数调用栈, log 进栈, 输出 6, log 出栈, s2 出栈. s2 执行完之后, timer 队列也被清空了, 检查发现 PromiseJobs 队列中也没有任务, 所以可执行代码执行完毕, 循环结束</code></pre><h2 id="模拟一个没有临时队列的外循环事件分发器"><a href="#模拟一个没有临时队列的外循环事件分发器" class="headerlink" title="模拟一个没有临时队列的外循环事件分发器"></a>模拟一个没有临时队列的外循环事件分发器</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用数组模拟一个队列</span></span><br><span class="line"><span class="keyword">var</span> tasks = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟一个事件分发器</span></span><br><span class="line"><span class="keyword">var</span> addFn1 = <span class="keyword">function</span> (<span class="params">task</span>) &#123;</span><br><span class="line">  tasks.<span class="title function_">push</span>(task);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行所有的任务</span></span><br><span class="line"><span class="keyword">var</span> flush = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  tasks.<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">task</span>) &#123;</span><br><span class="line">    <span class="title function_">task</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后利用setTimeout/或者其他你认为合适的方式丢入事件循环中</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">flush</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分发任务</span></span><br><span class="line"><span class="title function_">addFn1</span>(<span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;my name is add fn&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">addFn1</span>(<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;my name is foo fn&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>也可以不利用事件循环，而是手动在适当的时机去执行对应的某一个方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用数组模拟一个队列</span></span><br><span class="line"><span class="keyword">var</span> tasks = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟一个事件分发器</span></span><br><span class="line"><span class="keyword">var</span> addFn1 = <span class="keyword">function</span> (<span class="params">task</span>) &#123;</span><br><span class="line">  tasks.<span class="title function_">push</span>(task);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去执行对应的某一个方法</span></span><br><span class="line"><span class="keyword">var</span> dispatch = <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">  tasks.<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.<span class="property">name</span> === name) &#123;</span><br><span class="line">      item.<span class="title function_">handle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// task 只需要多保存一个 name 即可。格式如下</span></span><br><span class="line">demoTask = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;demo&quot;</span>,</span><br><span class="line">  <span class="attr">handle</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;my name is demoTack&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">addFn1</span>(demoTask);</span><br><span class="line"><span class="title function_">dispatch</span>(<span class="string">&quot;demo&quot;</span>);</span><br></pre></td></tr></table></figure><p>于是，一个订阅-通知的设计模式就这样实现了。</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p><strong>为什么要有一轮两轮</strong><br>相当于给一个浏览器一个缓存的时间。告诉浏览器下一轮该执行什么，而不是打他个措手不及。如果没有异步任务，那其实一轮就够了。<br>再回到之前的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 点击之后执行的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">d.<span class="property">onclick</span> = foo;</span><br></pre></td></tr></table></figure><p>从 script 标签开始第一轮循环，给 I&#x2F;O 事件临时队列分发一个 task foo，主线程代码执行完毕，第一次循环结束。</p><p>当满足 onclick 条件时，foo 移入 I&#x2F;O 事件队列, 并开始出队执行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码规范</title>
      <link href="/2024/02/07/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
      <url>/2024/02/07/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h1><p>通过配置<code>.eslintrc.*</code>指定团队代码规范。在编码过程中，对于不规范的代码能够进行提示，帮助开发者更正代码。同时，提供 auto-fix 能力。<br>auto-fix 能够修复的问题比较有限，无法修复较大变动的规范问题，如：单行不能超过 80 个字符。</p><h1 id="prettier"><a href="#prettier" class="headerlink" title="prettier"></a>prettier</h1><p>prettier 是什么？</p><p>prettier 能根据<code>.eslintrc.*</code>的约定，自动格式化代码。具有比 eslint auto-fix 更加强大的代码修复能力。</p><p>配置 prettier 的几种方式：</p><p>可以使用 vscode settings.json、prettier 配置文件或.editorconfig 文件。VSCode settings.json 是用来作为备用的，通常只用于非项目文件，不能用于 prettier CLI。建议你总是在项目中包含一个 prettier 配置文件，这将确保无论你以何种方式运行 prettier（通过 prettier-vscode 插件 or prettier CLI [prettier –single-quote ]），都将应用同样的格式化选项。<br>推荐使用 prettier 配置文件来设置格式化选项。如果你想将 prettier 的格式化选项应用于整个项目，只需在项目根目录下添加一个 prettier 配置文件即可。</p><h2 id="配置-prettier"><a href="#配置-prettier" class="headerlink" title="配置 prettier"></a>配置 prettier</h2><p>所有的 prettier 配置项都可以直接在 settings.json 中配置，这些配置的默认值始终是 prettier 2.0 的默认值。</p><p>一般我们需要<code>npm install prettier</code>进行安装，再进行使用，这里先不介绍如何使用，主要介绍下在 vs code 中的使用。</p><h2 id="在-vs-code-中使用-prettier"><a href="#在-vs-code-中使用-prettier" class="headerlink" title="在 vs code 中使用 prettier"></a>在 vs code 中使用 prettier</h2><ul><li><strong>在 vs code 应用商店安装 prettier 插件</strong></li></ul><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708325653485.png" alt="pic.1708325653485"></p><ul><li><strong>配置插件.prettierrc</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">printWidth</span>: <span class="number">80</span>, <span class="comment">//一行的字符数，如果超过会进行换行，默认为80</span></span><br><span class="line">  <span class="attr">tabWidth</span>: <span class="number">2</span>, <span class="comment">//一个tab代表几个空格数，默认为2</span></span><br><span class="line">  <span class="attr">useTabs</span>: <span class="literal">false</span>, <span class="comment">//是否使用tab进行缩进，默认为false，表示用空格进行缩减</span></span><br><span class="line">  <span class="attr">singleQuote</span>: <span class="literal">false</span>, <span class="comment">//字符串是否使用单引号，默认为false，使用双引号</span></span><br><span class="line">  <span class="attr">semi</span>: <span class="literal">true</span>, <span class="comment">//行位是否使用分号，默认为true</span></span><br><span class="line">  <span class="attr">trailingComma</span>: <span class="string">&quot;none&quot;</span>, <span class="comment">//是否使用尾逗号，有三个可选值&quot;&lt;none|es5|all&gt;&quot;</span></span><br><span class="line">  <span class="attr">bracketSpacing</span>: <span class="literal">true</span>, <span class="comment">//对象大括号直接是否有空格，默认为true，效果：&#123; foo: bar &#125;</span></span><br><span class="line">  <span class="attr">parser</span>: <span class="string">&quot;babylon&quot;</span>, <span class="comment">//代码的解析引擎，默认为babylon，与babel相同。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="eslint-与-prettier"><a href="#eslint-与-prettier" class="headerlink" title="eslint 与 prettier"></a>eslint 与 prettier</h1><p><strong>区别：</strong></p><p>eslint 主要解决代码质量问题。代码风格问题并没有完全做完。而 Prettier 认为代码风格更重要，所以格式问题由 Prettier 处理。<br>但是 Prettier 的处理结果可能 eslint 不会完全满意，但绝对不丑，而且给予了部分配置项，可以通过<code>.prettierrc</code>文件修改。</p><p><strong>冲突:</strong></p><p>因为 eslint 和 prettier 一起使用会有冲突。可以通过<code>eslint-config-prettier</code> 这个插件解决。</p><p><strong>eslint-config-prettier</strong>：用 prettier 的规则，覆盖掉 eslint:recommended 的部分规则。因此不会有冲突。<br><strong>eslint-plugin-prettier</strong>：将 prettier 的能力集成到 eslint。按照 prettier 的规则检查代码规范性，并进行修复。</p><h1 id="editorconfig"><a href="#editorconfig" class="headerlink" title=".editorconfig"></a>.editorconfig</h1><p>开发者<strong>使用不同编辑器或系统时</strong>，将<code>.editorconfig</code>文件保存到项目根目录下，即可让项目下所有文件都<strong>统一编辑器代码风格。</strong><br>这个文件会覆盖编辑器的默认配置。<br><a href="https://www.cnblogs.com/lwming/p/15270816.html">https://www.cnblogs.com/lwming/p/15270816.html</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># <span class="attr">http</span>:<span class="comment">//editorconfig.org</span></span><br><span class="line">root = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[*]</span><br><span class="line">charset = utf-<span class="number">8</span></span><br><span class="line">end_of_line = lf</span><br><span class="line">indent_size = <span class="number">2</span></span><br><span class="line">indent_style = space</span><br><span class="line">insert_final_newline = <span class="literal">true</span></span><br><span class="line">max_line_length = <span class="number">80</span></span><br><span class="line">trim_trailing_whitespace = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[*.<span class="property">md</span>]</span><br><span class="line">max_line_length = <span class="number">0</span></span><br><span class="line">trim_trailing_whitespace = <span class="literal">false</span></span><br></pre></td></tr></table></figure><h1 id="vscode-settings-json"><a href="#vscode-settings-json" class="headerlink" title="vscode settings.json"></a>vscode settings.json</h1><p>settings.json 文件是 VS Code 众多“配置文件”中的一个，用来控制诸多工作项的配置。<br>按快捷键【Ctrl】+【,】，打开 VS Code 的设置界面，<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708325666467.png" alt="pic.1708325666467"><br>可以看到设置内容有“用户” “工作区”两个分支，它们其实就分别对应了两个不同位置的 settings.json 文件，前者位于与用户相关联的特定文件夹中，后者就会位于你当前打开的文件夹的.vscode 子目录下。这两个 settings.json 文件其实都只会包含你修改过的设置项，而软件的全局默认设置则记录在软件安装目录中的某个位置，用户是不必理会的。<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708325675886.png" alt="pic.1708325675886"><br>这些配置文件具有工作区&gt;用户&gt;全局默认 的优先级，也就是前面的配置覆盖后面的，这样做的好处是你可以为不同工作区、不同用户做不同配置，而不会互相干扰。而当你不小心在某个工作区做了错误的配置导致软件不能正常工作时，只需删除相应的设置项，或者 settings.json 文件，即可恢复到用户配置或默认配置。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工作区分支 .vscode/setting.json</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;prettier.printWidth&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;editor.formatOnSave&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// 一个制表符等于的空格数。</span></span><br><span class="line">  <span class="attr">&quot;editor.tabSize&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;editor.fontSize&quot;</span><span class="punctuation">:</span> <span class="number">13</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>以“prettier”开头的配置项可以放在.prettierrc 文件中</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于 vscode 配置，setting.json 文件只会包含你「手动添加」过的设置项，在「设置页面中勾选」和「手动添加」设置项的效果是一致的。为了保持多项目使用同一份配置，建议将需要的配置『手动添加』到工作区分支的 setting.json 文件中，后续只需拷贝 setting.json 文件即可。</p><p><strong>参考</strong><br><a href="https://its401.com/article/yexudengzhidao/113249805">https://its401.com/article/yexudengzhidao/113249805</a><br>prettier: <a href="https://juejin.cn/post/6914549928131821576">https://juejin.cn/post/6914549928131821576</a></p><h1 id="Q-A"><a href="#Q-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><p><strong>修改了.gitignore 文件但无效？</strong><br>如果在开发的过程中添加或者修改了.gitignore 文件，那么它可能不会生效，因为一些需要忽略的文件已经加入了 git 的追踪列表中，可以通过清除 git 缓存来使新的.gitignore 生效。方法如下：<br>:::info<br>第一步：cd 到项目目录<br>第二步：git rm -r –cached .<br>第三步：git add .<br>第四步：git commit -m ‘update .gitignore’<br>:::</p><p><a href="https://its401.com/article/yexudengzhidao/113249805"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 项目场景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>作用域和作用域链</title>
      <link href="/2024/02/07/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
      <url>/2024/02/07/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>作用域是 <strong>规定变量与函数可访问范围的一套规则</strong>。</p><p>最常见的两种作用域，分别是全局作用域和函数作用域。</p><p><strong>词法作用域</strong></p><p>与词法作用域对立的是动态作用域，所有也可以成为静态作用域。因为我们前端领域没有动态作用域的概率，所以可以统称为作用域。</p><h2 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h2><p>全局作用域中声明的代码，可以在任何地方被访问。以下三种情形属于全局作用域</p><ol><li>在全局对象(window)下的属性与方法</li><li>在最外层声明的变量与方法</li><li>在非严格模式中，函数作用域中未申明直接赋值的属性和方法</li></ol><p>我们应该尽量少将变量或方法定义为全局，因为</p><ol><li>我们可能无意间修改了全局变量的值，但其他场景不知道</li><li>容易造成命名冲突</li><li>在应用程序的执行过程中，全局变量的内存无法被释放</li></ol><p><strong>知识体系关联：</strong></p><p>css 没有作用域的概念，那么也就意味着，每一个组件的样式都有可能影响别的组件布局，因为我们常常会通过一些方式让当前组件具备方为约束，以达到作用域的效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.sidebar</span> <span class="selector-class">.container</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sidebar</span> <span class="selector-class">.content</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 vue 中，也专门提供了 css 作用域的语法，以达到类似效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line"><span class="selector-class">.example</span>&#123;</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>会被编译为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.<span class="property">example</span>[data-v-f3f3eg9] &#123;</span><br><span class="line">  <span class="attr">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;example&quot;</span> <span class="attr">data-v-f3f3eg9</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>有一个细节需要关注一下，在全局声明的变量还存在一些差异。<br>使用 var 声明的变量，会被挂载到 window 对象下<br>而使用 const&#x2F;let 的变量，会被挂载到 script 对象下</p><h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><p>函数表达式或函数声明让花括号具备作用域，我们称之为函数作用域。函数作用域中的变量与方法，只能在下层子作用域中被访问，不能被其他不相关的作用域访问。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;do something by &quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// i == 5</span></span><br></pre></td></tr></table></figure><p>这种方式并不会有作用域的限制，i 挂载在全局对象下，循环结束后，i 还能被访问。<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708405619882.png" alt="pic.1708405619882"></p><h2 id="模拟块级作用域"><a href="#模拟块级作用域" class="headerlink" title="模拟块级作用域"></a>模拟块级作用域</h2><p>在没有块级作用域之前，我们可以使用自执行函数模拟块级作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;do something by &quot;</span>, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// i is not defined</span></span><br></pre></td></tr></table></figure><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>es6 引入了块级作用域。使用<code>let</code> 和 <code>const</code>声明的变量，能被任何花括号约束</p><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// Uncaught ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 1 2 3 4 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能重复声明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">20</span>; <span class="comment">// Uncaught SyntaxError: Identifier &#x27;a&#x27; has already been declared</span></span><br></pre></td></tr></table></figure><p>不能在声明前访问，因为存在暂时性死区</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// Uncaught ReferenceError: Cannot access &#x27;a&#x27; before initialization</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const 与 let 差不多，唯一不同的是，const 声明的变量的值不能被修改。</p><p>如果是基础数据类型，则值不能被修改。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line">a = <span class="number">2</span>; <span class="comment">// Uncaught TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure><p>如果是引用数据类型，则地址不能被修改。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">n</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="comment">// a = &#123;&#125;   // 这样不行</span></span><br><span class="line">a.<span class="property">n</span> = <span class="number">2</span>; <span class="comment">// 这样可以修改</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br></pre></td></tr></table></figure><p>let 和 const 的使用原则是，优先使用 const，不能用 const 再用 let。</p><h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><p><strong>在一个函数内，能够访问哪些变量与函数，都要有一个具体的方式体现出来</strong>。因此有了作用域链。</p><p>每一个函数都有一个 [[scopes]] 属性，它是由一系列父作用域对象组成的数组。</p><p><strong>当一个函数要寻找变量的值是从哪来的，就首先会在当前执行上下文中查找，如果没有找到，就回去作用域链中查找。作用域链存在于函数对象的一个属性 [[scopes]]，该属性在代码预解析阶段就已经确定了。</strong></p><p>完整作用域链的组成部分</p><ul><li>Global 全局对象</li><li>Script 对象：全局环境下 let&#x2F;const 声明的变量对象（变量和函数）</li><li>Closure 对象：闭包对象，嵌套函数生成</li><li>Local 对象：可称为活动对象。<strong>只有这个对象是在函数执行过程中才会确定</strong>，其它在函数声明是就确定了。local 对象会记录当前函数上下文的变量与函数声明，还会额外记录 this</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存与数据结构</title>
      <link href="/2024/02/07/%E5%86%85%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/02/07/%E5%86%85%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>把一个页面看做一个完整的独立应用。</p><p>那么，哪些个体参与了应用，个体以什么形式存在的，个体存放在哪里，个体在内存中如何存放？</p><p>个体 -&gt; 数据类型 -&gt; 内存 -&gt; 数据结构</p><h1 id="个体"><a href="#个体" class="headerlink" title="个体"></a>个体</h1><p>个体可以理解为角色，这些角色会参与应用运行<br>有变量、函数、对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 申明变量</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 申明函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="comment">// 申明对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">M</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>a、add、M 表示个体的名字。我们可以通过名字，访问到具体的值。</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>7 种基础数据类型和一种引用类型</p><h2 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h2><p>基础数据类型：Boolean、Null、Undefined、Number、String、BigInt、Symbol</p><p>重点理解 <strong>基础数据类型的值，是不可变的</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line">b++;</span><br></pre></td></tr></table></figure><p>将 a 赋予 b，这时候 a 和 b 是等价的。随后 b++，b 的值被改变了，a 的值却没有改变。这意味着 a b 的等价，并不表示他们是同一个值。也就是说，a 赋予 b 的时候，重新给 b 分配了一块内存空间。因此我们说，<strong>基础数据类型，是按值访问的。</strong>用图表示<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708326860642.png" alt="pic.1708326860642"><br><strong>基础数据类型的比较，是值在比较</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">1</span>;</span><br><span class="line">a === b; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>当 a 和 b 在比较的时候，本质上是值在比较。</p><p>还有一点要注意，当我们使用字符串时，竟然可以使用方法，这是因为访问字符串时，实际上依然是在访问一个对象。使用字符串调用方法时，经历了以下 3 步骤</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先使用包装对象创建对象</span></span><br><span class="line"><span class="keyword">var</span> _str = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后使用包装对象的实例去访问方法</span></span><br><span class="line">_str.<span class="title function_">charAt</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后销毁该对象</span></span><br><span class="line">_str = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2><p>与基础数据类型不同，<strong>引用类型的值是可以被改变的</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> book = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&quot;JavaScript 核心进阶&quot;</span>,</span><br><span class="line">  <span class="attr">author</span>: <span class="string">&quot;这波能反杀&quot;</span>,</span><br><span class="line">  <span class="attr">date</span>: <span class="string">&quot;2020.08.02&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> b2 = book;</span><br><span class="line">b2.<span class="property">author</span> = <span class="string">&quot;反杀&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(book); <span class="comment">// &#123;title: &quot;JavaScript 核心进阶&quot;, author: &quot;反杀&quot;, date: &quot;2020.08.02&quot;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b2); <span class="comment">// &#123;title: &quot;JavaScript 核心进阶&quot;, author: &quot;反杀&quot;, date: &quot;2020.08.02&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>我们发现，修改变量 b2 的值，变量 book 也被修改了。这是因为执行 b2&#x3D;book 时，b2 拷贝的是 book 的地址，所以他们指向的是同样的引用类型值。我们可称之为<strong>浅拷贝。</strong><br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708326879449.png" alt="pic.1708326879449"></p><p>所以说，<strong>引用数据类型，是按引用访问的</strong>。这里的引用，指的就是内存中的地址。</p><p><em>地址：我们常说的地址，其实指的是内存中的首地址，因为一个引用对象占多少个内存格子是不确定的。内存管理器知道这个引用的大小，那么就能找到首尾地址。</em></p><p><strong>引用类型的比较，本质上是他们的内存地址在比较</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> b = a;</span><br><span class="line">b.<span class="property">name</span> = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">a === b; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> d = &#123;&#125;;</span><br><span class="line">c === d; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>由于 c 和 d 是两个分开创建的对象，所以他们在内存中的地址是不一样的，所以结果也不同。直接比较引用地址，我们可以称之为<strong>浅比较。</strong></p><p><em>还有一种场景，只比较一层数据结构，也被认为是浅比较，这种比较成本比较低，浅拷贝同理。</em></p><h2 id="数据类型判断"><a href="#数据类型判断" class="headerlink" title="数据类型判断"></a>数据类型判断</h2><p>判断是否为数组</p><ol><li>Array.isArray(arr)</li><li>arr instanceof Array</li><li>Object.prototype.toString.call(arr) &#x3D;&#x3D;&#x3D; ‘[object, Array]’</li></ol><p>判断是否为对象</p><ol><li>isObject</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isObject</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> type = <span class="keyword">typeof</span> value;</span><br><span class="line">  <span class="keyword">return</span> value != <span class="literal">null</span> &amp;&amp; (type === <span class="string">&quot;object&quot;</span> || type === <span class="string">&quot;function&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Object.prototype.toString.call(obj) &#x3D;&#x3D;&#x3D; ‘[object Object]’</li><li>obj instanceof Object 数组也成立</li></ol><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p>运行一段 app&#x2F;进程，操作系统会分配一段连续的内存空间，在内存中运行。</p><p>内存用于储存程序运行时的信息。CPU 通过寄存器直接访问，访问速度非常快。<br>硬盘可以将大量电影、图片等信息永久存储在硬盘。CPU 不能直接访问硬盘的数据，要通过硬盘控制器来访问。</p><p>我们可以将一些数据做持久化储存，也就是常说的本地缓存，其实就是将数据存储在硬盘。在浏览器中，提供了 localStorage 对象来帮助我们实现本地缓存。</p><p>内存和硬盘的区别：</p><table><thead><tr><th><strong>对象</strong></th><th><strong>容量</strong></th><th><strong>访问速度</strong></th><th><strong>CPU 能否直接访问</strong></th><th><strong>存储时效</strong></th></tr></thead><tbody><tr><td>内存</td><td>小</td><td>快</td><td>能</td><td>程序运行时</td></tr><tr><td>硬盘</td><td>大</td><td>慢</td><td>不能</td><td>持久性</td></tr></tbody></table><p>JS 中，内存分为栈内存和堆内存。栈内存与堆内存本身没有区别，只因为存取方式的差异，而有了不同。</p><p>使用栈内存时，从地址高位开始分配内存空间。使用堆内存时，从地址低位开始分配。</p><p>:::info<br>内存中的地址本应该用 16 进制表示，为了便于理解，此处用 10 进制表示。<br>:::<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708326895926.png" alt="pic.1708326895926"></p><h3 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h3><p>Bit-比特<br>Byte-字节 计算机数据类型的最基本单位。1 Byte &#x3D; 8 Bits<br>KB-千字节<br>MB-兆字节<br>GB-吉字节<br>TB-太字节</p><p>1 GM &#x3D; 1024 MB<br>1 TB &#x3D; 1024 GB</p><p>英文字母 占一个字节空间<br>中文汉字 占两个字节空间<br>英文标点符号 占一个字节空间<br>中文标点符号 占两个字节</p><h3 id="指针、引用、对象"><a href="#指针、引用、对象" class="headerlink" title="指针、引用、对象"></a>指针、引用、对象</h3><p><strong>指针</strong>：也叫做首地址。指针占 4 个字节<br>0xFF<br>[1][2][3][4][][][][]</p><p><strong>引用</strong>：指针的别名。在我们前端里，可以认为指针和引用是同个东西。</p><p>举个例子：<br>基础数据类型：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>0xFF（十六进制。我们这里用十进制代替，更直观）<br>[10][20][][][][][][]</p><p>改为 20 后，引用变量 a 的指针发生改变。10 失去了引用，等待被回收。所以我们说基础数据类型的值是不可变的。<br>0xFF<br>[10][20][][][]</p><p>引用数据类型：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = 首地址 -&gt; &#123; <span class="attr">m</span>: <span class="number">10</span> &#125;</span><br></pre></td></tr></table></figure><p>首地址也是个基础数据类型。当我们改变引用类型时，首地址不变。</p><h1 id="基础数据结构"><a href="#基础数据结构" class="headerlink" title="基础数据结构"></a>基础数据结构</h1><p>基础数据结构主要介绍一下栈、堆、队列</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>说到栈，其实有两种场景，栈数据结构和栈内存空间。</p><p>第一种场景，<strong>栈数据结构：</strong>表达的是对数据的一种存取方式。</p><p>把栈数据结构的存取方式，通过乒乓球盒子来分析<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708326910241.png" alt="pic.1708326910241"><br>乒乓球依次入栈，5 号球位于最顶层，他一定是最后放进去的。1 号球位于最底层，你要想拿 1 号球，必须将上面所有乒乓球取出来之后才能取出。但 1 号球是最先放入盒子的。</p><p>这种存取方式与栈数据结构如出一辙。特点可以总结为<strong>先进后出，后进先出（LIFO Last in, First Out）。</strong></p><p>javaScript 中，数组提供了两个栈方法来应对这种存取方式。</p><p><strong>push</strong>：向数组末尾添加元素「进栈方法」<br><strong>pop</strong>：删除数组末尾元素「出栈方法」</p><p>第二种场景，<strong>栈内存空间</strong>。刚刚提到，内存空间，因为操作方式不同才有了区别，而栈内存空间的操作方式，正是使用了栈数据结构的思维。</p><p>栈内存空间，用于记录函数的执行记录，管理函数的执行顺序。我们称他为函数调用栈「call stack」</p><p>应用场景：有效的括号、两个栈实现队列</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p><strong>堆数据结构：</strong>是树结构中的一种。常见的是二叉堆。</p><p>二叉堆分为两种类型：最大堆和最小堆</p><p>最大堆：堆顶元素是整个堆中的最大值。任何父节点的键值都大于任何一个子节点<br>最下堆：堆顶元素是整个堆中的最小值。任何父节点的键值都小于任何一个子节点</p><p>以最小堆为例：</p><ul><li>插入节点时，只能插入二叉堆的最后一个位置。比较节点时，如果插入节点比父节点大，则需要上浮，持续比较，直到比父节点小为止</li><li>删除节点时，我们通常只会删除堆顶的元素。删除后结构出现了混乱，需要将最后一个节点补充到堆顶。补充后树结构不符合最小堆的特性，因此需要与子元素进行比较，找到最小的子元素与其交换位置，这个行为称之为下沉。持续比较，知道符合最小堆的规则</li></ul><p>应用场景：<br>数组的 sort 方法，也是采用类似堆的排序逻辑；前中后序遍历；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sort</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="comment">// 最小堆（升序）</span></span><br><span class="line">  <span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sort</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="comment">// 最大堆（降序）</span></span><br><span class="line">  <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栈和堆的区别</p><ul><li>分配方式不同：栈有操作系统分配；堆由开发人员分配</li><li>存放内容不同：栈用于存放函数的参数值、局部变量、函数返回值等；堆的存放内容由开发人员填充</li><li>释放方式不同：栈内存的数据，随生命周期函数的调用结束而结束。堆内存由开发人员释放，容易产生内存泄漏。</li><li>空间大小不同：每个进程拥有的栈大小远远小于堆大小。理论上，栈只有几兆大小，堆可以是虚拟内存的大小。</li></ul><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>先进先出的思维。在浏览器中，所有的异步事件都是放在任务队列中。</p><p>优先级队列是一个重要的概念，决定了哪个任务优先执行。</p><p>运用到实践中，有如下常用操作：</p><ol><li>从队列最后入队</li><li>从队列头部出队</li><li>从队列任意位置离队（有其他事情）</li><li>从队列任意位置插队（特殊权利）</li><li>清空队列</li></ol><p>应用场景：先到先处理</p><ul><li>医院挂号</li><li>promiseJobs</li></ul><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表是一种递归的数据结构，由多个节点组成，节点之前使用引用相互关联，组成一根链条。</p><p>链表的特征：</p><ul><li>在内存中，链表是松散不连续的结构，通过引用确定节点之间的联系，不像数组那样是排列在一起的连续内存地址</li><li>链表没有序列，如果引用是单向的，只能通过上一个节点，找到下一个节点</li><li>节点之间的引用可以是单向的「单向链表」，也可以是双向的「双向链表」，还可以是首尾连接的「循环链表」</li></ul><p>和数组的区别：</p><ul><li>在内存空间里，链表是松散的，不连续的。数组是紧密的，连续的</li><li>在性能角度考虑，访问某个成员，数组远远优于链表，而新增&#x2F;删除元素，链表远远优于数组</li></ul><p>应用场景：</p><ol><li>节点元素的相互引用，<code>nextSibling、previousSibling</code></li><li>原型链中，由<code>__proto__</code>进行关联的单向链表</li><li>react 源码中的<code>Fiber</code>节点中的<code>nextEffect</code></li></ol><h1 id="内存空间管理"><a href="#内存空间管理" class="headerlink" title="内存空间管理"></a>内存空间管理</h1><p>内存溢出：多指栈溢出</p><p>内存泄露：指某段内存空间无法被管理</p><ol><li>没有引用，无法被访问</li><li>失去引用时，没被标记，无法被垃圾回收机制回收</li></ol><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>基础数据类型存在栈内存，引用数据类型存在堆内存，这句话对不对？<br>不对。栈内存和堆内存本身并没有区别，只是存取方式的差异而有了不同。基础数据类型可以在栈里，也可以在堆里，函数执行时的参数、变量都在栈里。引用类型的地址在栈里，引用类型的数据在堆里。</p><p>变量会存在内存中吗，如果存在，以什么方式存在<br>不存在。内存中只存在 16 进制的地址编码和具体的数值</p><p>m 的值是否被改变？为什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">  arg.<span class="property">a</span> = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(m);</span><br></pre></td></tr></table></figure><p>m 被改变了。函数传入一个引用数据类型时，会干扰外部的值，参数变量的地址入栈内存，引用类型对象入堆内存。</p><p>为什么使用不可变数据类型：<br>因为浅比较无法比较出引用数据类型之间的差异</p><p>引用类型为什么有地址这个概念？<br>因为一个内存空间无法记录整个对象的值，所以用首地址（地址）来记录</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数写法</title>
      <link href="/2024/02/07/%E5%87%BD%E6%95%B0%E5%86%99%E6%B3%95/"/>
      <url>/2024/02/07/%E5%87%BD%E6%95%B0%E5%86%99%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h1><ul><li>函数名不可省略，省略了就变成非法语法</li><li>函数声明会存在函数提升</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h1><p>不存在函数提升，在使用前就得定义函数，阅读体验更好</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;&#125;;</span><br></pre></td></tr></table></figure><h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><p>匿名函数在回调参数中常见，可以省略函数名，优点是书写起来容易</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h2 id="匿名函数表达式"><a href="#匿名函数表达式" class="headerlink" title="匿名函数表达式"></a>匿名函数表达式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法二：匿名函数表达式</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二：箭头函数写法的匿名函数表达式</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><h1 id="立即执行函数表达式-IIFE"><a href="#立即执行函数表达式-IIFE" class="headerlink" title="立即执行函数表达式(IIFE)"></a>立即执行函数表达式(IIFE)</h1><p>Immediately Invoked Function Expression，函数名不是必须的，完全可以省略。<br>第一个括号把函数变成了表达式，第二个括号执行了这个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">IIFE</span>(<span class="params"></span>) &#123;&#125;)();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建</title>
      <link href="/2024/02/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2024/02/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>hexo + <a href="https://github.com/zchengsite/hexo-theme-oranges/tree/master">hexo-theme-oranges</a>主题 + Github Pages + 自定义域名<br><a name="rKYtK"></a></p><h1 id="Hexo-环境搭建"><a href="#Hexo-环境搭建" class="headerlink" title="Hexo 环境搭建"></a>Hexo 环境搭建</h1><ol><li>安装 hexo 并初始化，仓库名为 <strong>weilun0510.github.io</strong></li><li>更换主题：<a href="https://github.com/zchengsite/hexo-theme-oranges/tree/master">hexo-theme-oranges</a></li><li>修改_config.yml</li><li>添加项目说明</li><li>部署：安装 hexo-deployer-git<br><a name="irCGk"></a></li></ol><h2 id="gitalk-评论"><a href="#gitalk-评论" class="headerlink" title="gitalk 评论"></a>gitalk 评论</h2><ol><li>新建一个仓库 <strong>blog-comments</strong></li><li>新建开放认证应用 <a href="https://www.cnblogs.com/qisi007/p/13731562.html">https://www.cnblogs.com/qisi007/p/13731562.html</a></li><li>博客配置</li></ol><p>注意：配置后，需要手动新建一个 issues 才能使用</p><p>效果图：<br /><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1707273451889.png#id=aylXj&originHeight=297&originWidth=934&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p><a name="XdxYY"></a></p><h1 id="hexo-源码备份"><a href="#hexo-源码备份" class="headerlink" title="hexo 源码备份"></a>hexo 源码备份</h1><p>hexo 发布<code>hexo d</code>后，github 仓库上的 hexo 源代码会消失，只保留构建后的代码，如图所示：<br /><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1707273493092.png#id=oXpJK&originHeight=413&originWidth=650&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />万一 <strong>username.github.io</strong>本地仓库的代码丢失，后面就无法进行写作。<br />所以新建一个仓库，用于专门写作，如 <strong>blog</strong>。后面 <strong>username.github.io</strong> 项目不动，在 <strong>blog</strong> 上写作即可。<br><a name="JPz1u"></a></p><h1 id="Pages-自定义域名"><a href="#Pages-自定义域名" class="headerlink" title="Pages 自定义域名"></a>Pages 自定义域名</h1><ol><li>买个域名，如华为云</li><li>域名解析 -&gt; 添加记录集</li></ol><p>华为云提供了一种 CNAME 记录的设置方式，这样可以更好地适应服务器 IP 地址的变化。通过使用 CNAME 记录，你的域名将指向 GitHub Pages 的域名，而不是直接指向 IP 地址。这样，GitHub 在 IP 地址变更时会更新其域名的 DNS 记录，而你无需手动调整。</p><p>每次部署后自定义域名失效？</p><ul><li><a href="https://blog.csdn.net/Passerby_Wang/article/details/121209799">https://blog.csdn.net/Passerby_Wang&#x2F;article&#x2F;details&#x2F;121209799</a><br><a name="sQ0As"></a></li></ul><h1 id="图片存储-Github-Pages-PicGo"><a href="#图片存储-Github-Pages-PicGo" class="headerlink" title="图片存储(Github Pages + PicGo )"></a>图片存储(Github Pages + PicGo )</h1><p>github 做图床(免费，上限 100G) + picGo 上传图片</p><p>缺点：想使用 Github Pages ,仓库不能设置为 private，必须为 Public</p><p>实现：</p><ol><li>设置图床<ol><li>新建一个仓库 <strong>blog-images</strong></li><li>添加 index.html 文件，内容随意</li></ol></li><li>设置 picGo。我用的 vscode，<strong>注意</strong>：repo 值得格式为 <strong>username&#x2F;仓库名</strong><ol><li>配置参考： <a href="https://zhuanlan.zhihu.com/p/138012354">https://zhuanlan.zhihu.com/p/138012354</a></li></ol></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;picgo.picBed.current&quot;</span><span class="punctuation">:</span> <span class="string">&quot;github&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;picgo.picBed.github.branch&quot;</span><span class="punctuation">:</span> <span class="string">&quot;master&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;picgo.picBed.github.token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;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&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;picgo.picBed.github.repo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;weilun0510/blog-images&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;picgo.customUploadName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pic.$&#123;Date.now()&#125;$&#123;extName&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;picgo.picBed.github.path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-02-07/&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>写作时，<code>picgo.picBed.github.path</code>根据写作日期进行更改，如<code>2424-02-27/</code>，这样图片就会保存在这个目录下。这样做的好处是图片保存路径与写作日期一致，到时想查找这张图片会很方便。</p><p>使用：<br />Uploading an image from clipboard</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Windows/Unix:</span><br><span class="line">ctrl + alt + u</span><br><span class="line"></span><br><span class="line">OsX:</span><br><span class="line">Cmd + Opt + u</span><br></pre></td></tr></table></figure><p>上传成功后的链接格式： <a href="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1707273493092.png">https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1707273493092.png</a></p><p>上传失败参考：<a href="https://blog.csdn.net/TalesOV/article/details/104450037">https://blog.csdn.net/TalesOV/article/details/104450037</a></p><p>参考:</p><ul><li><a href="https://github.com/yansheng836/yansheng836.github.io/blob/blog/docs/1hexo+yilia%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA.md">https://github.com/yansheng836/yansheng836.github.io/blob/blog/docs/1hexo+yilia%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA.md</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 项目搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数调用栈</title>
      <link href="/2024/02/07/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88/"/>
      <url>/2024/02/07/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h1><p>函数声明或函数表达式，都能够创建一个函数体。函数体也是数据，在代码解析阶段，被持久的存在于堆内存中。</p><h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><p>执行函数会创建执行上下文，执行上下文会占用新的内存空间。执行上下文会按函数体内编辑好的代码逻辑，实时的记录函数体在执行过程中的所有状态与数据。</p><p>JS 的运行环境：</p><ul><li>全局环境：代码运行时首先会进入全局环境，生成全局上下文</li><li>函数环境：当函数被调用时，进入函数环境执行代码，同时执行上下文被创建</li></ul><p>当调用一个新函数时，新的执行上下文就会被创建。JS 引擎使用栈的方式来跟踪多个执行上下文的运行情况，我们称之为「函数调用栈」。正在执行的函数永远处于栈顶，栈顶上下文执行完毕就会出栈，被垃圾回收器回收，新的栈顶上下文继续执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeColor</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> anotherColor = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">swapColors</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tempColor = anotherColor;</span><br><span class="line">    anotherColor = color;</span><br><span class="line">    color = tempColor;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">    <span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">trace</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">swapColors</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">changeColor</span>();</span><br></pre></td></tr></table></figure><ol><li>进入全局上下文，并一直处于栈底</li><li>遇到 <code>changeColor()</code>，创建 changeColor 上下文，新的上下文入栈并开始执行，此时全局上下文被挂起</li><li>遇到 <code>swapColors()</code>，创建 swapColors 上下文，新的上下文入栈并开始执行，changeColor 上下文被挂起</li><li>swapColors 代码执行完毕，swapColors 上下文出栈，等待被回收</li><li>changeColor 上下文激活，changeColor 代码执行完毕，changeColor 上下文出栈，等待被回收</li><li>全局上下文被激活，所有代码执行完毕，全局上下文出栈，函数调用栈被清空</li></ol><h1 id="console-trace"><a href="#console-trace" class="headerlink" title="console.trace()"></a>console.trace()</h1><p>我们可以使用 console 的 trace 方法打印出，当前函数调用栈中有哪些函数<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708325971422.png" alt="pic.1708325971422"></p><p>当我们代码报错时，浏览器的 console 面板也会把当前函数调用栈打印出来，这是我们定位 bug 的有效手段<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708325977284.png" alt="pic.1708325977284"></p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型和原型链</title>
      <link href="/2024/02/07/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/2024/02/07/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><p>实例对象共享的属性和方法，可以抽离出来放在一个对象中，这个对象就是原型对象。</p><ol><li>构造函数中，使用 prototype 指向原型对象</li><li>实例对象中，使用 <strong>proto</strong> 指向原型对象</li><li>原型对象中，使用 construct 指向构造函数</li><li>实例对象中，使用 construct 指向构造函数</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;p1: &quot;</span>, p1);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> === <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(p1));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(p1));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(p1).<span class="property">construct</span> === <span class="title class_">Person</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">construct</span> === <span class="title class_">Person</span>());</span><br></pre></td></tr></table></figure><p><strong>instanceof:</strong> 用于检测构造函数的原型对象是否出现在某个实例对象的原型链上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>操作原型的方法：</p><ul><li>Object.create: 根据指定的原型对象创建新对象。Object.create(proto, [propertiesObject])</li><li>Object.getPrototypeOf: 获取一个对象的原型。Object.getPrototypeOf(obj)</li><li>Object.setPrototypeOf: 设置一个对象的原型。Object.setPrototypeOf(obj, prototype)</li><li>Object.prototype.isPrototypeOf(): 返回一个布尔值，表示指定的对象是否在本对象的原型链中。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 操作原型的方法</span></span><br><span class="line"><span class="keyword">const</span> parentObj = &#123;</span><br><span class="line">  <span class="attr">add</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">a</span> + <span class="variable language_">this</span>.<span class="property">b</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.create: 接收一个现有对象为新对象的__proto__，第二参数为属性描述符对象</span></span><br><span class="line"><span class="keyword">const</span> newObj = <span class="title class_">Object</span>.<span class="title function_">create</span>(parentObj, &#123;</span><br><span class="line">  <span class="attr">a</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">10</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">b</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">20</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newObj.<span class="title function_">add</span>()); <span class="comment">// 30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> childObj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">20</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 设置一个指定对象的原型</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(childObj, parentObj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(childObj.<span class="title function_">add</span>()); <span class="comment">// 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定对象的原型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(childObj)); <span class="comment">// &#123;add: f&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个布尔值，用于检测一个对象的原型是否在另一个对象的原型链上</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(parentObj.<span class="title function_">isPrototypeOf</span>(childObj)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>实例、原型对象、构造函数关系图：<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708405528743.png" alt="pic.1708405528743"></p><h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>定义：<br>每一个对象都包含一个原型属性，用于关联另一个对象，关联后就能够使用那个对象的属性和方法；对象之前通过原型关联在一起，就好比一条锁链将一个个对象连接在一起，最终形成了一条原型链。</p><p>属性查找机制：<br>当查找对象属性时，如果实例对象自身不存在该属性，就从原型链往上一级查找，如果还没找到就再往上一级，直至最顶级的原型对象 Object.prototype，如果还没找到则返回 undefined</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾回收机制</title>
      <link href="/2024/02/07/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
      <url>/2024/02/07/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p><strong>垃圾</strong>：无任何引用的对象</p><p><strong>回收</strong>：清理被垃圾占用的内存</p><p><strong>区域</strong>：堆内存（栈内存有自己的回收机制）</p><p><strong>发生时间</strong>：程序空闲时间</p><h1 id="垃圾如何产生的"><a href="#垃圾如何产生的" class="headerlink" title="垃圾如何产生的"></a>垃圾如何产生的</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708326437848.png" alt="pic.1708326437848"></p><p>将变量 a 赋值为 2 的时候，会在内存中开辟一个新的空间，变量 a 指向这个新的地址，那么虚线部分的数据失去了连接，这时候它就成为了一个垃圾。如果不清理垃圾，等所以内存被占满时，内存就会溢出，所以有了垃圾回收机制。</p><p>垃圾回收机制是什么<br>垃圾回收机制是 V8 引擎实现的一套清理垃圾的方案，它会在程序空闲时，周期性的清理被标记为是垃圾的内存。</p><h1 id="识别垃圾（标记方式）"><a href="#识别垃圾（标记方式）" class="headerlink" title="识别垃圾（标记方式）"></a>识别垃圾（标记方式）</h1><p>识别垃圾有两种标记法，引用计数法和根搜索算法。</p><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>通过添加一个计数变量的方法，当对象被初始化赋值后，该变量计数为 1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">n</span>: <span class="number">1</span> &#125;; <span class="comment">// 计数变量 = 1</span></span><br></pre></td></tr></table></figure><p>当有一个地方引用它时，变量计数+1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = a; <span class="comment">// 计数变量 +1 = 2</span></span><br><span class="line"><span class="keyword">var</span> c = a; <span class="comment">// 计数变量 +1 = 3</span></span><br></pre></td></tr></table></figure><p>引用失效时，变量计数-1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="literal">null</span>; <span class="comment">// 计数变量 -1 = 2</span></span><br><span class="line">b = &#123;&#125;; <span class="comment">// 计数变量 -1 = 1</span></span><br></pre></td></tr></table></figure><p>当计数器为 0 时，则表示失去了所有引用，该对象成为垃圾。</p><p><strong>关联场景：改实现原理和数组 length 的实现一样。</strong></p><p>优点就是简单、高效。缺点就是无法解决循环引用的问题，这会导致内存泄漏。这个一个重大缺陷，所以 V8 没有采用这种标记法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123;</span><br><span class="line">  <span class="attr">n</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">next</span>: &#123;</span><br><span class="line">    <span class="attr">n</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">next</span>: p,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">p = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>![引用计数法的内存泄漏.png]<img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708326472502.png" alt="pic.1708326472502"><br>对象无法访问，计数也不为 0，无法被回收，导致内存泄漏。</p><p>循环引用的问题并不是没有办法解决，这需要开发者手动删除引用，即<code>let a = null</code> 这种方式。</p><h2 id="根搜索算法（标记法）"><a href="#根搜索算法（标记法）" class="headerlink" title="根搜索算法（标记法）"></a>根搜索算法（标记法）</h2><p>V8 采用根搜索算法，根搜索算法会对堆内存进行遍历，找到<strong>GC Root(根对象)<strong>引用的其他对象，</strong>能访问到的都标记为活跃对象</strong>，其余则为非活跃对象。</p><p>如果不考虑循环引用，GC Roots Set(根集)会表现为一颗树状结构。考虑循环引用，则会呈现出图结构，所以不存在内存泄露问题。<br>![根搜索算法.png]<img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708326483934.png" alt="pic.1708326483934"></p><p>根对象 Root：</p><ul><li>所有正在运行的栈上的引用变量</li><li>全局对象 Global、window(对于浏览器来说，Glocal 等于 window)</li><li>所有内置对象</li></ul><p>关于标记阶段指的注意的是，开始标记之前，需要先暂停应用线程(<code>stop-the-world</code>)</p><h1 id="代际假说（The-Generational-Hypothesis）"><a href="#代际假说（The-Generational-Hypothesis）" class="headerlink" title="代际假说（The Generational Hypothesis）"></a>代际假说（The Generational Hypothesis）</h1><p>代际假说是垃圾回收中的一个重要术语，他主要有两个特点：</p><ul><li>大部分对象在内存中的存活周期都很短暂。例如执行上下文</li><li>不死的对象，存活周期比较漫长。例如函数声明，全局对象</li></ul><h1 id="V8-回收器-Orinoco"><a href="#V8-回收器-Orinoco" class="headerlink" title="V8 回收器 Orinoco"></a>V8 回收器 Orinoco</h1><p>V8 回收器名叫 <code>Orinoco</code>。垃圾回收器在进行标记或回收行为时，会暂停 JS 主线程的执行。</p><p>任何垃圾回收器的基本任务：</p><ol><li>识别死&#x2F;活对象</li><li>回收&#x2F;重用死对象占用的内存</li><li>压缩碎片内存（可选）</li></ol><p><code>Orinoco</code>利用代际假说这一假设，<strong>大多数对象都会在新生代中死亡，只有少数对象能在新生代中存活下来，然后移动到老生代。</strong></p><p>所以，GC 复制算法得以在 V8 中被使用。</p><h1 id="V8-回收算法（GC-复制算法）"><a href="#V8-回收算法（GC-复制算法）" class="headerlink" title="V8 回收算法（GC 复制算法）"></a>V8 回收算法（GC 复制算法）</h1><p><strong>分代回收</strong><br>在<code>Orinoco</code>中，存在两个不同的 GC。Minor GC: 用于回收新生代的垃圾，Major: 用于回收老生代的垃圾。</p><p>对于存活周期漫长的对象，那他需要的空间肯定也比较大，对应的算法也就不同。</p><h2 id="新生代-Minor-GC"><a href="#新生代-Minor-GC" class="headerlink" title="新生代(Minor GC)"></a>新生代(Minor GC)</h2><h3 id="Scavenge（深度优先-存在递归问题）"><a href="#Scavenge（深度优先-存在递归问题）" class="headerlink" title="Scavenge（深度优先 存在递归问题）"></a>Scavenge（深度优先 存在递归问题）</h3><p>Scavenge 是典型的牺牲空间换时间的复制算法。</p><p>在<code>to-space</code>中，存在<code>$free</code>指针，用于指向当前对应空间可分配内存的起始地址。当我们从复制完一个对象后，<code>$free</code>会移动到新的起始位置。</p><p>具体步骤为以下 4 步：</p><ol><li>从 Root 引用开始查询，通过根搜索算法标记活动对象和非活动对象</li><li>复制<code>from-space</code>的活动对象到<code>to-space</code>中</li><li>清空<code>from-space</code></li><li><code>from-space</code>和<code>to-space</code>角色互换，以便下次回收</li></ol><p>第二步还有个细节，将某个活动对象复制到<code>to-space</code>后，会在<code>from-space</code>中将该对象标记为已复制，而不是马上清空该对象占用的空间。这是因为该对象可能被其他对象引用。</p><p>还有一点，在<code>from-space</code>中找到某个活动对象（B）后，如果该活动对象下还有别的活动对象（A），就会将 A 复制到<code>to-space</code>。这是一个<strong>递归</strong>过程。</p><p>递归的问题：</p><ol><li>持续占用栈内存，而且可能出现爆栈的情况</li><li>执行一个函数就会创建一个执行上下文，也会持续占用内存</li></ol><p>递归带来的负担不可忽视，V8 并没有完全采用<code>Scavenge</code>算法，之后引入了<code>cheney</code>算法，用迭代来解决该问题。</p><h3 id="cheney（广度优先-迭代）"><a href="#cheney（广度优先-迭代）" class="headerlink" title="cheney（广度优先 迭代）"></a>cheney（广度优先 迭代）</h3><p><code>cheney</code>算法引入了新的指针<code>$scan</code>，该指针用于标记<code>to-space</code>中，还没有被向下搜索过子对象的起始位置。</p><ol><li>从 Root 引用开始查询，通过根搜索算法标记活动对象和非活动对象</li><li>依次将活动对象复制到<code>to-space</code>中（不再进行递归查找）</li><li><code>$scan</code>指针不变，<code>$free</code>指针向右移动</li><li>Root 节点中没有找到别的引用后，我们从<code>to-space</code>（可以看做队列）头部开始搜索。<code>to-space</code>头部的对象成为了新的 Root 节点，<code>$scan</code>指针向右移动（出队）如果发现新节点存在引用，则复制进入队列。</li><li><code>$scan</code>指针依次向右移动，发现新对象就复制入队，直到<code>$scan</code>指针与<code>$free</code>指针重合，表示所有活动对象查询完毕。</li><li>剩下的就是清理空间然后互换。</li></ol><p>知识体系关联：与 Promise 的任务队列方式相似</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">PromiseJobs</span> = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入 job1</span></span><br><span class="line"><span class="title class_">PromiseJobs</span>.<span class="title function_">push</span>(job1);</span><br><span class="line"><span class="comment">// 加入 job2</span></span><br><span class="line"><span class="title class_">PromiseJobs</span>.<span class="title function_">push</span>(job2);</span><br><span class="line"></span><br><span class="line"><span class="title class_">PromiseJobs</span> = [job1, job2];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> job;</span><br><span class="line"><span class="comment">// 将先进入队列的 job 移除队列，并执行</span></span><br><span class="line"><span class="comment">// PromiseJobs 是处于动态变化的，所以只能用 while 来处理这种动态循环的场景。不能用 for 循环</span></span><br><span class="line"><span class="keyword">while</span> ((job = <span class="title class_">PromiseJobs</span>.<span class="title function_">shift</span>())) &#123;</span><br><span class="line">  <span class="title function_">job</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cheney 算法采用的是广度优先遍历，这就是迭代，这样把堆用做队列的方式，消除了 <code>scavenge</code>算法的递归风险。代价就是访问速度上，与<code>scavenge</code> 相比可能会稍微慢一点。</p><p>知识体系关联：队列优先级的算法，在 React Fiber 架构中也有用到。</p><h2 id="老生代-Major-GC"><a href="#老生代-Major-GC" class="headerlink" title="老生代(Major GC)"></a>老生代(Major GC)</h2><p><code>scavenge</code>算法为什么不合适老生代，因为</p><ul><li><code>scavenge</code>是复制算法，反复复制存活率高的对象没有意义</li><li><code>scavenge</code> 是以空间换时间的算法，老生代内存空间很大，所以空间资源非常浪费</li></ul><p>所以老生代使用了<code>mark-sweep(标记清理)</code>和<code>mark-Compact(标记清理整理)</code></p><h3 id="Mark-Sweep"><a href="#Mark-Sweep" class="headerlink" title="Mark-Sweep"></a>Mark-Sweep</h3><p><code>Mark-Sweep</code>算法分为两个阶段，标记和清理。标记依旧是通过根搜索算法。清理阶段与<code>scavenge</code>算法不同，<code>scavenge</code> 算法是复制后再清理，而<code>Mark-Sweep</code>是标记后直接清理。</p><h3 id="Mark-Compact"><a href="#Mark-Compact" class="headerlink" title="Mark-Compact"></a>Mark-Compact</h3><p><code>Mark-Compact</code>是为了解决<code>Mark-Sweep</code>算法带来的内存缝隙而提出的解决方案。</p><p>compact 主要做两件事：</p><ol><li>把活动对象移动到该去的位置</li><li>修改引用，让他们指向新的地址</li></ol><p>![Mark-Compact.png]<img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708326499231.png" alt="pic.1708326499231"></p><h2 id="全停顿-Stop-The-World"><a href="#全停顿-Stop-The-World" class="headerlink" title="全停顿(Stop-The-World)"></a>全停顿(Stop-The-World)</h2><p>JS 代码的运行需要用到 JS 引擎，垃圾回收也要用到 JS 引擎，如果这两者同时运行怎么办？答案是<strong>垃圾回收优于代码执行</strong>。代码会暂停执行，等待垃圾回收完毕再执行。这个过程称为<strong>全停顿</strong>。<br>但这样的代价就是页面明细卡顿，因此<code>Orinoco</code>还继续做了优化。</p><h1 id="Orinoco-进一步优化"><a href="#Orinoco-进一步优化" class="headerlink" title="Orinoco 进一步优化"></a>Orinoco 进一步优化</h1><h3 id="增量标记-惰性清理"><a href="#增量标记-惰性清理" class="headerlink" title="增量标记+惰性清理"></a>增量标记+惰性清理</h3><p>2011 年，V8 从早期的<code>stop-the-world</code> 切换到 <code>Incremental</code>增量标记 + <code>Lazy Sweeping</code>惰性清理的模式。</p><p>垃圾回收任务被拆分为多个小任务，然后在主线程空隙中执行这个小任务。</p><p>增量标记是针对<strong>标记</strong>阶段的优化。只有当垃圾达到一定数量是，增量标记就会开启：<code>标记一点，JS代码运行一段</code></p><p>惰性清理是针对<strong>清除</strong>阶段的优化。假如当前可用内存足以让代码快速执行，那就延迟清理，或清理部分垃圾。</p><p>结合浏览器的<code>requestIdleCallback</code>，增量标记与惰性清理的出现，使主线程的最大停顿时间减少了 80%。页面更流畅了。</p><p>但是也带来了问题，标记和代码执行的穿插，可能会造成<strong>对象引用改变、标记错误</strong>的现象。这就需要<strong>写屏障</strong>技术来记录这些引用关系的变化。</p><p>2018 年，V8 同时引入了并行与并发，让垃圾回收的时间进一步缩短。</p><h3 id="并行-Parallel"><a href="#并行-Parallel" class="headerlink" title="并行(Parallel)"></a>并行(Parallel)</h3><p>并行指的是主线程和辅助线程同时执行大致数量相等的清理任务。依旧采用<code>stop-the-world</code>的方式，但是将清理任务交给多个线程来执行。这是实现起来最简单的方案。<br>![多线程并行减少主线程等待时间.png]<img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708326507586.png" alt="pic.1708326507586"></p><h3 id="并发-Concurrent"><a href="#并发-Concurrent" class="headerlink" title="并发(Concurrent)"></a>并发(Concurrent)</h3><p>并发指的是在不暂停 JS 代码执行的同时，辅助线程在后台执行垃圾回收工作。除了<strong>需要写屏障</strong>技术，还可能会存在辅助线程与 JS 主线程同时读取或修改同一对象的问题，这就能能处理了。这是三种技术中实现起来最难的。<br>![并发执行(不暂停js的执行).png]<img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708326513601.png" alt="pic.1708326513601"></p><p><code>知识体系关联：React 18 的并发(Concurrent)</code></p><h1 id="V8-当前的垃圾回收机制"><a href="#V8-当前的垃圾回收机制" class="headerlink" title="V8 当前的垃圾回收机制"></a>V8 当前的垃圾回收机制</h1><p>在新生代中，使用并行机制。在将活动对象从<code>from-space</code>赋值到<code>to-space</code>时，启用多个辅助线程并行整理。由于多个线程可能会竞争同一个对象，因此第一个线程对该对象操作之后，都必须维护这个对象的转发地址，以便其他线程能够快速判断该对象是否已被复制。</p><p>新生代：<strong>并行方式+cheney 算法</strong></p><p>在老生代中，如果堆中的内存大小超过某个阈值，会启用并发标记任务。每个辅助线程都会去追踪每个标记到的对象的指针以及对这个对象的引用，JS 代码执行的之后，并发标记也在后台的辅助进程中进行，当堆中的某个对象被修改的时候，写入屏障技术会在辅助线程在进行并发标记时进行追踪。</p><p>并发标记完成后，辅助线程会进行内存整理，不影响 JS 代码的执行。</p><h1 id="从-V8-到实践"><a href="#从-V8-到实践" class="headerlink" title="从 V8 到实践"></a>从 V8 到实践</h1><p>了解 V8 垃圾回收的内部机制，可以帮助我们考虑内存使用。例如，从垃圾回收角度来看，存活周期漫长的对象维护成本会偏高。因为</p><ul><li>对于无效函数的声明就应该更严谨</li><li>使用 shaking 技术</li><li>减少闭包对象的大小（Redux 的 Provider 注入，Provider 只放少量必要的数据）</li></ul><p>参考：</p><ul><li><a href="https://xiaozhuanlan.com/advance/4158792360">https://xiaozhuanlan.com/advance/4158792360</a></li><li><a href="https://www.teqng.com/2021/09/01/13%E5%BC%A0%E5%9B%BE%EF%BC%8120%E5%88%86%E9%92%9F%EF%BC%81%E8%AE%A4%E8%AF%86v8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/#31_zeng_liang_biao_ji_Incremental_marking">https://www.teqng.com/2021/09/01/13%E5%BC%A0%E5%9B%BE%EF%BC%8120%E5%88%86%E9%92%9F%EF%BC%81%E8%AE%A4%E8%AF%86v8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/#31_zeng_liang_biao_ji_Incremental_marking</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>封装的理解</title>
      <link href="/2024/02/07/%E5%B0%81%E8%A3%85%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2024/02/07/%E5%B0%81%E8%A3%85%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近在学习 canvas 的使用，并写了个 demo，就是做一个 K 线图，支持提示、拖拽、缩放，也发布为 npm 包：<a href="https://www.npmjs.com/package/echarts-for-abc">echarts-for-abc</a><br>效果如图所示<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708325742371.png" alt="pic.1708325742371"><br>写代码过程中，封装是必不可少的一部分，所以想以这个为例子来讲一下封装。</p><h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>封装的目的，是为了减少代码量。</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>万物皆对象，对象具有属性和行为（方法），对象公共属性和行为的提取就是封装。</p><h1 id="理念"><a href="#理念" class="headerlink" title="理念"></a>理念</h1><p>封装的前提，必定跟场景相关联的，也就是说，先有场景，再有封装。<strong>封装前，先把场景下的属性具象化出来，再考虑提取他们的共性</strong>。如果跳过这一步直接思考他们的共性，这很容易出现思考偏差。</p><p>举个例子：一个学校里面，有老师、学生、校长等各角色，不同角色有自己的特点和行为，比如学生有学号，老师有职位等级、类型，他们也有共同的特性，比如拥有性别、年龄等特点，用类（class）来表示各个角色。</p><p>将学生和老师用代码抽象化表示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">studentNumber, sex, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">studentNumber</span> = studentNumber; <span class="comment">// 学号</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sex</span> = sex;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">rank, sex</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">rank</span> = rank; <span class="comment">// 等级</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sex</span> = sex;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现学生和老师都有性别和年龄，那就可以提取出来，所以可以很容易用<code>Person</code>封装起来，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">sex, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sex</span> = sex;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以使用<code>extends</code>让子类（学生）继承父类（Person）的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">studentNumber, sex, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(sex, age);</span><br><span class="line">    <span class="comment">// super() 表示执行父类构造函数，相当于Person.prototype.constructor.call(this), 用于继承父类Person的属性</span></span><br><span class="line">    <span class="comment">// 在这里，相当于this.sex = undefined; this.age = undefined</span></span><br><span class="line">    <span class="comment">// 传入sex,age 相当于 this.sex = sex; this.age = age;</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">studentNumber</span> = studentNumber;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> student1 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;330311221&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="number">15</span>);</span><br><span class="line"><span class="comment">// student1 = &#123; age: 15, sex: &quot;男&quot;, studentNumber: &quot;330311221&quot; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">rank, sex, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(sex, age);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">rank</span> = rank;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> teacher1 = <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;高级教师&quot;</span>, <span class="string">&quot;女&quot;</span>, <span class="number">35</span>);</span><br><span class="line"><span class="comment">// teacher1 = &#123; age: 35, sex: &quot;女&quot;, rank: &quot;高级教师&quot; &#125;</span></span><br></pre></td></tr></table></figure><h1 id="封装颗粒度"><a href="#封装颗粒度" class="headerlink" title="封装颗粒度"></a>封装颗粒度</h1><p>封装颗粒度表示函数的拆分程度，是否越细越好呢，其实不是。<br>在项目中，如果组件拆的过于细，可能会导致父组件的参数向子组件一层层传递时，会出现遗漏，传错等问题。如果拆的太粗，会导致难以复用、难以维护等问题，那么怎样的颗粒度大小才算合适呢？<strong>封装的颗粒度大小，取决于不同场景下的偏向性考虑。</strong></p><h1 id="考虑偏向性"><a href="#考虑偏向性" class="headerlink" title="考虑偏向性"></a>考虑偏向性</h1><p>封装偏向性可以分为两种，偏应用还是偏底层。</p><p>偏应用：这个封装只适用你这个特定的场景<br>偏底层：具有独立性，颗粒度更小，可以脱离特定场景，就像工具方法，如 Lodash 工具库</p><p><em>工具方法：是一个纯函数，传入参数，返回结果。也就是说不要在工具方法内部获取外部变量，要作为参数传入。</em></p><p>考虑哪种偏向性，取决于场景，所以进入“写一个 K 线图 demo”的场景，来聊一聊封装。</p><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><p>可以看到图中的蜡烛出现了 10 次，那么如何封装渲染蜡烛的这个函数呢？是封装单个蜡烛合适还是一串蜡烛合适？</p><p>如果作为单个蜡烛的出现，我们只需要知道蜡烛横坐标、蜡烛宽度、颜色以及四个点的纵坐标就能绘制出蜡烛，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绘制蜡烛</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; abscissa 蜡烛横坐标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; topPointY 最高点纵坐标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; bottomPointY 最低点纵坐标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; secondPointY 第二个点纵坐标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; thirdPointY 第三个点纵坐标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; candleW 蜡烛宽度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; candleColor 蜡烛颜色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">renderCandle</span>(<span class="params"></span></span><br><span class="line"><span class="params">  abscissa,</span></span><br><span class="line"><span class="params">  topPointY,</span></span><br><span class="line"><span class="params">  bottomPointY,</span></span><br><span class="line"><span class="params">  secondPointY,</span></span><br><span class="line"><span class="params">  thirdPointY,</span></span><br><span class="line"><span class="params">  candleW,</span></span><br><span class="line"><span class="params">  candleColor</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> halfCandleW = candleW / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绘制蜡烛上影线</span></span><br><span class="line">  ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">  ctx.<span class="title function_">moveTo</span>(abscissa, topPointY);</span><br><span class="line">  ctx.<span class="title function_">lineTo</span>(abscissa, secondPointY);</span><br><span class="line">  ctx.<span class="title function_">closePath</span>();</span><br><span class="line">  ctx.<span class="title function_">stroke</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绘制蜡烛下影线</span></span><br><span class="line">  ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">  ctx.<span class="title function_">moveTo</span>(abscissa, bottomPointY);</span><br><span class="line">  ctx.<span class="title function_">lineTo</span>(abscissa, thirdPointY);</span><br><span class="line">  ctx.<span class="title function_">closePath</span>();</span><br><span class="line">  ctx.<span class="title function_">stroke</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绘制蜡烛实体（中间矩形部分）</span></span><br><span class="line">  ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">  ctx.<span class="title function_">moveTo</span>(abscissa - halfCandleW, secondPointY);</span><br><span class="line">  ctx.<span class="title function_">rect</span>(</span><br><span class="line">    abscissa - halfCandleW,</span><br><span class="line">    secondPointY,</span><br><span class="line">    candleW,</span><br><span class="line">    thirdPointY - secondPointY</span><br><span class="line">  );</span><br><span class="line">  ctx.<span class="property">fillStyle</span> = candleColor;</span><br><span class="line">  ctx.<span class="title function_">fill</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">renderCandle</span>(<span class="number">50</span>, <span class="number">88</span>, <span class="number">50</span>, <span class="number">44</span>, <span class="number">33</span>, <span class="number">20</span>, <span class="string">&quot;red&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708325756628.png" alt="pic.1708325756628"><br>这个函数的封装偏向性就属于偏底层封装，它具有独立性，颗粒度更小，复用率更高，就像在 Echarts 图标库里，有多个应用到单个蜡烛的地方，就可以使用这个工具函数，你只需要传入相关参数即可。</p><p>但在我这个练习 demo 中，单个蜡烛并没有独立出现的场景，我考虑偏应用封装，而且在渲染蜡烛之前我需要处理数据源、判断涨跌以及蜡烛颜色的情况，所以将这些处理逻辑和绘制蜡烛封装为一个函数，不管在阅读还是使用上都更为方便，我的代码为:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绘制一串蜡烛</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">array</span>&#125; data 数据源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; candleW 蜡烛宽度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">renderCandles</span>(<span class="params">data, candleW</span>) &#123;</span><br><span class="line">  <span class="comment">// 将数据源转换为绘制蜡烛所需要的纵坐标集合</span></span><br><span class="line">  <span class="keyword">const</span> dataYAxisPoint = <span class="title function_">tranPriceToOrdinate</span>(data);</span><br><span class="line">  <span class="keyword">const</span> halfCandleW = candleW / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, candleLength = dataYAxisPoint.<span class="property">length</span>; i &lt; candleLength; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; heightPrice, lowPrice, openingPrice, closingPice &#125; =</span><br><span class="line">      dataYAxisPoint[i];</span><br><span class="line">    <span class="keyword">let</span> abscissa = <span class="title function_">xAxisTickPointX</span>(i),</span><br><span class="line">      topPointY = heightPrice,</span><br><span class="line">      bottomPointY = lowPrice,</span><br><span class="line">      secondPointY,</span><br><span class="line">      thirdPointY,</span><br><span class="line">      candleColor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (closingPice &lt; openingPrice) &#123;</span><br><span class="line">      <span class="comment">// 涨</span></span><br><span class="line">      candleColor = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">      secondPointY = closingPice;</span><br><span class="line">      thirdPointY = openingPrice;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      candleColor = <span class="string">&quot;green&quot;</span>;</span><br><span class="line">      secondPointY = openingPrice;</span><br><span class="line">      thirdPointY = closingPice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制蜡烛上影线</span></span><br><span class="line">    ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">    ctx.<span class="title function_">moveTo</span>(abscissa, topPointY);</span><br><span class="line">    ctx.<span class="title function_">lineTo</span>(abscissa, secondPointY);</span><br><span class="line">    ctx.<span class="title function_">closePath</span>();</span><br><span class="line">    ctx.<span class="title function_">stroke</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制蜡烛下影线</span></span><br><span class="line">    ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">    ctx.<span class="title function_">moveTo</span>(abscissa, bottomPointY);</span><br><span class="line">    ctx.<span class="title function_">lineTo</span>(abscissa, thirdPointY);</span><br><span class="line">    ctx.<span class="title function_">closePath</span>();</span><br><span class="line">    ctx.<span class="title function_">stroke</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制蜡烛实体（中间矩形部分）</span></span><br><span class="line">    ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">    ctx.<span class="title function_">moveTo</span>(abscissa - halfCandleW, secondPointY);</span><br><span class="line">    ctx.<span class="title function_">rect</span>(</span><br><span class="line">      abscissa - halfCandleW,</span><br><span class="line">      secondPointY,</span><br><span class="line">      candleW,</span><br><span class="line">      thirdPointY - secondPointY</span><br><span class="line">    );</span><br><span class="line">    ctx.<span class="property">fillStyle</span> = candleColor;</span><br><span class="line">    ctx.<span class="title function_">fill</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>封装的理念为：把场景下的属性和方法具象化，提取共性</li><li>封装的颗粒度大小，取决于不同场景下的偏向性考虑</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发环境和线上环境</title>
      <link href="/2024/02/07/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8C%E7%BA%BF%E4%B8%8A%E7%8E%AF%E5%A2%83/"/>
      <url>/2024/02/07/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8C%E7%BA%BF%E4%B8%8A%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<ul><li>开发环境：表示本地开发时的环境，便于开发人员调试。代码中可能会包含测试代码，调试工具等，这些东西没必要放到线上环境中</li><li>线上环境：追求快速化、最小化。包括测试、生产等非开发环境</li></ul><p>在 node.js 中约定了一个环境变量 <code>NODE_ENV</code>，用于环境区分。</p><p>未定义任何环境变量时，<code>production</code>表示线上环境，<code>development</code>表示开发环境。</p><blockquote><p>线上环境：<strong>线上环境不等于生产环境</strong>。在未定义其他环境时，线上环境表示生产环境；定义了其他环境（比如测试环境）时，线上环境表示除开发环境的其他环境。</p></blockquote><p>一般我们还会有一个测试环境，通常情况下都是把线上接口改为测试接口，但是这样容易出错。<br>为了避免手动修改接口，我们可以定义一个测试环境<code>test</code>。</p><h1 id="umi-环境变量配置"><a href="#umi-环境变量配置" class="headerlink" title="umi 环境变量配置"></a>umi 环境变量配置</h1><h2 id="UMI-ENV"><a href="#UMI-ENV" class="headerlink" title="UMI_ENV"></a>UMI_ENV</h2><p>当指定 UMI_ENV 时，会<strong>额外加载</strong>指定值的配置文件。参考: <a href="https://umijs.org/docs/guides/env-variables#umi_env">https://umijs.org/docs/guides/env-variables#umi_env</a></p><p>多了测试环境，这时候的<code>production</code>可能会包含<code>test</code>，所以我们再定义一个 online，用<code>online</code>表示生产。<br>:::info<br>注意：umi4.x 版本里，自定义变量时不能用 prod 表示生产环境，所以这里使用 online .<br>:::</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;umi dev&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;build:test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cross-env UMI_ENV=test umi build&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;build:online&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cross-env UMI_ENV=online umi build&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>打包时，除了加载<code>.umirc.tc</code>，还会额外加载<code>.umirc.$&#123;UMI_ENV&#125;.ts</code>文件。</p><h2 id="区分本地开发和线上"><a href="#区分本地开发和线上" class="headerlink" title="区分本地开发和线上"></a>区分本地开发和线上</h2><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isDev = process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&quot;development&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> notDev = process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&quot;production&quot;</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 项目场景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步解决方案</title>
      <link href="/2024/02/07/%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2024/02/07/%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h1><p>同步是指发起一个请求时，如果未得到请求结果，代码逻辑将会等待，直到结果出来才会继续执行之后的代码。</p><p>异步是指当发起一个请求时，不会等待请求结果，直接继续执行后面的代码。请求结果的处理逻辑，会添加一个监听，等到反馈结果出来后，在回调函数中处理对应的逻辑。</p><p>使用 Promise 模拟一个发起请求的函数，该函数在 1s 之后返回数值 30。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="number">30</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res)); <span class="comment">// 输出 30</span></span><br></pre></td></tr></table></figure><p>在该函数的基础上，我们可以使用 async&#x2F;await 来模拟同步的效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> res = <span class="keyword">await</span> <span class="title function_">fn</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;next code&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// 30</span></span><br><span class="line"><span class="comment">// next code</span></span><br></pre></td></tr></table></figure><p>而异步效果则会有不同的输出</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">fn</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;next code&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// next code</span></span><br><span class="line"><span class="comment">// 30</span></span><br></pre></td></tr></table></figure><h1 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h1><p>ajax 是网页与服务端进行数据交互的一种技术。<br>我们可以通过服务端提供的接口，利用 ajax 向服务端请求需要的数据</p><p>整个过程的简单实现如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&quot;http: www.demo.com/user/info&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">XHR</span> = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="variable constant_">XHR</span>.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, url, <span class="literal">true</span>);</span><br><span class="line"><span class="variable constant_">XHR</span>.<span class="title function_">send</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">XHR</span>.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable constant_">XHR</span>.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; <span class="variable constant_">XHR</span>.<span class="property">state</span> == <span class="number">200</span>) &#123;</span><br><span class="line">    result = <span class="variable constant_">XHP</span>.<span class="property">reponse</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这看起来没什么麻烦的，但是这时候，如果我们还需要做另一个 ajax 请求，这个请求的参数是从上一个 ajax 请求中获取的，那么我们就不得不如下这么做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&quot;http: www.demo.com/user/info&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">XHR</span> = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line"><span class="variable constant_">XHR</span>.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, url, <span class="literal">true</span>)</span><br><span class="line"><span class="variable constant_">XHR</span>.<span class="title function_">send</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">XHR</span>.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable constant_">XHR</span>.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; <span class="variable constant_">XHR</span>.<span class="property">state</span> == <span class="number">200</span>) &#123;</span><br><span class="line">    result = <span class="variable constant_">XHP</span>.<span class="property">reponse</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 伪代码2</span></span><br><span class="line">    <span class="keyword">var</span> url2 = <span class="string">&#x27;http:xxx.yyy.com/zzz?ddd=&#x27;</span> + result.<span class="property">someParams</span>;</span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">XHR2</span> = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    <span class="title class_">XHR2</span>.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, url, <span class="literal">true</span>);</span><br><span class="line">    <span class="title class_">XHR2</span>.<span class="title function_">send</span>();</span><br><span class="line">    <span class="title class_">XHR2</span>.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当出现第三个（甚至更多）仍然依赖上一个请求的时候，代码就变成了一场灾难。</p><p>我们需要不停的嵌套回调函数。这样的灾难，我们称之为 <strong>回调地狱。</strong></p><p>**Promise **可以帮助我们解决这个问题。</p><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>我们知道，如果要确保代码在谁之后执行，可以利用函数调用栈，将想要执行的代码放入回调函数中。<br>如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">want</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这是你想要执行的代码&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">want</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这里表示执行了一大堆其他代码&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其他代码执行完后，最后执行回调函数</span></span><br><span class="line">  want &amp;&amp; <span class="title function_">want</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>(want);</span><br></pre></td></tr></table></figure><p>或者可以利用任务队列</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">want</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这是你想要执行的代码&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">want</span>) &#123;</span><br><span class="line">  <span class="comment">// 根据事件循环的机制，我们就不用非得将代码放在最后面了，由你自由选择</span></span><br><span class="line">  want &amp;&amp; <span class="built_in">setTimeout</span>(want, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这里表示执行了一大堆其他代码&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>(want);</span><br></pre></td></tr></table></figure><p>与 setTimeout 类似， Promise 也可以认为是一种任务分发器，它将任务分发到 PromiseJobs 执行队列中。通常的用法是，我们发起一个请求，然后等待并处理请求结果。</p><p>简单用法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (tag) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Promise 是一个对象，保存着未来某一时刻才会执行的事件。</p><p>我们常使用 Promise 来解决反馈结果需要等待的场景。</p><p>例如</p><ul><li>前端向服务端发送一个接口请求。请求结果不会马上返回，而是需要等待一段时间。</li><li>加载图片，需要等待一段时间</li><li>弹窗中，等待用户点击确认或者取消</li></ul><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="创建-Promise-实例"><a href="#创建-Promise-实例" class="headerlink" title="创建 Promise 实例"></a>创建 Promise 实例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>();</span><br></pre></td></tr></table></figure><p>Promise 函数中的第一个参数为一个回调函数，我们可以称之为 <strong>executor</strong> 。通常情况下，在这个函数中，我们将会执行发起请求操作，并修改结果的状态值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="title function_">reject</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>状态有三种</p><ol><li>pending：等待结果状态</li><li>fulfilled：已出结果，结果符合预期完成状态</li><li>rejected：已出结果，结果未符合预期完成状态</li></ol><p>promise 表达的就是从发起请求开始，从没有结果 padding 到有结果 fulfilled&#x2F;rejected 的一个过程。</p><p>在 executor 函数中，我们可以分别使用 resolve 与 reject 将状态修改为对应的 fulfilled 与 rejected.</p><p>resolve&#x2F;reject 是 executor 函数的两个参数。他们能够将请求结果的具体数据传递出去。</p><ol><li>Promise 实例拥有 <code>then</code> 方法，用来处理请求结果变为 fulfilled 状态时的逻辑。<code>then</code>的第一个参数也是一个回调函数，该函数的参数则是 resolve 传递出来的数据。第二个参数用来处理 rejected 状态时的逻辑。</li><li>Promise 实例拥有 <code>catch</code>方法，用来处理请求结果变为 rejected 时的逻辑。<code>catch</code>的第一个参数也是一个回调函数，该函数的参数则是 reject 传递出来的数据。</li></ol><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>写个例子感受一下 Promise 的用法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">// 模拟一个请求，2s 后得到结果</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> num == <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(num);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> err = num + <span class="string">&quot; is not a number&quot;</span>;</span><br><span class="line">        <span class="title function_">reject</span>(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(resp);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意观察该语句的执行顺序</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;next code&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>then</code>方法可以接收两个参数，第一个参数用来接收 fulfilled 状态的逻辑，第二个参数用来处理 rejected 状态的逻辑。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fn</span>(<span class="string">&quot;abc&quot;</span>).<span class="title function_">then</span>(</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">resp</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(resp);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>因此 <code>catch</code> 方法其实与下面的写法等价。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fn</span>(<span class="string">&quot;abc&quot;</span>).<span class="title function_">then</span>(<span class="literal">null</span>, <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(er);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>then</code>方法返回的仍然是一个 Promise 实例对象，因此 then 方法可以链式调用，通过在内部 return 的方式，能够将数据持续往后传递。</p><h3 id="封装-ajax"><a href="#封装-ajax" class="headerlink" title="封装 ajax"></a>封装 ajax</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&quot;http://www.demo.com/user/info&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装一个get请求的方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getJSON</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">// 利用ajax发送一个请求</span></span><br><span class="line">    <span class="keyword">var</span> <span class="variable constant_">XHR</span> = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    <span class="variable constant_">XHR</span>.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, url, <span class="literal">true</span>);</span><br><span class="line">    <span class="variable constant_">XHR</span>.<span class="title function_">send</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待结果</span></span><br><span class="line">    <span class="variable constant_">XHR</span>.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable constant_">XHR</span>.<span class="property">readyState</span> == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable constant_">XHR</span>.<span class="property">status</span> == <span class="number">200</span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> response = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable constant_">XHR</span>.<span class="property">responseText</span>);</span><br><span class="line">            <span class="comment">//  得到正确的结果修改状态并将数据传递出去</span></span><br><span class="line">            <span class="title function_">resolve</span>(response);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 得到错误结果并抛出错误</span></span><br><span class="line">          <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable constant_">XHR</span>.<span class="property">statusText</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装好之后，使用就很简单了</span></span><br><span class="line"><span class="title function_">getJSON</span>(url).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(resp);</span><br><span class="line">  <span class="comment">// 之后就是处理数据的具体逻辑</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p>当有一个 ajax 请求，它的参数需要另外 2 个甚至更多请求都有了结果之后才能确定，那么这个时候，就需要 Promise.all 来帮助我们应该这个场景。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>Promise.all 接收一个由 Promise 对象组成的数组作为参数，当 Promise 对象状态都变成 fulfilled 的时候，才会去调用 then 方法。</p><p>如果其中一个 Promise 对象状态变成 rejected，那么 p 的状态就会变成 rejected，第一个被 reject 的实例的返回值会传递给回调函数。</p><p>如果作为参数的 Promise 实例，自己定义了 catch 方法，那么它一旦被 rejected，并不会触发 Promise.all() 的 catch() 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p5 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p6 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;报错了&quot;</span>);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p5, p6])</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// [&quot;hello&quot;, Error: 报错了]</span></span><br></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>与 Promise.all 相似的是，Promise.race 也是接收一个 Promise 对象组成的数组作为参数，不同的是，只要当数组中的一个 Promise 状态变为 fulfilled 或者 rejected 时，就可以调用 .then 方法了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>Promise.race 可以理解为 Promise 实例赛跑，哪个实例有了状态就返回哪个，通常用于处理规定时间内请求超时的情况。</p><p>如果 5 秒之内请求无法返回结果，变量 p 的状态就会变为 rejected，从而触发 catch 方法指定的回调函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 模拟请求，10秒后返回数据</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">10000</span>, <span class="string">&quot;my name is a&quot;</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理请求超时</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(reject, <span class="number">5000</span>, <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;超时了&quot;</span>));</span><br><span class="line">  &#125;),</span><br><span class="line">])</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err: &quot;</span>, err);</span><br><span class="line">    <span class="title function_">alert</span>(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>如何封装与使用息息相关。</p><h3 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h3><p>封装一个加载图片的函数，Promise 的使用如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">imageLoad</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">  img.<span class="property">src</span> = url;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    img.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">&quot;图片加载成功&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    img.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="string">&quot;图片加载失败&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们就可以使用 imageLoad 来执行图片加载完成之后的逻辑。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">imageLoad</span>(<span class="string">&quot;xxx.png&quot;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(res);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>封装的核心关键是： Promise 的最终目的是，为了执行 then 中的回调函数，我们称它为 <code>then_cb</code>。</p><p>所以在封装的时候，我们就应该思考如何在 Promise 内部，让 <code>then_cb</code>执行。</p><h3 id="简易版-MyPromise"><a href="#简易版-MyPromise" class="headerlink" title="简易版 MyPromise"></a>简易版 MyPromise</h3><p>显而易见，Promise 包含原型方法 then，构造函数需要传递回调函数 <code>executor</code>，该回调函数包含两个参数，resolve 与 reject 。</p><p>根据这些特点，我们得出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  construcotr (executor) &#123;</span><br><span class="line">    <span class="title function_">executor</span>(<span class="variable language_">this</span>.<span class="property">_resolve</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="variable language_">this</span>.<span class="property">_reject</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _resolve (value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  _reject () &#123;&#125;</span><br><span class="line"></span><br><span class="line">  then (then_cb) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>目的是为了调用 then_cb ，通过封装加载图片可以发现，调用 resolve 时，then_cb 才会执行，所以可以得出结论， <strong>then_cb 的执行需要被 resolve 触发</strong>。</p><p>我们可以通过保存 then_cb 引用的方式来解决。所以代码就变成了这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">thenCallback</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">executor</span>(<span class="variable language_">this</span>.<span class="property">_resolve</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="variable language_">this</span>.<span class="property">_reject</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">_resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">thenCallback</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">_reject</span>(<span class="params">value</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">then</span>(<span class="params">then_cb</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">thenCallback</span> = then_cb;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，再解决 catch 回调函数的执行问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">thenCallback</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">rejectCallback</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="title function_">executor</span>(<span class="variable language_">this</span>.<span class="property">_resolve</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="variable language_">this</span>.<span class="property">_reject</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">_resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">thenCallback</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">_reject</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">rejectCallback</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">then</span>(<span class="params">then_cb, onRejected</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">thenCallback</span> = then_cb;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">rejectCallback</span> = onRejected;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">null</span>, onRejected);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不追求别的特性，我们的 Promise 对象就已经封装好了，并且可以使用了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// resolve(&#x27;123&#x27;)</span></span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&quot;some err&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// p.then(res =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   console.log(res);</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">p.<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> [<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err&quot;</span>, err)]);</span><br></pre></td></tr></table></figure><p>再模拟将 then_cb 放入队列中执行，简单调整如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">thenCallback</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">rejectCallback</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="title function_">executor</span>(<span class="variable language_">this</span>.<span class="property">_resolve</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="variable language_">this</span>.<span class="property">_reject</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">_resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="comment">// this.thenCallback(value)</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">thenCallback</span>(value);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">_reject</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="comment">// this.rejectCallback(value)</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">rejectCallback</span>(value);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">then</span>(<span class="params">then_cb, onRejected</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">thenCallback</span> = then_cb;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">rejectCallback</span> = onRejected;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">null</span>, onRejected);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加入队列机制后，就可以在 executor 中直接执行 resolve ，否则会报错 <code>this.thenCallback is not a function</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Promise-all-1"><a href="#Promise-all-1" class="headerlink" title="Promise.all"></a>Promise.all</h3><p>Promise.all 返回的是一个数组，我们要将参数 array 内的每个 Promise 的执行结果放在一个数组 result 里，并且 result 数组成员的顺序要与传入时的 array 成员顺序保持一一对应。</p><p>实现 Promise.all 的重点在于对 all 参数内 Promise 实例全部执行完毕时机的判断。</p><p>因为 Promise 是异步的，我们不能保证 Promise 实例完成的时机与数组顺序一样。也就是说我们不能使用数组的 length 属性来表达 Promise 全都执行完毕。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">delay</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(data);</span><br><span class="line">    &#125;, <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">_all</span> = <span class="function">(<span class="params">array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = array.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">      array[i].<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        result[i] = data;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">// 因为 array[i] 的执行是异步的，所以这种判断是错误的</span></span><br><span class="line">        <span class="comment">// 如果 i===2 的 promise 先执行完毕,result[2] 导致 result.length === 3</span></span><br><span class="line">        <span class="keyword">if</span> (result.<span class="property">length</span> === array.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, reject);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="title function_">delay</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="title function_">delay</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="title function_">delay</span>(<span class="number">3</span>);</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">_all</span>([<span class="title function_">delay</span>(<span class="number">2</span>), <span class="title function_">delay</span>(<span class="number">1</span>), <span class="title function_">delay</span>(<span class="number">3</span>)]).<span class="title function_">then</span>(</span><br><span class="line">  <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res: &quot;</span>, res); <span class="comment">// [2, 1, 3]</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err: &quot;</span>, err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面的代码，如果最后一个 Promise 先执行完毕，赋值时 <code>result[2] = data</code>，那么 <code>result.length</code>等于 3， 满足 <code>result.length === array.length</code>的判断条件，就会提前执行 resolve 。</p><p>所以，我们可以参考垃圾回收机制的引用计数法，在内部添加一个计数变量 count 来判断是否所有 Promise 都已执行完毕。当 count 等于传入的 Promise 数组长度时，表示所有 Promise 都有了结果，然后我们再执行 resolve 将结果传递出去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property">_all</span> = <span class="function">(<span class="params">array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = array.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">      array[i].<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        result[i] = data;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">// 因为array[i]的执行是异步的，所以这种判断是错误的</span></span><br><span class="line">        <span class="comment">// 如果i===2的promise先执行完毕,result[2]导致result.length === 3</span></span><br><span class="line">        <span class="comment">// if (result.length === array.length) &#123;</span></span><br><span class="line">        <span class="comment">//   resolve(result)</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">if</span> (count === array.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, reject);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="async-await"><a href="#async-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h1><p>异步问题除了使用 Promise 来解决之外，还可以使用 ES7 中新增的语法 async&#x2F;await 来搞定。</p><p>在函数声明前面，加上关键字 <code>async</code>，这就是 async 的具体使用了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">30</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后我们查看一下 fn 的运行结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// result</span></span><br><span class="line"><span class="title class_">Promise</span> = &#123;</span><br><span class="line">  <span class="attr">__proto__</span>: <span class="title class_">Promise</span>,</span><br><span class="line">  [[<span class="title class_">PromiseStatus</span>]]: <span class="string">&quot;resolved&quot;</span>,</span><br><span class="line">  [[<span class="title class_">PromiseValue</span>]]: <span class="number">30</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>发现 fn 函数运行返回的是一个标准的 Promise 对象。也就是说 async 其实就是 Promise 的一个语法糖，目的是为了让写法更加简单。于是，我们可以使用 Promise 的相关语法来处理后续的逻辑</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fn</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// 30</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>await</strong> 含义为等待，意思就是需要等待 await 后面函数运行完了，并且有了返回结果，才能继续执行下面的代码。这正是同步的效果。</p><p>需要注意的是，await 关键字只能在 async 函数中使用。并且 await 后面的函数运行后必须返回一个 Promise 对象才能实现同步的效果。</p><p>当我们使用一个变量去接收 await 的返回值时，该返回值为 Promise 中 resolve 传递出来的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="number">30</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> t = <span class="keyword">await</span> <span class="title function_">fn</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;t&quot;</span>, t);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;next code&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// t: 30</span></span><br><span class="line"><span class="comment">// next code</span></span><br></pre></td></tr></table></figure><p>从例子中我们可以看出，在 async 函数中，遇到 await 时，就会等待 await 后面的函数运行完毕，而不会直接执行 next code。</p><p>如果我们直接使用 then 方法，就不得不把后续的逻辑写在 then 方法中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fn</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">t</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;t: &quot;</span>, t);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;next doce&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure><p>很明显，如果使用 async&#x2F;await 的话，代码会更简洁，逻辑也更清晰。</p><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><ul><li>在 Promise 中，我们使用 .catch 方法来捕获错误</li><li>而使用 async 时，我们使用 try&#x2F;catch 来捕获错误<ul><li>如果有多个 await ，只会捕获到第一个错误<br>:::info<br>tyr&#x2F;catch 除了可以捕获使用 async 时 Promise 抛出的错误，还可以捕获 throw 关键字抛出的错误。<br>:::</li></ul></li></ul><p><strong>在 Promise 中，我们使用 .catch 方法来捕获错误</strong>，而不是使用 .then 的第二个参数。因为：</p><ol><li>更接近同步的语法（try&#x2F;catch）</li><li>then 中的错误也会被 catch 捕获</li></ol><p>使用 then 的第二个参数，并不能捕获到第一个参数内部抛出的错误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">123</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p3.<span class="title function_">then</span>(</span><br><span class="line">  <span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;is err&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;error&quot;</span>, error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// 123</span></span><br><span class="line"><span class="comment">// Uncaught (in promise) Error: is err</span></span><br></pre></td></tr></table></figure><p>使用 catch ，则可以捕获到上一个 then 内部抛出的错误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">123</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p3.<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;is err&quot;</span>);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;error&quot;</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// 123</span></span><br><span class="line"><span class="comment">// error Error: is err</span></span><br></pre></td></tr></table></figure><p><strong>而使用 async 时，我们使用 try&#x2F;catch 来捕获错误。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="string">&quot;some error&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">fn</span>();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;e: &quot;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure><p>如果有多个 await ，只会捕获到第一个错误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="string">&quot;some error fn1&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="string">&quot;some error fn2&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">fn1</span>();</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">fn2</span>();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;e: &quot;</span>, e); <span class="comment">// some error fn1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure><h1 id="Generator-函数"><a href="#Generator-函数" class="headerlink" title="Generator 函数"></a>Generator 函数</h1><p>Generator 函数可以认为是异步任务的容器。异步操作需要暂停的地方，都用 yield 语句注明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>(<span class="number">1</span>);</span><br><span class="line">g.<span class="title function_">next</span>(); <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>(); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>Generator 函数名前要加*号，调用 Generator 函数，会返回一个指针对象（即遍历器）。调用指针对象的 next 方法，会移动内布指针，指向第一个遇到的 yield 语句。</p><p>也就是说，next 的作用是分段执行 Generator 函数。每次调用 next 方法，都会返回一个对象，表示当前阶段的信息。</p><p>value 属性是 yield 语句后面表达式的值，done 属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。</p><h2 id="错误处理-1"><a href="#错误处理-1" class="headerlink" title="错误处理"></a>错误处理</h2><p>使用 try catch 捕获函数体外抛出的错误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params">x</span>)&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>(<span class="number">1</span>);</span><br><span class="line">g.<span class="title function_">next</span>();</span><br><span class="line">g.<span class="property">throw</span>（<span class="string">&#x27;出错了&#x27;</span>）;</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><h1 id="async"><a href="#async" class="headerlink" title="async"></a>async</h1><p>从 Promise 对象，再到 Generator，异步解决方案每次都有所改进，很多人认为 async 函数是异步操作的终极解决方案。<br><strong>async 函数就是 Generator 函数的语法糖。</strong><br>async 函数就是将 Generator 函数的*号替换成 async，将 yield 替换成 await。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&quot;/etc/fstab&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&quot;/etc/shells&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> asyncReadFile = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">await</span> <span class="title function_">readFile</span>(<span class="string">&quot;/etc/fstab&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">await</span> <span class="title function_">readFile</span>(<span class="string">&quot;/etc/shells&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>async 函数对 Generator 函数的改进，体现在一下三点：</p><ol><li>内置执行器。Generator 函数的执行必须依靠执行器。</li><li>更好的语义。async 和 await，比起星号和 yield，语义更清楚。</li><li>更广的适用性。await 命令后面可以跟 Promise 对象和原始类型的值（数值、字符串、布尔值），Generator 函数只能是 thunk 函数或 Promise 对象。</li></ol><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信网页分享「自定义标题、描述和图片」</title>
      <link href="/2024/02/07/%E5%BE%AE%E4%BF%A1%E7%BD%91%E9%A1%B5%E5%88%86%E4%BA%AB%E3%80%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E9%A2%98%E3%80%81%E6%8F%8F%E8%BF%B0%E5%92%8C%E5%9B%BE%E7%89%87%E3%80%8D/"/>
      <url>/2024/02/07/%E5%BE%AE%E4%BF%A1%E7%BD%91%E9%A1%B5%E5%88%86%E4%BA%AB%E3%80%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E9%A2%98%E3%80%81%E6%8F%8F%E8%BF%B0%E5%92%8C%E5%9B%BE%E7%89%87%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>记录一下通过微信网页分享时，需要自定义标题、描述和图片的功能。参考 <a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html#1">JSSDJ 使用步骤</a> 。</p><h1 id="步骤解读"><a href="#步骤解读" class="headerlink" title="步骤解读"></a>步骤解读</h1><p>步骤一：JS 接口安全域名，指的是后端 API 接口域名。</p><p>步骤二：使用<code>ES MODULE</code>加载<code>微信 JS SDK</code>文件。<br><code>pnpm i weixin-js-sdk</code></p><p>步骤三：注入权限验证配置</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wx.<span class="title function_">config</span>(&#123;</span><br><span class="line">  <span class="attr">debug</span>: <span class="literal">true</span>, <span class="comment">// 开启调试模式,调用的所有 api 的返回值会在客户端 alert 出来，若要查看传入的参数，可以在 pc 端打开，参数信息会通过 log 打出，仅在 pc 端时才会打印。</span></span><br><span class="line">  <span class="attr">appId</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 必填，公众号的唯一标识</span></span><br><span class="line">  <span class="attr">timestamp</span>: , <span class="comment">// 必填，生成签名的时间戳</span></span><br><span class="line">  <span class="attr">nonceStr</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 必填，生成签名的随机串</span></span><br><span class="line">  <span class="attr">signature</span>: <span class="string">&#x27;&#x27;</span>,<span class="comment">// 必填，签名</span></span><br><span class="line">  <span class="attr">jsApiList</span>: [] <span class="comment">// 必填，需要使用的 JS 接口列表</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>jsApiList</code>指的是<strong>微信 JS 提供的接口</strong>，如“分享给朋友”接口<code>updateAppMessageShareData</code>。<br><code>timestamp</code>、<code>nonceStr</code>、<code>signature</code>三个签名信息，让后端参考<a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html#62">使用签名算法</a> 将其返回给前端即可。<br>后端需要做的是：</p><ol><li>获取<code>access_token</code></li><li>通过<code>access_token</code>获取<code>jsapi_ticket</code>，并为<code>jsapi_ticket</code>做缓存处理</li><li>返回签名信息：签名、生产签名的时间戳和随机串</li></ol><p>步骤四：<br>获取签名信息是异步的，并且如果页面加载时就调用<strong>微信 JS 提供的接口，</strong>需将<strong>微信 JS 提供的接口</strong>放在<code>wx.ready()</code>中调用。</p><p>步骤五：<br>通过 wx 对象的通用参数来验证<strong>微信 JS 提供的接口</strong>是否调用成功，如<code>success</code>参数</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wx.<span class="title function_">updateAppMessageShareData</span>(&#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&quot;分享标题&quot;</span>,</span><br><span class="line">  <span class="attr">desc</span>: <span class="string">&quot;分享描述&quot;</span>,</span><br><span class="line">  <span class="attr">imgUrl</span>: <span class="string">&quot;分享图片链接&quot;</span>,</span><br><span class="line">  <span class="attr">link</span>: <span class="string">&quot;分享页面链接&quot;</span>,</span><br><span class="line">  <span class="attr">success</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;updateAppMessageShareData接口调用成功&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="封装和使用"><a href="#封装和使用" class="headerlink" title="封装和使用"></a>封装和使用</h1><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hooks/useWXShare.tsx</span></span><br><span class="line"><span class="keyword">import</span> wx <span class="keyword">from</span> <span class="string">&quot;weixin-js-sdk&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">&quot;@/api&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> urlMap <span class="keyword">from</span> <span class="string">&quot;@/api/url-map&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; weChat &#125; = urlMap;</span><br><span class="line"><span class="keyword">const</span> appId = <span class="string">&quot;xxxxxxxxxxxxx&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ShareData</span> &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">  desc?: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">link</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">imgUrl</span>: <span class="built_in">string</span>;</span><br><span class="line">  success?: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 微信网页分享</span></span><br><span class="line"><span class="comment">// 注意，通过 ready 接口处理成功验证</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">useWXShare</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 自定义“分享给朋友”及“分享到QQ”按钮的分享内容</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">updateAppMessageShareData</span> = (<span class="params">props: ShareData</span>) =&gt; &#123;</span><br><span class="line">    wx.<span class="title function_">updateAppMessageShareData</span>(props);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自定义“分享到朋友圈”及“分享到QQ空间”按钮的分享内容</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">updateTimelineShareData</span> = (<span class="params">props: ShareData</span>) =&gt; &#123;</span><br><span class="line">    wx.<span class="title function_">updateTimelineShareData</span>(props);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">getSign</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    request</span><br><span class="line">      .<span class="title function_">post</span>(weChat.<span class="property">sign</span>, &#123;</span><br><span class="line">        <span class="attr">url</span>: location.<span class="property">href</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; timestamp, nonceStr, signature &#125; = res.<span class="property">data</span>;</span><br><span class="line">        <span class="comment">// 签名需要后端返回</span></span><br><span class="line">        wx.<span class="title function_">config</span>(&#123;</span><br><span class="line">          <span class="comment">// debug: true, // 开启调试模式,调用的所有 api 的返回值会在客户端 alert 出来，若要查看传入的参数，可以在 pc 端打开，参数信息会通过 log 打出，仅在 pc 端时才会打印。</span></span><br><span class="line">          appId, <span class="comment">// 必填，公众号的唯一标识</span></span><br><span class="line">          timestamp, <span class="comment">// 必填，生成签名的时间戳</span></span><br><span class="line">          nonceStr, <span class="comment">// 必填，生成签名的随机串</span></span><br><span class="line">          signature, <span class="comment">// 必填，签名</span></span><br><span class="line">          <span class="attr">jsApiList</span>: [<span class="string">&quot;updateTimelineShareData&quot;</span>, <span class="string">&quot;updateAppMessageShareData&quot;</span>], <span class="comment">// 必填，需要使用的 JS 接口列表</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    wx,</span><br><span class="line">    updateAppMessageShareData,</span><br><span class="line">    updateTimelineShareData,</span><br><span class="line">    getSign,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useWXShare;</span><br></pre></td></tr></table></figure><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useWXShare &#125; <span class="keyword">from</span> <span class="string">&#x27;@/hooks&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; wx, getSign, updateAppMessageShareData, updateTimelineShareData &#125; = <span class="title function_">useWXShare</span>();</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">getSign</span>();</span><br><span class="line"></span><br><span class="line">    <span class="title function_">onLoading</span>();</span><br><span class="line">    request</span><br><span class="line">      .<span class="title function_">get</span>(home.<span class="property">articlesDetail</span>, &#123; uri &#125;)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; title, description &#125; = res.<span class="property">data</span>;</span><br><span class="line">        <span class="title function_">offLoading</span>();</span><br><span class="line"></span><br><span class="line">        wx.<span class="title function_">ready</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">updateAppMessageShareData</span>(&#123;</span><br><span class="line">            title,</span><br><span class="line">            <span class="attr">desc</span>: description,</span><br><span class="line">            <span class="attr">imgUrl</span>: <span class="string">&#x27;https:xx.jpeg&#x27;</span>,</span><br><span class="line">            <span class="attr">link</span>: detailLink,</span><br><span class="line">          &#125;);</span><br><span class="line">          <span class="title function_">updateTimelineShareData</span>(&#123;</span><br><span class="line">            title,</span><br><span class="line">            <span class="attr">imgUrl</span>: <span class="string">&#x27;https:xx.jpeg&#x27;</span>,</span><br><span class="line">            <span class="attr">link</span>: detailLink,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="title function_">offLoading</span>());</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span>微信网页分享<span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">  )</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure><p>微信网页分享朋友圈无法显示图片？<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708334234054.png" alt="pic.1708334234054"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 项目场景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件篇</title>
      <link href="/2024/02/07/%E6%96%87%E4%BB%B6%E7%AF%87/"/>
      <url>/2024/02/07/%E6%96%87%E4%BB%B6%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>文件上传和下载是很常见的功能，今天就来梳理一下操作文件过程中常见的概念和 api，加深对文件的理解。</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="Blob-对象"><a href="#Blob-对象" class="headerlink" title="Blob 对象"></a>Blob 对象</h2><p>当用户通过一个<code>input</code>元素选择文件时，浏览器会创建一个<code>Blob</code>对象代表该文件的二进制数据。如果要在将文件数据上传到服务器或者存储到本地之前对其进行操作，你可能需要使用 <code>Blob</code>对象 。</p><p>举个例子，你可以使用<code>URL.createObjectURL</code>方法创建一个<code>URL</code>代表这个<code>Blob</code>对象，然后用这个<code>URL</code>在<code>&lt;img&gt;</code>或<code>video</code>元素中展示这个文件。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">img.<span class="property">src</span> = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(file);</span><br></pre></td></tr></table></figure><h2 id="File-对象"><a href="#File-对象" class="headerlink" title="File 对象"></a>File 对象</h2><p>当用户通过一个<code>input</code>元素选择文件时，浏览器会创建一个基于<code>Blob</code>对象的<code>File</code>对象，并添加文件名<code>name</code>、大小<code>size</code>、上次修改日期<code>lastModifiedData</code>等属性。如果要在将文件上传到服务器之前验证文件的属性，则可能需要使用<code>File</code>对象。</p><p>:::info<br>也就是说，File 对象是一种 Blob 对象，他包含了文件的附加信息，如 name、size、lastModifiedDate 等属性。开发人员无法直接访问底层的 Blob 对象，而是通过 api 与 File 对象进行交互。<br>:::</p><h2 id="base-64"><a href="#base-64" class="headerlink" title="base 64"></a>base 64</h2><p>base64 编码将二进制数据表示为一串 ASCII 字符「我们常说的字符串」。<br>有些场合并不能传输或者储存二进制流，这时候就需要使用 base64 编码。</p><p>比如，一个传输协议是基于 ASCII 文本的，那么他就不能传输二进制流，想要传输该二进制流就得编码。常用的 http 协议的 url 就是纯文本的，不能直接放二进制流。<br>大多数现代语言的 String 类型，都不能直接存储二进制流，但可以储存 base64 编码的字符串。</p><p>举个例子，你可以使用<code>FileReader.readAsDataURL()</code>方法读取 File 对象的内容并将其转换为 base64 编码的 data:URL 格式的字符串，简称<code>DataURL</code>。<br>这个 DataURL 表示所读取的文件内容，可以将其发送到服务器。然后服务器可以将 DataURL 解码回<code>二进制数据</code>并将其保存为文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * file 转 base64编码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">File</span>&#125; file 文件流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">base64Callback</span>&#125; callback 回调函数 - 处理响应</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">fileByBase64</span> = (<span class="params">file, callback</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">var</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// onload事件在读取操作完成时触发</span></span><br><span class="line">  reader.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="comment">// e.target.result/reader.target 该属性表示目标对象的DataURL</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">target</span>.<span class="property">result</span>);</span><br><span class="line">    callback &amp;&amp; <span class="title function_">callback</span>(e.<span class="property">target</span>.<span class="property">result</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以 data:URL 的形式读取数据</span></span><br><span class="line">  reader.<span class="title function_">readAsDataURL</span>(file);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="简单的文件上传"><a href="#简单的文件上传" class="headerlink" title="简单的文件上传"></a>简单的文件上传</h1><p>文件上传的传统形式，是使用<code>type=&#39;file&#39;</code>的<code>input</code>表单元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;file-input&quot;</span> <span class="attr">accept</span>=<span class="string">&quot;.jpg, .jpeg, .png&quot;</span> <span class="attr">multiple</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>可以添加<code>change</code>事件监听读取文件对象列表<code>event.target.files</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fileInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;file-input&quot;</span>);</span><br><span class="line">fileInput.<span class="title function_">addEventListener</span>(<span class="string">&quot;change&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> files = e.<span class="property">target</span>.<span class="property">files</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>File 对象:<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708334253215.png" alt="pic.1708334253215"></p><p>文件上传前，可以通过<code>File</code>对象，验证文件大小、类型等信息，决定是否进行下一步，比如验证文件大小。</p><h1 id="验证文件大小"><a href="#验证文件大小" class="headerlink" title="验证文件大小"></a>验证文件大小</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;file-input&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;upload-btn&quot;</span>&gt;</span>Upload File<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fileInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;file-input&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> uploadBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;upload-btn&quot;</span>);</span><br><span class="line"></span><br><span class="line">uploadBtn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> selectedFile = fileInput.<span class="property">files</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> fileSizeLimit = <span class="number">5</span> * <span class="number">1024</span>; <span class="comment">// 5KB in bytes</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (selectedFile.<span class="property">size</span> &gt; fileSizeLimit) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(</span><br><span class="line">      <span class="string">&quot;Selected file exceeds the size limit of 5 KB. Please select a smaller file.&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If file size is within the limit, proceed with file upload</span></span><br><span class="line">  <span class="comment">// Your code for uploading the file to the server goes here</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">获取 files 的方式：</span><br><span class="line"></span><br><span class="line">- 在 input 元素的 change 事件中，可通过 e.<span class="property">target</span>.<span class="property">files</span> 获取；</span><br><span class="line">- 或者通过 input 元素直接获取，如：<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;file-input&#x27;</span>).<span class="property">files</span>;</span><br><span class="line"></span><br><span class="line">也就是说<span class="string">`e.target === fileEl`</span></span><br></pre></td></tr></table></figure><h1 id="显示读取进度（下载文件的场景）"><a href="#显示读取进度（下载文件的场景）" class="headerlink" title="显示读取进度（下载文件的场景）"></a>显示读取进度（下载文件的场景）</h1><p><strong>FileReader.onprogress</strong><br><code>pregress</code>事件，在读取<code>Blob</code>时触发。在下载文件并显示进度这个场景下能够派上用场。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;file-input&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">id</span>=<span class="string">&quot;progress-label&quot;</span> <span class="attr">for</span>=<span class="string">&quot;progress&quot;</span>&gt;</span>Upload File<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">progress</span> <span class="attr">id</span>=<span class="string">&quot;progress&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span> <span class="attr">max</span>=<span class="string">&quot;100&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">progress</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;read-blob&quot;</span>&gt;</span>读取Blob<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>readAsDataURL</code>能够读取<code>Blob</code>对象，然后监听<code>FileReader</code>的<code>progress</code>事件，通过<code>ProgressEvent.loaded</code>和<code>ProgressEvent.total</code>计算读取的进度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fileInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;file-input&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> readBlobBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;read-blob&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示文件读取进度</span></span><br><span class="line"><span class="keyword">const</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line"></span><br><span class="line">reader.<span class="title function_">addEventListener</span>(<span class="string">&quot;progress&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.<span class="property">loaded</span> &amp;&amp; e.<span class="property">total</span>) &#123;</span><br><span class="line">    <span class="comment">// 计算完成百分比</span></span><br><span class="line">    <span class="keyword">const</span> percent = (e.<span class="property">loaded</span> / e.<span class="property">total</span>) * <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 将值设置为进度组件</span></span><br><span class="line">    progress.<span class="property">value</span> = percent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">readBlobBtn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> selectedFile = fileInput.<span class="property">files</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// 以 URL 格式的字符串的形式读取数据</span></span><br><span class="line">  reader.<span class="title function_">readAsDataURL</span>(selectedFile);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="显示上传进度"><a href="#显示上传进度" class="headerlink" title="显示上传进度"></a>显示上传进度</h1><p>要显示文件的上传进度，可以使用 JavaScript 中的 XMLHttpRequest (XHR) 对象将文件上传到服务器并使用 <code>XMLHttpRequest.upload.onprogress</code> 事件跟踪进度。这是一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fileInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;file-input&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> uploadBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;upload-btn&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> uploadProgress = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;upload-progress&quot;</span>);</span><br><span class="line"></span><br><span class="line">uploadBtn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> selectedFile = fileInput.<span class="property">files</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">  xhr.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;/upload&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Track the upload progress</span></span><br><span class="line">  xhr.<span class="property">upload</span>.<span class="property">onprogress</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> progress = (event.<span class="property">loaded</span> / event.<span class="property">total</span>) * <span class="number">100</span>;</span><br><span class="line">    uploadProgress.<span class="property">value</span> = progress;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  xhr.<span class="property">onload</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;File uploaded successfully&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  xhr.<span class="property">onerror</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;File upload failed&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">  formData.<span class="title function_">append</span>(<span class="string">&quot;file&quot;</span>, selectedFile);</span><br><span class="line"></span><br><span class="line">  xhr.<span class="title function_">send</span>(formData);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="上传目录"><a href="#上传目录" class="headerlink" title="上传目录"></a>上传目录</h1><p><code>input</code>元素的<code>webkitdirectory</code>属性，表示允许用户选择文件目录，而不是文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;file-input&quot;</span> <span class="attr">webkitdirectory</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>选择目录时，该目录下的文件会全部选中（包括子孙文件）。</p><h1 id="拖放上传"><a href="#拖放上传" class="headerlink" title="拖放上传"></a>拖放上传</h1><p>设置一个放置文件的目标元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;drop-zone&quot;</span>&gt;</span>Drop files here<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>调用 <code>event.preventDefault()</code>，这使它能够接收 drop 事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dropZone = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;drop-zone&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// dragover 事件在可拖动元素被拖进放置目标时被触发</span></span><br><span class="line">dropZone.<span class="title function_">addEventListener</span>(<span class="string">&quot;dragover&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  event.<span class="title function_">preventDefault</span>();</span><br><span class="line">  dropZone.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&quot;drag-over&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// dragleave 事件在可拖动元素离开放置目标时被触发</span></span><br><span class="line">dropZone.<span class="title function_">addEventListener</span>(<span class="string">&quot;dragleave&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  event.<span class="title function_">preventDefault</span>();</span><br><span class="line">  dropZone.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&quot;drag-over&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// drop 事件在可拖动元素放置在放置目标时被触发</span></span><br><span class="line">dropZone.<span class="title function_">addEventListener</span>(<span class="string">&quot;drop&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  event.<span class="title function_">preventDefault</span>();</span><br><span class="line">  dropZone.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&quot;drag-over&quot;</span>);</span><br><span class="line">  <span class="comment">// 获取文件</span></span><br><span class="line">  <span class="keyword">const</span> files = event.<span class="property">dataTransfer</span>.<span class="property">files</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;files: &quot;</span>, files);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">  xhr.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;/upload&quot;</span>);</span><br><span class="line"></span><br><span class="line">  xhr.<span class="property">onload</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;File uploaded successfully&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  xhr.<span class="property">onerror</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;File upload failed&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">  formData.<span class="title function_">append</span>(<span class="string">&quot;file&quot;</span>, files[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  xhr.<span class="title function_">send</span>(formData);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="Content-Type（表单的-enctype-属性）"><a href="#Content-Type（表单的-enctype-属性）" class="headerlink" title="Content-Type（表单的 enctype 属性）"></a>Content-Type（表单的 enctype 属性）</h1><p>当 method 属性值为 post 时，enctype 就是将表单的内容提交给服务器的数据编码类型。可能的取值有：</p><ul><li>application&#x2F;x-www-form-urlencoded：未指定属性时的默认值。</li><li>multipart&#x2F;form-data：<strong>当表单包含 type&#x3D;file input 元素时使用此值</strong>。</li><li>text&#x2F;plain：出现于 HTML5，用于调试。这个值可被 <code>&lt;button&gt;</code>、<code>&lt;input type=&quot;submit&quot;&gt;</code> 或 <code>&lt;input type=&quot;image&quot;&gt;</code> 元素上的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/button#formenctype">formenctype</a> 属性覆盖。</li></ul><h2 id="application-x-www-form-urlencoded"><a href="#application-x-www-form-urlencoded" class="headerlink" title="application&#x2F;x-www-form-urlencoded"></a>application&#x2F;x-www-form-urlencoded</h2><p>这种数据编码类型只支持传输文本数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST http://www.example.com HTTP/1.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded;charset=utf-8</span><br><span class="line"></span><br><span class="line">title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3</span><br></pre></td></tr></table></figure><p>首先，<code>Content-Type</code> 被指定为 <code>application/x-www-form-urlencoded</code>；其次，提交的数据按照 <code>key1=val1&amp;key2=val2</code> 的方式进行编码，<code>key</code> 和 <code>val</code> 都进行了 URL 转码。大部分服务端语言都对这种方式有很好的支持。</p><p>此类型不适合用于传输大型二进制数据或者包含非 ASCII 字符的数据。平常我们使用这个类型都是把表单数据使用 url 编码后传送给后端，二进制文件当然没办法一起编码进去了。所以 multipart&#x2F;form-data 就诞生了。</p><h2 id="multipart-form-data"><a href="#multipart-form-data" class="headerlink" title="multipart&#x2F;form-data"></a>multipart&#x2F;form-data</h2><p>为了支持文件上传，表单数据必须使用<code>multipart/form-data</code>内容类型进行编码。这种编码格式允许二进制数据作为请求主体的一部分发送。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST http://www.example.com HTTP/1.1</span><br><span class="line">Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class="line">Content-Disposition: form-data; name=&quot;text&quot;</span><br><span class="line"></span><br><span class="line">title</span><br><span class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot;</span><br><span class="line">Content-Type: image/png</span><br><span class="line"></span><br><span class="line">PNG ... content of chrome.png ...</span><br><span class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA--</span><br></pre></td></tr></table></figure><p><code>Content-Type</code>被指定为<code>multipart/form-data</code>，<code>boundary</code>为<code>----WebKitFormBoundaryrGKCBY7qhFd3TrwA</code>。<code>boundary</code>用于分割提交的数据。<br><code>Content-Disposition</code>包含文件的基本信息，<code>Content-Type</code>表示文件内容类型。<br>第一部分是一个名为<code>text</code>的表单字段，该字段的内容是字符串<code>title</code>。第二部分是名为<code>file</code>的字段，文件名为<code>chrome.png</code>，文件内容类型为<code>image/png</code>，内容为<code>PNG ... content of chrome.png ...</code>，然后以<code>boundary</code>为结尾。</p><h1 id="FormData"><a href="#FormData" class="headerlink" title="FormData()"></a>FormData()</h1><p>这是一个传统的最简单的 form 表单上传如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> <span class="attr">value</span>=<span class="string">&quot;请选择文件&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>FormData 的由来：</strong><br>当使用 Ajax 上传文件时，如果不指定<code>enctype=&quot;multipart/form-data&quot;</code>，会导致后端在解析 Form 表单的数据格式时与 Ajax 上传的数据格式不一致的问题。为了后端能够使用相同的代码解析这两种提交方式，所以出现了<code>FormData</code>。</p><p>FormData 接口提供了一种表示表单数据的键值对<code>key/value</code>的构造方式，可以轻松的将数据通过 Ajax 发送出去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单文件</span></span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&quot;files&quot;</span>, file);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多文件</span></span><br><span class="line">_files.<span class="title function_">forEach</span>(<span class="function">(<span class="params">file</span>) =&gt;</span> &#123;</span><br><span class="line">  formData.<span class="title function_">append</span>(<span class="string">&quot;files&quot;</span>, file);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用 FormData 上传文件时，无需手动设置<code>Content-Type=&#39;multipart/form-data&#39;</code>，FormData 会自动设置正确的 Content-Type 和 数据类型。</p><p>实际开发过程中也是如此，通常会使用 FormData 格式保存文件，关于<code>Content-Type</code>需要什么类型，取决于后端是怎么设计的。</p><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><h2 id="window-open"><a href="#window-open" class="headerlink" title="window.open"></a>window.open</h2><p><code>open()</code>方法，用于将指定的资源加载到浏览器新的窗口或者标签页。<br>当我们指定一个图片链接时，浏览器会自动下载该资源，下载后自动关闭该窗口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> imgUrl =</span><br><span class="line">  <span class="string">&quot;https://nd-news-mangement.oss-cn-hangzhou.aliyuncs.com/2023/04/274a8263e05f37a5d8663193b86e1a0583.png&quot;</span>;</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">open</span>(imgUrl);</span><br></pre></td></tr></table></figure><h2 id="location-href"><a href="#location-href" class="headerlink" title="location.href"></a>location.href</h2><p><code>location.href</code>表示将当前页面的 URL 设置为一个新的值。它是一个字符串，包含当前页面的完成 URL，包括协议、域名、路径、查询参数和片段标识符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> imgUrl =</span><br><span class="line">  <span class="string">&quot;https://nd-news-mangement.oss-cn-hangzhou.aliyuncs.com/2023/04/274a8263e05f37a5d8663193b86e1a0583.png&quot;</span>;</span><br><span class="line">location.<span class="property">href</span> = imgUrl;</span><br></pre></td></tr></table></figure><p><code>window.open</code>和<code>location.href</code>的区别：</p><ul><li><code>window.open</code>会打开一个新窗口或选项卡，而<code>location.href</code>会替换当前页</li><li><code>window.open</code> 打开太多新窗口可能会对用户体验产生负面影响</li><li><code>location.href</code>可能会刷新整个页面（但如果在输入框中输入了文本，加载新页面时文本内容不会丢失，这是因为浏览器通常将表单数据保存在浏览器的缓存中）</li></ul><h2 id="a-标签"><a href="#a-标签" class="headerlink" title="a 标签"></a>a 标签</h2><p>a 标签通常用于用户启动的交互，而<code>location.href</code>通常用于响应用户事件。<br>a 标签的方式属性更多，如<code>download</code>、<code>target</code>，也更为灵活，在实际开发过程中，我们通常会使用 a 标签封装一个下载功能的函数来使用，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">downloadFile</span>(<span class="params">url, fileName</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> link = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  link.<span class="property">href</span> = url;</span><br><span class="line">  link.<span class="property">target</span> = <span class="string">&quot;_blank&quot;</span>;</span><br><span class="line">  <span class="comment">// download仅适用于同源 URL</span></span><br><span class="line">  link.<span class="property">download</span> = fileName;</span><br><span class="line">  link.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(link);</span><br><span class="line">  link.<span class="title function_">click</span>();</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(link);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>File 对象是基于 Blob 对象的，只不过多了一些附加信息，如 <code>name</code>、<code>size</code>等</li><li>想要显示文件读取进度时，我们可以通过 FileReader 的 readAsDataURL(file) 方法，然后监听<code>FileReader</code>的<code>progress</code>事件</li><li>想要显示上传到服务器的进度时，可以通过<code>xhr.upload.onprogress</code>事件</li><li>使用 FormData 上传文件时，无需手动设置<code>Content-Type=&#39;multipart/form-data&#39;</code>，FormData 会自动设置正确的 Content-Type 和 数据类型</li></ul><p>实际项目应用中，大多数的表单场景都是手动上传文件到服务器，也就是说在提交到服务器之前，我们是不需要使用后端接口的。但现实中遇到的情况往往是后端提供一个上传接口，再提供一个提交表单数据的接口，前一个接口就显得很多余，而且存在数据库内存被乱用的风险。</p><p>参考：</p><ul><li><a href="https://juejin.cn/post/7224402365452238906#heading-11">https://juejin.cn/post/7224402365452238906#heading-11</a></li><li><a href="https://blog.csdn.net/WuLex/article/details/118771912">https://blog.csdn.net/WuLex/article/details/118771912</a></li><li><a href="https://juejin.cn/post/6940547458069954596">https://juejin.cn/post/6940547458069954596</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 项目场景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>封装的理解</title>
      <link href="/2024/02/07/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
      <url>/2024/02/07/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>构造函数用于初始化实例对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="attr">run</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;调用此方法张三就开始奔跑&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;李四&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">22</span>,</span><br><span class="line">  <span class="attr">run</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;调用此方法李四就开始奔跑&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p3 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;王五&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">21</span>,</span><br><span class="line">  <span class="attr">run</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;调用此方法王五就开始奔跑&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种场景很常见，每个对象都有<code>name</code>、<code>age</code>属性和<code>run</code>方法，我们可以用一个函数封装一下。</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p><strong>封装的目的是为了减少重复代码的编写。</strong></p><p>提取共性，将不同点作为参数传入。可以如下封装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">CreatePerson</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">run</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`调用此方法<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>就会开始奔跑`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">CreatePerson</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">CreatePerson</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">30</span>);</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">CreatePerson</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">40</span>);</span><br><span class="line">p1.<span class="title function_">run</span>();</span><br><span class="line">p2.<span class="title function_">run</span>();</span><br><span class="line">p3.<span class="title function_">run</span>();</span><br></pre></td></tr></table></figure><p>这种方式有个问题，就是每次使用 CreatePerson 函数创建对象时，run 方法被反复创建了多次。同样的内容，占据了多份内存空间。</p><p><strong>原型对象</strong><br><strong>属于所有实例共享的属性和方法，抽离出来放在原型对象中，而每个实例特有的属性和方法，都会留在构造函数中</strong>。<br>例如，每一个实例的名字，名字是每个实例特有的，不可能被共享。</p><p>将 run 方法挂载到原型对象上，这样就可以实现一次创建，被多个实例对象共同使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">CreatePerson</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  <span class="comment">// this.run = function () &#123;</span></span><br><span class="line">  <span class="comment">//   console.log(`调用此方法$&#123;this.name&#125;就会开始奔跑`)</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">CreatePerson</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">run</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`调用此方法<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>就会开始奔跑`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">CreatePerson</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">CreatePerson</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">30</span>);</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">CreatePerson</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">40</span>);</span><br><span class="line">p1.<span class="title function_">run</span>();</span><br><span class="line">p2.<span class="title function_">run</span>();</span><br><span class="line">p3.<span class="title function_">run</span>();</span><br></pre></td></tr></table></figure><h1 id="new-关键字都干了什么？"><a href="#new-关键字都干了什么？" class="headerlink" title="new 关键字都干了什么？"></a>new 关键字都干了什么？</h1><ol><li>创建一个新对象，该对象为最终返回的实例</li><li>将新对象的原型对象指向构造函数的原型对象</li><li>将构造函数内部的 this 指向这个新对象，即为实例</li><li>如果构造函数明确返回了对象或函数，那么这个返回值取代第一部的新对象</li></ol><p>实现一个 new</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myNew</span>(<span class="params">Fn, ...args</span>) &#123;</span><br><span class="line">  <span class="comment">// 1.创建一个新对象，该对象为最终返回的实例</span></span><br><span class="line">  <span class="keyword">let</span> res = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.将新对象的原型执行构造函数的原型</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// res.__proto__ = Fn.prototype</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(res, <span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.将构造函数的 this 指向新对象</span></span><br><span class="line">  ret = <span class="title class_">Fn</span>.<span class="title function_">apply</span>(res, args);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.如果函数返回了对象或者函数，那么这个返回值取代第一部创建的新对象</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">typeof</span> ret === <span class="string">&quot;Object&quot;</span> || <span class="keyword">typeof</span> ret === <span class="string">&quot;function&quot;</span>) &amp;&amp; ret !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="title function_">myNew</span>(<span class="title class_">CreatePerson</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="title function_">myNew</span>(<span class="title class_">CreatePerson</span>, <span class="string">&quot;李四&quot;</span>, <span class="number">30</span>);</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="title function_">myNew</span>(<span class="title class_">CreatePerson</span>, <span class="string">&quot;王五&quot;</span>, <span class="number">40</span>);</span><br><span class="line">p1.<span class="title function_">run</span>();</span><br><span class="line">p2.<span class="title function_">run</span>();</span><br><span class="line">p3.<span class="title function_">run</span>();</span><br></pre></td></tr></table></figure><p>小结：构造函数的返回值为基本类型，其返回值是实例化后的对象。构造函数的返回值为引用类型，其返回值即为 new 之后的返回值。</p><p><strong>构造函数和原型对象的访问优先级</strong><br>如果在构造函数和原型对象中，同时声明了属性&#x2F;方法，那么会优先访问构造函数中的属性&#x2F;方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">CreatePerson</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">run</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`构造函数中的：调用此方法<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>就会开始奔跑`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">CreatePerson</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">run</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`调用此方法<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>就会开始奔跑`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">CreatePerson</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">CreatePerson</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">30</span>);</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">CreatePerson</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">40</span>);</span><br><span class="line">p1.<span class="title function_">run</span>(); <span class="comment">// 构造函数中的：调用此方法张三就会开始奔跑</span></span><br><span class="line">p2.<span class="title function_">run</span>(); <span class="comment">// 构造函数中的：调用此方法李四就会开始奔跑</span></span><br><span class="line">p3.<span class="title function_">run</span>();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>柯里化</title>
      <link href="/2024/02/07/%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
      <url>/2024/02/07/%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p><strong>定义：柯里化是这么一个函数，他接收一个函数 A 为参数，运行后能够返回一个新函数，这个新函数能够处理函数 A 的剩余参数。</strong></p><p>配合例子理解这个定义</p><p>假如有个一接收三个参数的函数 A</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时还要一个封装好的柯里化通用函数 createCurry 。他接收 A 为参数，能够将 A 转化为柯里化函数，返回结果就是这个转化之后的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _A = <span class="title function_">createCurry</span>(A);</span><br></pre></td></tr></table></figure><p>那么 _A 作为 createCurry 运行的返回函数，他能够处理 A 的剩余参数。因此下面的执行结果是等价的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">_A</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="title function_">_A</span>(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>);</span><br><span class="line"><span class="title function_">_A</span>(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="title function_">_A</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>);</span><br><span class="line"><span class="title function_">A</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>_A 能够处理 A 的所有剩余参数。因为柯里化也可以被称为部分求值。</p><p>在简单的场景下，可以不借用柯里化通用式得到柯里化函数，比如一个简单的加法函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_add</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">c</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> a + b + c;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="title function_">_add</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>柯里化的实现思路：<br>柯里化函数的运行过程其实是一个参数的收集过程，每次将传入的参数收集起来，在最里层处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arity 用于标记剩余参数的个数</span></span><br><span class="line"><span class="comment">// args 用于收集参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createCurry</span>(<span class="params">func, arity, args</span>) &#123;</span><br><span class="line">  <span class="comment">// 第一次执行，剩余参数为函数的参数各位</span></span><br><span class="line">  <span class="keyword">var</span> arity = arity || func.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第一次执行，args 为空</span></span><br><span class="line">  <span class="keyword">var</span> args = args || [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义一个函数</span></span><br><span class="line">  <span class="keyword">var</span> wrapper = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 将wrapper中的参数收集到args中</span></span><br><span class="line">    <span class="keyword">var</span> _args = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">    [].<span class="property">push</span>.<span class="title function_">apply</span>(args, _args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果收集到的参数小于最初的func.length，则递归调用，继续收集参数</span></span><br><span class="line">    <span class="keyword">if</span> (_args.<span class="property">length</span> &lt; arity) &#123;</span><br><span class="line">      arity -= _args.<span class="property">length</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">createCurry</span>(func, arity, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数收集完毕，则执行func</span></span><br><span class="line">    <span class="keyword">return</span> func.<span class="title function_">apply</span>(func, args);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回这个函数</span></span><br><span class="line">  <span class="keyword">return</span> wrapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>柯里化确实把简单的问题复杂化了，但复杂化的同时，我们在使用函数时拥有了更多的自由度。也就是说，<strong>柯里化的核心，就是对于函数参数的自由处理。</strong></p><p>举一个非常常见的例子</p><p>验证一串数字是否是正确的手机号，按照普通的思路，可能如下封装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">checkPhone</span>(<span class="params">phoneNumber</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="regexp">/^1[34578]\d&#123;9&#125;&amp;/</span>.<span class="title function_">test</span>(phoneNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要验证一个邮箱，可能如下封装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">checkEmail</span>(<span class="params">email</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="regexp">/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/</span>.<span class="title function_">test</span>(email);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，可能还有更多的封装逻辑，因此在实践中，<strong>为了统一逻辑，我们会封装一个更为通用的函数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">check</span>(<span class="params">reg, targetString</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> reg.<span class="title function_">test</span>(targetString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样封装之后，在使用时又会稍微麻烦一点，因为总是输入一串正则，这样就导致使用效率低下，并且容易出错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">check</span>(<span class="regexp">/^1[34578]\d&#123;9&#125;$/</span>, <span class="string">&quot;14900000088&quot;</span>);</span><br><span class="line"><span class="title function_">check</span>(<span class="regexp">/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/</span>, <span class="string">&quot;test@163.com&quot;</span>);</span><br></pre></td></tr></table></figure><p>那么这个时候，我们可以借助柯里化，在 check 的基础上，再做一层封装，以简化使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _check = <span class="title function_">createCurry</span>(check);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> checkPhone = <span class="title function_">_check</span>(<span class="regexp">/^1[34578]\d&#123;9&#125;$/</span>);</span><br><span class="line"><span class="keyword">var</span> checkEmail = <span class="title function_">_check</span>(<span class="regexp">/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/</span>);</span><br></pre></td></tr></table></figure><p>最后在使用的时候就会变得更加直观与简洁了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">checkPhone</span>(<span class="string">&quot;183888888&quot;</span>);</span><br><span class="line"><span class="title function_">checkEmail</span>(<span class="string">&quot;xxxxx@test.com&quot;</span>);</span><br></pre></td></tr></table></figure><p>通过这个例子可以发现，柯里化能够应付更加复杂的逻辑封装。</p><p>虽然柯里化确实在一定程度上将问题复杂化了，也让代码更加不容易理解。但是柯里化在面对复杂情况下的灵活性却让我们不得不爱。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模块化的理解</title>
      <link href="/2024/02/07/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2024/02/07/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708326768564.png" alt="pic.1708326768564"></p><h1 id="什么是模块化"><a href="#什么是模块化" class="headerlink" title="什么是模块化"></a>什么是模块化</h1><p>模块化，就是把一个大的问题，化解为小的问题在这种思维下提炼出来的工程化解决方案。</p><h1 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h1><p>核心思想就是隔离。要有自己的内部属性，内部方法，以及自己来决定哪些属性与方法能够被其他模块访问。</p><h1 id="模块的设计目的是什么？"><a href="#模块的设计目的是什么？" class="headerlink" title="模块的设计目的是什么？"></a>模块的设计目的是什么？</h1><p>有了模块，我们可以更方便的使用别人的代码，想要什么功能，就加载什么模块。</p><h1 id="什么是-js-模块？"><a href="#什么是-js-模块？" class="headerlink" title="什么是 js 模块？"></a>什么是 js 模块？</h1><p>在 es6 之前，JavaScript 没有官方规范，主要采用 CommonJS 和 AMD 这两种规范。</p><h1 id="无模块化"><a href="#无模块化" class="headerlink" title="无模块化"></a>无模块化</h1><p>函数 -&gt; 命名空间 -&gt; 立即执行函数</p><h1 id="CommonJS-规范"><a href="#CommonJS-规范" class="headerlink" title="CommonJS 规范"></a>CommonJS 规范</h1><p>nodeJS 采用的就是 CommonJS 规范，运行在 nodeJS 中的规范。</p><p>CommonJS 的加载方式称为运行时加载，以下代码的实质是加载整个<code>fs</code>对象，再从<code>fs</code>对象上读取这三个方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS模块</span></span><br><span class="line"><span class="keyword">let</span> &#123; stat, exists, readfile &#125; = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> _fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> stat = _fs.<span class="property">stat</span>;</span><br><span class="line"><span class="keyword">let</span> exists = _fs.<span class="property">exists</span>;</span><br><span class="line"><span class="keyword">let</span> readfile = _fs.<span class="property">readfile</span>;</span><br></pre></td></tr></table></figure><h2 id="require"><a href="#require" class="headerlink" title="require()"></a>require()</h2><p>在 node 源码中有一个 module.js 文件，这个文件实现了 node 的整个模块加载系统。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Module</span>(<span class="params">id, parent</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = id;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">exports</span> = &#123;&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">parent</span> = parent;</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>我们在 nodeJS 中使用的 require()方法调用的就是 module.require 方法。具体可参考 <a href="https://developer.aliyun.com/article/113478">Node.js 模块加载机制 Require()</a></p><p><strong><em>注意：node 中使用的</em></strong><code>**_require()_**</code><strong><em>和 RequireJS 是两个东西。</em></strong></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>主要有 module、exports、require。</p><h3 id="导出：module"><a href="#导出：module" class="headerlink" title="导出：module"></a>导出：<strong>module</strong></h3><p>module.exports 由 Module 对象创建。如果我们想导出一个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a-common.js(导出)</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123; <span class="attr">foo</span>: <span class="string">&quot;bar&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">或者;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">foo</span> = <span class="string">&quot;bar&quot;</span>;</span><br></pre></td></tr></table></figure><p>exports 是 module.exports 的一个引用，所以我们可以使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✅</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">foo</span> = <span class="string">&quot;bar&quot;</span>;</span><br></pre></td></tr></table></figure><p>错误使用，这相当于重新定义了 exports</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❎</span></span><br><span class="line"><span class="built_in">exports</span> = &#123;&#125;;</span><br></pre></td></tr></table></figure><h3 id="导入：require"><a href="#导入：require" class="headerlink" title="导入：require"></a>导入：require</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="built_in">require</span>(<span class="string">&quot;./a-common.js&quot;</span>);</span><br><span class="line"></span><br><span class="line">使用;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o.<span class="property">foo</span>);</span><br></pre></td></tr></table></figure><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点：<br>解决了依赖、全局变量污染的问题</p><p>缺点：<br>因为 nodeJS 是运行在服务端，服务端所有的模块是放在本地的，模块的加载速度就是硬盘的读取速度，是同步的。但是浏览器的模块是放在服务器端，如果一个模块过大，浏览器会处于一种假死状态。</p><p>因此，浏览器端的模块不能采用”同步加载”，只能采用”异步加载”。所以 AMD 规范诞生了。</p><h1 id="AMD-规范"><a href="#AMD-规范" class="headerlink" title="AMD 规范"></a>AMD 规范</h1><p>AMD 是”Asynchronous Module Definition”的缩写，意思是”异步模块定义“。模块的加载不影响后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等模块加载完毕，回调函数才会执行。<br>define 和 require 就是 require.js 在全局注入的函数。</p><p>AMD 规范主要由 <a href="https://requirejs.org/">require.js</a> 和 <a href="https://github.com/cujojs/curl">curl.js</a> 这两个 JavaScript 库实现。<br>在网页中嵌入 require.js，就可以进行模块化编程了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script data-main=<span class="string">&quot;scripts/main&quot;</span> src=<span class="string">&quot;scripts/require.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="定义模块"><a href="#定义模块" class="headerlink" title="定义模块"></a>定义模块</h2><p>使用 define 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">define</span>(<span class="string">&quot;A&quot;</span>, [<span class="string">&quot;require&quot;</span>, <span class="string">&quot;exports&quot;</span>], <span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span></span>) &#123;</span><br><span class="line">  <span class="built_in">exports</span>.<span class="property">fun</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">require</span>(<span class="string">&quot;B&quot;</span>).<span class="property">fun</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h2><p>AMD 也是采用 require()语句加载模块，<code>require([module], callback)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">&quot;math&quot;</span>], <span class="keyword">function</span> (<span class="params">math</span>) &#123;</span><br><span class="line">  math.<span class="title function_">add</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>注意，不要与 NodeJS 中的 require()混淆。CommonJS 中的 require 是 NodeJS 源代码 module.js 文件中定义的方法，AMD 中的 require()是由 RequireJs 实现的。</strong></p><h1 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h1><p>CMD，全称 Common Module Definition，它整合了 CommonJS 和 AMD 规范的特点。<br>主要区别为一下两点：</p><ol><li>CMD 可以同步加载模块，也可以异步加载，而 AMD 需要异步加载模块</li><li>CMD 遵循依赖就近原则，而 AMD 遵循依赖前置原则。也就是说 CMD 在使用模块前，引入模块即可，而 AMD 需要把所有的依赖提前放在依赖数组中。</li></ol><h1 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h1><p>umd，全称 Universal Module Definition，它允许在环境中同时使用 AMD 规范和 CommonJS 规范。</p><h1 id="ES-Module"><a href="#ES-Module" class="headerlink" title="ES Module"></a>ES Module</h1><p>module 可完全取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的解决方案。<br>ES Module 的设计思想是静态化，也就是说在编译时就确定了模块的依赖关系，而 CommonJS 和 AMD 是在运行时确定，这是 EM 模块和其他模块最显著的差别；第二个差别是 ES6 模块输出的是值的引用，而 CommonJS 输出的是值的拷贝。</p><p>ES6 模块的加载方式称为“编译时加载”，在编译时就完成了加载，效率要比 CommonJS 和 AMD 的“运行时加载”效率高。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; stat, exists, readFile &#125; <span class="keyword">from</span> <span class="string">&quot;fs&quot;</span>;</span><br></pre></td></tr></table></figure><p>以上代码只会从<code>fs</code>中加载这 3 个方法，其他方法不会加载。</p><h2 id="引入模块"><a href="#引入模块" class="headerlink" title="引入模块"></a>引入模块</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;my name is test.js&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> test <span class="keyword">from</span> <span class="string">&quot;./test&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;test: &quot;</span>, test);</span><br></pre></td></tr></table></figure><ul><li>import 表示引入一个模块</li><li>test 可理解为要引入模块的名字</li><li>from 表示从哪里引入</li><li>‘.&#x2F;test’ 为 ‘.&#x2F;test.js’ 的简写，表示将要引入的模块的路径</li></ul><p>引入这个模块的同时，<code>&#39;./test&#39;</code>里的代码也执行了。因为 test.js 没有对外暴露接口，所以 test 为空对象。<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708326785878.png" alt="pic.1708326785878"></p><h2 id="对外提供接口"><a href="#对外提供接口" class="headerlink" title="对外提供接口"></a>对外提供接口</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;my name is test.js&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fn&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name,</span><br><span class="line">  obj,</span><br><span class="line">  arr,</span><br><span class="line">  fn,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用 <code>export default</code> 对外暴露一个对象。当使用<code>import test from &#39;./test&#39;</code>时，test 就是这个暴露的对象<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708326805238.png" alt="pic.1708326805238"></p><p>我们还可以仅通过 export 暴露几个方法和属性，在 test 中添加以下代码，看看 index.js 中的 test 会发生什么变化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">bar</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果发现 test 并没有什么变化，因为它仅仅等于<code>export defaule</code>所暴露的对象</p><p>如果想要获取 test.js 对外暴露的所有接口，可通过如下模式获取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> test <span class="keyword">from</span> <span class="string">&quot;./test&quot;</span>;</span><br></pre></td></tr></table></figure><p><code>*</code>号表示所有，是比较常用的通配符，as 表示别名。<code>* as test</code> 表示将 test.js 对外暴露的所有接口组成的对象，命名为 test。<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708326814698.png" alt="pic.1708326814698"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> test, &#123; age, bar &#125; <span class="keyword">from</span> <span class="string">&quot;./test&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等于以下写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> test <span class="keyword">from</span> <span class="string">&quot;./test&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> allTest <span class="keyword">from</span> <span class="string">&quot;./test&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> &#123; age, bar &#125; = allTest;</span><br></pre></td></tr></table></figure><p>这种写法非常常见，test 仍表示为<code>export default</code> 所暴露的对象，<code>&#123; age, bar &#125;</code> 表示<strong>用解构的语法从返回的整个对象中取对应的接口</strong>。结果显而易见<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708326822951.png" alt="pic.1708326822951"></p><p>在 react，这种使用方法很常见，我们能根据导入语法，就知道 react 内部是如何封装接口的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; lazy &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应的导出</span></span><br><span class="line">expoet <span class="keyword">default</span> &#123;</span><br><span class="line"><span class="attr">lazy</span>: <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有另一种写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> <span class="title class_">RightMain</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./right-main&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// import RightMain from &#x27;./right-main&#x27;;</span></span><br><span class="line"><span class="comment">// export &#123;</span></span><br><span class="line"><span class="comment">//   RightMain</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>参考：<br><a href="https://developer.aliyun.com/article/113478">https://developer.aliyun.com/article/113478</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器如何渲染页面</title>
      <link href="/2024/02/07/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2/"/>
      <url>/2024/02/07/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<p><strong>在地址栏输入 url 后发生了什么？</strong></p><p>用一张图描述一下：<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708326672310.png" alt="pic.1708326672310"></p><ol><li>输入域名</li><li>DNS：域名解析，得到 ip 地址</li><li>建立 TCP 连接</li><li>客户端发起请求</li><li>服务端处理请求，返回数据</li><li>断开 TCP 连接</li><li>浏览器拿到请求结果，解析 HTML，渲染页面</li></ol><p>优化方案里，和日常开发息息相关的是最后的流程，<strong>浏览器解析 html，渲染页面。</strong>本文主要介绍这一块内容。</p><p><strong>网页进程：</strong>浏览器网页的渲染和 JS 执行在一个单独的进程中执行。这个进程也称为<strong>render 进程</strong>。每启动一个页面，都会启动一个 render 进程。</p><p>说到网页进程，又引入了线程的概念。</p><p>如果说进程是一个工厂，那线程就是工厂中的流水线。一个工厂的正常运行，往往需要多个流水线通力合作才能完成。在网页进程中也是一样，想要网页进程能正常渲染运行，也需要多个线程参与合作。</p><p>网页的渲染运行，有如下线程参与</p><h3 id="GUI-渲染线程"><a href="#GUI-渲染线程" class="headerlink" title="GUI 渲染线程"></a>GUI 渲染线程</h3><p>GUI(Graphical User Interface)表示图形用户界面的意思，render tree 的渲染。用一张图看一下渲染路径</p><h4 id="渲染路径"><a href="#渲染路径" class="headerlink" title="渲染路径"></a>渲染路径</h4><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708326684005.png" alt="pic.1708326684005"></p><p>后端返回的 html 文件其内容是个字符串，<code>&lt;html&gt;、&lt;style&gt;</code>等标签是语法糖，HTML Parser 或 CSS Parser 表示对应的解析器，解析器的工作就是将这些字符串语法糖转换为对象。</p><p>加载：表示『资源文件发起请求-&gt;服务器返回结果』这一过程<br>解析：表示词法分析，先加载，后解析<br>渲染：将节点信息绘制到页面的过程</p><p>html 的解析过程，是自上而下的，解析过程中，如果发现了样式文件(link 标签)，就会加载样式文件。<strong>样式文件的加载并不会阻塞 html 的解析，阻塞的是 render tree 的渲染。</strong></p><p>HTML 会解析出 DOM（Document Object Model）树，样式文件会解析出 CSSOM(CSS Object Model)树，在 Attachment 环节，GUI 线程将 DOM 树与 CSSOM 树合并在一起，生成渲染树(render tree)，并将渲染树绘制到页面。</p><p><strong>为什么样式文件的加载会阻塞 render tree 的渲染？</strong></p><p>如果不会阻塞，页面会先出现没有样式的 DOM 结构，等 CSSOM 树生成后，需要重新计算 Render Tree，这会造成没必要的损耗。</p><p>用代码证明 css 的阻塞现象：<br>我们先把下载速度设置为 20kbit&#x2F;s<br>开发者工具-&gt; Network -&gt; No throttling -&gt; 添加一个 20kbit&#x2F;s，再观察结果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>css阻塞<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-tag">h1</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>: red <span class="meta">!important</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">function</span> <span class="title function_">h</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 打印结果不是空数组(断点看结果)，说明h1已解析完成。所以证明css的加载不会阻塞HTML的解析</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;h1&quot;</span>, <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;h1&quot;</span>));</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">      <span class="built_in">setTimeout</span>(h, <span class="number">0</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span></span></span><br><span class="line"><span class="tag">      <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 样式文件加载完毕之前，h1并没有显示在页面上。所以证明css的加载会阻塞DOM树的渲染 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是红色的<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>怎么解决 css 阻塞的阻塞现象？我们可以提高 css 的加载速度：</p><ol><li>使用 CDN。CDN 会替你挑选最近的节点为你提供资源。</li><li>对 css 进行压缩。webpack,gulp 等打包工具</li><li>将多个 css 文件合并。</li></ol><p><strong>思考：在页面中新增一个弹窗节点，加在哪个位置最好？页面是如何重新渲染的？</strong><br>加在 DOM 结构末尾。无论放在哪个位置，整个 HTML 都会重新解析，加在末尾是为了减少生成 render tree 时的计算过程（整颗新旧树还是会比较的，react diff 也会同理）</p><h4 id="JS-与渲染路径"><a href="#JS-与渲染路径" class="headerlink" title="JS 与渲染路径"></a>JS 与渲染路径</h4><p><strong>js 与样式文件：</strong><br>解析 HTML 时，如果在 script 元素之前发现样式文件，<strong>样式文件的加载和解析会阻塞 JS 的解析和执行</strong>。</p><p>用代码证明 css 的加载阻塞 js 的执行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>css阻塞js的执行<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;before css&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> startDate = <span class="keyword">new</span> <span class="title class_">Date</span>();</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span></span></span><br><span class="line"><span class="tag">      <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>css阻塞js的执行<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> endDate = <span class="keyword">new</span> <span class="title class_">Date</span>();</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;after css&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;经过了&quot;</span> + (endDate - startDate) + <span class="string">&quot;ms&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708326697875.png" alt="pic.1708326697875"><br>可以看出，bootstrap 样式文件加载了 111964ms，加载完成后才执行了后面的 JS。</p><p>JS 与 HTML，用一张图来表示：<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708326704654.png" alt="pic.1708326704654"><br>稍微解释一下这张图：<br>解析 HTML 时，如果发现了 script 元素，<strong>JS 的加载和解析都会阻塞 HTML 的解析</strong>，等 script 加载以及执行完毕再解析 HTML。这就是我们将 script 放在 DOM 结构后面的原因。</p><p>那是不是说 script 标签必须放在 DOM 结构后面？并不是，因为可以给 script 标签添加 async 或 defre 属性。</p><p><strong>带 async 属性的 script:</strong></p><p>async 表示异步，即用异步的方式加载脚本，render 进程会开启一个新的线程来加载 JS，所以<strong>JS 的加载不会阻塞 HTML 的解析，但 JS 的执行仍然会阻塞 HTML 的解析。</strong>等 JS 执行完毕后，才继续解析 HTML。</p><p>因为 async 加载完成之后会马上执行，所以它是无序的。</p><p><strong>带 defer 属性的 script:</strong></p><p>defer 表示延迟，即延迟执行，像 async 一样，<strong>JS 的加载不会阻塞 HTML 的解析</strong>，<strong>并且 JS 会在 HTML 解析完成后再执行</strong>。</p><p>async 与 defer 的区别：</p><ul><li>async 脚本是无序的，适合‘完全不依赖它或它不被任何脚本依赖’的脚本</li><li>async 脚本的执行会阻止 HTML 的解析，defer 不会</li></ul><p>async 与 defer 的相同点：</p><ul><li>使用 async 或 defer 属性，render 进程会开启一个新的线程来加载 JS 文件，也就是说 script 的加载是和 HTML 的解析同时进行的</li></ul><p>HTML 的解析能不能和 JS 的执行同时进行？<br>不能。GUI 线程负责 HTML 的解析，JS 引擎线程负责 JS 的执行，虽然是两个线程，但他们是互斥的。</p><p>补充：<br>DOMContentLoaded<br>HTML 解析完成后，DOMContentLoaded 就会触发，解析完成表示我们已经可以访问页面的 DOM 元素了。DOMContentLoaded 类似于 JQuery 中的<code>$(document).ready(function() &#123; // ...代码... &#125;)</code>。</p><p>load<br>整个页面及所有依赖资源如图片和样式表都已加载完成时触发。<br>DOMContentLoaded 时间会比 load 小，时间差表示依赖资源加载的时间。</p><p>参考：<br><a href="https://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html">https://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html</a><br><a href="https://segmentfault.com/q/1010000000640869">https://segmentfault.com/q/1010000000640869</a><br><a href="https://www.cnblogs.com/caizhenbo/p/6679478.html">https://www.cnblogs.com/caizhenbo/p/6679478.html</a></p><p>在页面的交互过程中，需要重绘或者由于某些操作引发了回流时，GUI 会重新计算 render tree，然后重新绘制页面元素。</p><h4 id="重绘和回流"><a href="#重绘和回流" class="headerlink" title="重绘和回流"></a>重绘和回流</h4><p><strong>重绘（repaint）</strong>：当页面元素的样式发生改变时，GUI 会根据新样式重新绘制该元素，这个过程称为重绘。重绘不影响布局</p><p>导致重绘的操作有哪些：</p><ul><li>改变元素的外观，可见性（visibility）</li><li>回流导致重绘</li></ul><p>利用 chrome 中的 Paint flashing 工具，可以观察元素的重绘。<br>开发者工具 -&gt; more tools -&gt; Rendering，勾选 Paint flashing。重绘的元素会高亮显示。</p><p><strong>回流（reflow）</strong>：当页面元素的尺寸、结构发生改变时，GUI 重新计算的过程，这个过程称为回流。回流完成后，重新绘制受影响的部分到屏幕中，所以说回流必将引起重绘。</p><p>导致回流的操作有哪些：</p><ul><li>浏览器窗口发生变化</li><li>元素的尺寸、位置发生变化</li><li>元素内容、字体大小发生变化</li><li>激活 css 伪类，例如 hover</li><li>添加或者删除元素</li><li>滚动</li></ul><h4 id="如何减少回流"><a href="#如何减少回流" class="headerlink" title="如何减少回流"></a>如何减少回流</h4><p>抓住一个核心原则，<strong>对于 DOM 元素的操作，避免影响该元素之外的元素</strong></p><ul><li>如果想要改变元素样式，可以通过 class 名，而不是使用 JS 操作</li><li>避免使用多层内联样式</li><li>首屏服务端渲染，减少页面内容计算次数</li><li>避免使用 table 布局</li></ul><h3 id="JS-引擎线程"><a href="#JS-引擎线程" class="headerlink" title="JS 引擎线程"></a>JS 引擎线程</h3><p>浏览器是不支持直接运行 JS 代码的，所以需要在浏览器中植入一个内核，来支持 JS 的解析和运行。在 chrome 中，这个内核叫 V8。</p><p>一个网页只会启动一个 JS 线程来处理 JS 脚本。</p><p>JS 线程是单线程。这点不难理解，如果是多线程，一个线程删除 DOM，一个线程新增 DOM，浏览器要如何处理呢？</p><p>还有一点，<strong>JS 线程和 GUI 线程是互斥的</strong>。所以在渲染路径阶段，存在阻塞问题。</p><h3 id="定时触发器线程"><a href="#定时触发器线程" class="headerlink" title="定时触发器线程"></a>定时触发器线程</h3><p>专门负责 setTimeout&#x2F;setInterval 的逻辑。应该结合事件循环中的队列来理解定时器线程的执行过程。</p><h3 id="事件触发线程"><a href="#事件触发线程" class="headerlink" title="事件触发线程"></a>事件触发线程</h3><p>当我们鼠标点击与滑动、键盘的输入等都会触发一些事件，而这些事件的触发逻辑的处理，就是依靠事件触发线程来帮助浏览器完成。</p><p>该线程也会把事件的逻辑放入队列中，等待 JS 引擎的处理。在事件循环中，事件触发为宏任务。</p><h3 id="http-线程"><a href="#http-线程" class="headerlink" title="http 线程"></a>http 线程</h3><p>使用无状态短链接的 http 请求，在应用层基于 http 协议的基础之上，达到与服务端进行通信的目的。</p><p>该线程的触发罗家，不是在 JS 引擎线程之中，过程是异步的。</p><p>参考：<br><a href="https://juejin.cn/post/6844903667733118983">https://juejin.cn/post/6844903667733118983</a><br><a href="https://juejin.cn/post/6844903667733118983">https://juejin.cn/post/6844903667733118983</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器的进程与线程</title>
      <link href="/2024/02/07/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
      <url>/2024/02/07/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h1><p>操作系统上有很多 app，app 就是应用程序，应用程序就是一个软件包，一个代码集合。而应用程序是静态的，想要运行应用程序，操作系统就会对应的启动一个进程，负责该程序的运行。</p><p>把浏览器看做一个大集团，那进程就是集团下的某一个工厂。</p><p>总结进程有以下特点：</p><ul><li>动态性：进程的实质是程序的一次执行过程</li><li>并发性：集团可以有多个工厂，浏览器也可以同时运行多个进程</li><li>独立性：工厂是独立的，进程是一个能独立运行的基本单位</li><li>异步性：因为是独立的，因此可以按照自己逻辑不可预知的运行</li><li>协同性：应用程序之间能够协作完成一些任务</li></ul><h1 id="浏览器进程"><a href="#浏览器进程" class="headerlink" title="浏览器进程"></a>浏览器进程</h1><p>与操作系统一样，浏览器也有一个任务管理器，每一个任务，都是独立的进程。<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708326642981.png" alt="pic.1708326642981"></p><p>浏览器主要包括如下进程：</p><h2 id="一、浏览器主进程"><a href="#一、浏览器主进程" class="headerlink" title="一、浏览器主进程"></a>一、浏览器主进程</h2><p>浏览器只会创建一个主进程，它主要负责：</p><ul><li>浏览器界面提供的交互，如前进、后退、标签栏、设置等</li><li>各页面进程的管理，如创建、关闭等</li><li>网络资源的管理，如下载内容、缓存等</li></ul><h2 id="二、网页进程"><a href="#二、网页进程" class="headerlink" title="二、网页进程"></a>二、网页进程</h2><p><strong>网页进程</strong>：浏览器网页的渲染和 JS 执行在一个单独的进程中执行。这个进程也称为<strong>render 进程</strong>。每启动一个页面，都会启动一个 render 进程。</p><p>说到网页进程，又引入了线程的概念。</p><p>如果说进程是一个工厂，那线程就是工厂中的流水线。一个工厂的正常运行，往往需要多个流水线通力合作才能完成。在网页进程中也是一样，想要网页进程能正常渲染运行，也需要多个线程参与合作。</p><p>网页的渲染运行，有如下线程参</p><h3 id="GUI-渲染线程"><a href="#GUI-渲染线程" class="headerlink" title="GUI 渲染线程"></a>GUI 渲染线程</h3><p>GUI(Graphical User Interface)表示图形用户界面的意思，render tree 的渲染。用一张图看一下渲染路径<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708326653199.png" alt="pic.1708326653199"><br>HTML 会解析出 DOM（Document Object Model）树，样式文件会解析出 CSSOM(CSS Object Model)树，在 Attachment 环节，GUI 线程将 DOM 树与 CSSOM 树合并在一起，生成渲染树(render tree)，并将渲染树绘制到页面。</p><h3 id="JS-引擎线程"><a href="#JS-引擎线程" class="headerlink" title="JS 引擎线程"></a>JS 引擎线程</h3><p>浏览器是不支持直接运行 JS 代码的，所以需要在浏览器中植入一个内核，来支持 JS 的解析和运行。在 chrome 中，这个内核叫 V8。</p><p>一个网页只会启动一个 JS 线程来处理 JS 脚本。</p><p>JS 线程是单线程。这点不难理解，如果是多线程，一个线程删除 DOM，一个线程新增 DOM，浏览器要如何处理呢？</p><p>还有一点，<strong>JS 线程和 GUI 线程是互斥的</strong>。所以在渲染路径阶段，存在阻塞问题。</p><h3 id="定时触发器线程"><a href="#定时触发器线程" class="headerlink" title="定时触发器线程"></a>定时触发器线程</h3><p>专门负责 setTimeout&#x2F;setInterval 的逻辑。应该结合事件循环中的队列来理解定时器线程的执行过程。</p><h3 id="事件触发线程"><a href="#事件触发线程" class="headerlink" title="事件触发线程"></a>事件触发线程</h3><p>当我们鼠标点击与滑动、键盘的输入等都会触发一些事件，而这些事件的触发逻辑的处理，就是依靠事件触发线程来帮助浏览器完成。</p><p>该线程也会把事件的逻辑放入队列中，等待 JS 引擎的处理。在事件循环中，事件触发为宏任务。</p><h3 id="http-线程"><a href="#http-线程" class="headerlink" title="http 线程"></a>http 线程</h3><p>使用无状态短链接的 http 请求，在应用层基于 http 协议的基础之上，达到与服务端进行通信的目的。</p><p>该线程的触发罗家，不是在 JS 引擎线程之中，过程是异步的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深浅拷贝</title>
      <link href="/2024/02/07/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2024/02/07/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<h1 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h1><p>从一个或多个源对象分配到目标对象，返回目标对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, <span class="attr">sym</span>: <span class="title class_">Symbol</span>(<span class="number">1</span>) &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj1, <span class="string">&quot;innumerable&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&quot;不可枚举属性&quot;</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(obj2, obj1);</span><br><span class="line"></span><br><span class="line">obj1.<span class="property">a</span>.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123; obj1 &#125;); <span class="comment">// &#123; a: &#123; b: 2 &#125;, sym: Symbol(1), innumerable: &quot;不可枚举属性&quot; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123; obj2 &#125;); <span class="comment">// &#123; a: &#123; b: 2 &#125;, sym: Symbol(1) &#125;</span></span><br></pre></td></tr></table></figure><ul><li>不会拷贝不可枚举属性</li><li>可以拷贝 symbol 类型的属性</li><li>他不会拷贝对象的继承属性</li></ul><h1 id="…-扩展运算符"><a href="#…-扩展运算符" class="headerlink" title="… 扩展运算符"></a>… 扩展运算符</h1><p>和<code>Object.assign</code>拥有同样的缺陷，但是拷贝基本类型的值的时候会更加方便</p><h1 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h1><p>用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组</p><h1 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h1><p>浅拷贝数组，仅仅针对数组类型。<br>类数组可以使用 <code>Object.prototype.slice.call(arr)</code>，表示从 Array 中获取 slice 方法，绑定到 arr 中，并执行 slice。</p><p>测试：<br><code>array1</code>和<code>cloneArray1</code>第一项的 name 属性都变为’wangwu’</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;zhangsan&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&quot;lisi&quot;</span> &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="comment">// const cloneArray1 = [...array1]</span></span><br><span class="line"><span class="comment">// const cloneArray1 = Object.assign(array1)</span></span><br><span class="line"><span class="comment">// const cloneArray1 = array1.concat([])</span></span><br><span class="line"><span class="keyword">const</span> cloneArray1 = array1.<span class="title function_">slice</span>();</span><br><span class="line">cloneArray1[<span class="number">0</span>].<span class="property">name</span> = <span class="string">&quot;wangwu&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;array1&quot;</span>, array1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;cloneArray1&quot;</span>, cloneArray1);</span><br></pre></td></tr></table></figure><h1 id="浅拷贝的实现"><a href="#浅拷贝的实现" class="headerlink" title="浅拷贝的实现"></a>浅拷贝的实现</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shallowClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span> || target === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> newObj = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      <span class="comment">// 忽略原型上继承过来的属性</span></span><br><span class="line">      newObj[key] = obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="深拷贝的实现"><a href="#深拷贝的实现" class="headerlink" title="深拷贝的实现"></a>深拷贝的实现</h1><h2 id="乞丐版：JSON-stringify"><a href="#乞丐版：JSON-stringify" class="headerlink" title="乞丐版：JSON.stringify"></a>乞丐版：JSON.stringify</h2><p>将对象序列化为 JSON 字符串，对对象里面的内容转为字符串，再用 JSON.parse 生成新对象。<br>注意点：</p><ul><li>如果对象”值”中有函数、undefined、symbol 这几种类型，经过序列化之后这个键值对会消失</li><li>拷贝 Date 引用各类型会变成字符串</li><li>拷贝 RegExp 引用类型会变成空对象</li><li>无法拷贝不可枚举属性</li><li>无法拷贝对象的原型链</li><li>无法拷贝对象的循环应用，即对象成环（obj[key] &#x3D; obj）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Obj</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">func</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">obj</span> = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">und</span> = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">reg</span> = <span class="regexp">/123/</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">date</span> = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">NaN</span> = <span class="title class_">NaN</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">infinity</span> = <span class="title class_">Infinity</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sym</span> = <span class="title class_">Symbol</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="variable language_">this</span>[<span class="title class_">Symbol</span>(<span class="number">2</span>)] = <span class="string">&quot;sym2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> <span class="title class_">Obj</span>();</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj1, <span class="string">&quot;innumerable&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&quot;innumerable&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;obj1&quot;</span>, obj1);</span><br><span class="line"><span class="keyword">let</span> obj22 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj1));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;obj22&quot;</span>, obj22);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708326973863.png" alt="pic.1708326973863"></p><h2 id="基础版"><a href="#基础版" class="headerlink" title="基础版"></a>基础版</h2><p>注意点：</p><ul><li>不能复制不可枚举和 Symbol 类型的属性</li><li>对于 Date、RegExp 这样的引用类型不能正确的拷贝</li><li>没解决循环引用问题</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">&quot;object&quot;</span> &amp;&amp; target !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> newObj = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> target[key] === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">        newObj[key] = <span class="title function_">deepClone</span>(target[key]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newObj[key] = target[key];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj3 = <span class="title function_">deepClone</span>(obj1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;obj3&quot;</span>, obj3);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708326963610.png" alt="pic.1708326963610"></p><h2 id="改进版"><a href="#改进版" class="headerlink" title="改进版"></a>改进版</h2><ul><li>对于不可枚举和 Symbol 类型，可以 Reflect.ownKeys(),Reflect.ownKeys &#x3D;&#x3D;&#x3D; Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(Obj))</li><li>对于 Date 和 RegExp 类型，直接返回一个实例对象</li><li>Object.getOwnPropertyDescriptors 可以获取所有自身属性的描述符，以及对应的特性，顺便结合 Object 的 create 方法创建一个新对象，并集成原对象的原型链</li><li>利用 WeakMap 类型作为 hash 表，因为 WeakMap 是弱引用类型，可以有效防止内存泄漏，如果存在循环引用，就直接返回 WeakMap 存储的值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">isComplexDataType</span> = (<span class="params">obj</span>) =&gt;</span><br><span class="line">  (<span class="keyword">typeof</span> obj === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> obj === <span class="string">&quot;function&quot;</span>) &amp;&amp; obj !== <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepCloneImprove</span>(<span class="params">obj, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj.<span class="property">constructor</span> === <span class="title class_">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(obj); <span class="comment">// 日期对象直接返回一个新的日期对象</span></span><br><span class="line">  <span class="keyword">if</span> (obj.<span class="property">constructor</span> === <span class="title class_">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegExp</span>(obj); <span class="comment">//正则对象直接返回一个新的正则对象</span></span><br><span class="line">  <span class="comment">//如果循环引用了就用 weakMap 来解决</span></span><br><span class="line">  <span class="keyword">if</span> (hash.<span class="title function_">has</span>(obj)) <span class="keyword">return</span> hash.<span class="title function_">get</span>(obj);</span><br><span class="line">  <span class="keyword">let</span> allDesc = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj);</span><br><span class="line">  <span class="comment">//遍历传入参数所有键的特性</span></span><br><span class="line">  <span class="keyword">let</span> cloneObj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj), allDesc);</span><br><span class="line">  <span class="comment">//继承原型链</span></span><br><span class="line">  hash.<span class="title function_">set</span>(obj, cloneObj);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj)) &#123;</span><br><span class="line">    cloneObj[key] =</span><br><span class="line">      <span class="title function_">isComplexDataType</span>(obj[key]) &amp;&amp; <span class="keyword">typeof</span> obj[key] !== <span class="string">&quot;function&quot;</span></span><br><span class="line">        ? <span class="title function_">deepCloneImprove</span>(obj[key], hash)</span><br><span class="line">        : obj[key];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj4 = &#123;</span><br><span class="line">  <span class="attr">num</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">str</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">boolean</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">unf</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">nul</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">obj</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;我是一个对象&quot;</span>, <span class="attr">id</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  <span class="attr">arr</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  <span class="attr">func</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我是一个函数&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">date</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">0</span>),</span><br><span class="line">  <span class="attr">reg</span>: <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;/我是一个正则/ig&quot;</span>),</span><br><span class="line">  [<span class="title class_">Symbol</span>(<span class="string">&quot;1&quot;</span>)]: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj4, <span class="string">&quot;innumerable&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&quot;不可枚举属性&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line">obj4 = <span class="title class_">Object</span>.<span class="title function_">create</span>(obj4, <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj4));</span><br><span class="line">obj4.<span class="property">loop</span> = obj4; <span class="comment">// 设置loop成循环引用的属性</span></span><br><span class="line"><span class="keyword">let</span> cloneObj = <span class="title function_">deepCloneImprove</span>(obj4);</span><br><span class="line">cloneObj.<span class="property">arr</span>.<span class="title function_">push</span>(<span class="number">4</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;obj4&quot;</span>, obj4);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;cloneObj&quot;</span>, cloneObj);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708326948006.png" alt="pic.1708326948006"></p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包</title>
      <link href="/2024/02/07/%E9%97%AD%E5%8C%85/"/>
      <url>/2024/02/07/%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p><strong>本质：</strong> 局部数据共享</p><p>没有任何一个技术方案可以做到局部数据共享。那么如何局部共享呢？<br>可以创建一个函数作用域，在这个作用域内共享数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">p</span> () &#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">  funtion foo () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  funtion bar () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>p 函数的局部变量 a，被 foo 和 bar 这两个函数共享</p><p><strong>定义：</strong> 闭包是一个特殊的对象。它由两部分组成，执行上下文 A 以及在 A 中创建的函数 B。当 B 执行时，如果访问了 A 中的变量，那么闭包就产生了。</p><p>在 chrome 中，执行上下文 A 的函数名代指闭包</p><p>词法作用域：在我们编写代码时，语法规范就已经确定了词法作用域的作用范围。<br><br>词法作用域是为了明确告诉我们，当前的上下文环境中，能够访问哪些变量参与程序的运行。除了自身上下文，还可以从函数体的[[Scopes]]属性访问其他作用域的声明。</p><p>闭包形成的原因：<br><br>闭包是基于词法作用域的规则产生，让函数内部可以访问函数外部的声明。闭包在代码解析时就能确定。</p><h1 id="闭包对象什么时候被回收"><a href="#闭包对象什么时候被回收" class="headerlink" title="闭包对象什么时候被回收"></a>闭包对象什么时候被回收</h1><p>闭包对象<code>[Closure(A)]</code>的引用存在于函数体 B 的内存中。如果 B 函数体被回收，闭包对象同样也被回收。</p><p>看个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  (<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(++a); <span class="comment">// 这时候闭包产生了，</span></span><br><span class="line">  &#125;)();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">//运行到这里是，f的执行上下文被销毁，闭包也消失了。此时fn中的a变成了2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">fn</span>(); <span class="comment">// 等fn执行完，fn的执行上下文也被销毁</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708325490489.png" alt="pic.1708325490489"><br>内部函数<code>f</code>执行完毕，其执行上下文被回收，闭包对象也随之被回收。<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708325496558.png" alt="pic.1708325496558"></p><h1 id="保存闭包对象不被回收"><a href="#保存闭包对象不被回收" class="headerlink" title="保存闭包对象不被回收"></a>保存闭包对象不被回收</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    a = a + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>()(); <span class="comment">// 31</span></span><br><span class="line"><span class="title function_">foo</span>()(); <span class="comment">// 31</span></span><br></pre></td></tr></table></figure><p>foo 调用完毕，其执行上下文被回收，bar 作为 foo 的一部分，自然也被回收，那么保存在 foo.[[Scipes]] 上的闭包对象自然也被回收。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    a = a + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo()()</span></span><br><span class="line"><span class="comment">// foo()()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="title function_">foo</span>();</span><br><span class="line"><span class="title function_">bar</span>(); <span class="comment">// 31</span></span><br><span class="line"><span class="title function_">bar</span>(); <span class="comment">// 32</span></span><br></pre></td></tr></table></figure><p>那么如何保存这个闭包对象不被回收呢？我们知道垃圾回收机制会通过根搜索算法回收非活跃的对象，那只需要<strong>在当前执行上下文中，保存内部函数的引用</strong>，闭包对象就不会被回收。</p><p>当 foo 执行完毕时，foo 依然会被回收，但是由于执行了<code>var bar = foo()</code>，内部函数 bar 有了新的方式保存引用，所以即使 foo 执行完毕，bar 也不会被回收，而是在内存中持续存在，那么闭包对象 <code>Closure[foo]</code>也就不会被回收。</p><h1 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h1><h2 id="常用面试题"><a href="#常用面试题" class="headerlink" title="常用面试题"></a>常用面试题</h2><p>表现为 setTimeout 第二个参数为 1-5，定时器在循环结束后隔秒输出 6</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;, i * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用自执行函数改造-隔秒一次输出 1-5<br>自执行函数与 timer 形成闭包，所以 i 被保存了下来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="keyword">function</span> (<span class="params">i</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    &#125;, i * <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708325509698.png" alt="pic.1708325509698"><br>可以看到，循环执行完毕后，还能访问到 i，此时 i 的值为保存在闭包对象的值。</p><p>进一步改造，缩小约束范围，只约束 timer，瞬间输出 1-5</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(</span><br><span class="line">    (<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params">i</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    &#125;)(i),</span><br><span class="line">    i * <span class="number">1000</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单例模式与闭包"><a href="#单例模式与闭包" class="headerlink" title="单例模式与闭包"></a>单例模式与闭包</h2><p>单例模式，就是只有一个实例的对象<br>对象字面量的方法，就是一个单例模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> per = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Jake&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="attr">getName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getAge</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">age</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">per.<span class="property">name</span> = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per.<span class="title function_">getName</span>());</span><br></pre></td></tr></table></figure><p>这样的单例存在一个问题，属性可以被外部修改。<br>我们希望拥有自己的私有方法&#x2F;属性，所以可以利用自执行函数的作用域进行隔离。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> per = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&quot;Jake&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">getName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">getAge</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>这样内部修改就不会被修改，我们可以控制对外提供的属性和方法<br>但是还有一个小问题，这种方式一开始就被初始化了。</p><p>改造一下，仅在调用时初始化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> per = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> instance = <span class="literal">null</span>; <span class="comment">// 保存实例</span></span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&quot;Jake&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">initial</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">getName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">getAge</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">getInstance</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">        instance = <span class="title function_">initial</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> per1 = per.<span class="title function_">getInstance</span>();</span><br><span class="line"><span class="keyword">var</span> per2 = per.<span class="title function_">getInstance</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per1 === per2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="模块化与闭包"><a href="#模块化与闭包" class="headerlink" title="模块化与闭包"></a>模块化与闭包</h2><p>为了减少全局变量的使用，可用模块化的思维解决需要使用全局变量的问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用单例模式，创建一个用于管理全局状态的模块</span></span><br><span class="line"><span class="keyword">var</span> module_status = (<span class="keyword">function</span> <span class="title function_">module_status</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> status = &#123;</span><br><span class="line">    <span class="attr">number</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">color</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> get = <span class="keyword">function</span> (<span class="params">prop</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> status[prop]; <span class="comment">// 访问闭包对象 Closure(module_status) 的属性</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> set = <span class="keyword">function</span> (<span class="params">prop, value</span>) &#123;</span><br><span class="line">    status[prop] = value; <span class="comment">// 设置闭包对象 Closure(module_status) 的属性</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">get</span>: get,</span><br><span class="line">    <span class="attr">set</span>: set,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责改变颜色的模块</span></span><br><span class="line"><span class="keyword">var</span> module_color = (<span class="keyword">function</span> <span class="title function_">module_color</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 假装用这种方式引入模块 类似于 import state from &#x27;module_status&#x27;;</span></span><br><span class="line">  <span class="keyword">var</span> state = module_status;</span><br><span class="line">  <span class="keyword">var</span> colors = [<span class="string">&quot;orange&quot;</span>, <span class="string">&quot;#ccc&quot;</span>, <span class="string">&quot;pink&quot;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> color = colors[state.<span class="title function_">get</span>(<span class="string">&quot;number&quot;</span>) % <span class="number">3</span>]; <span class="comment">// 访问闭包对象 Closure(module_status) 的 number 属性</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">render</span>: render,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责显示当前number的模块</span></span><br><span class="line"><span class="keyword">var</span> module_context = (<span class="keyword">function</span> <span class="title function_">module_context</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> state = module_status;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;this Number is &quot;</span>); <span class="comment">// 小提示(与主逻辑无关): render[[scopes]]]作用域信息在解析这个函数时就已经确定了。执行到这里时 Closure(module_context) 就已经产生了</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">&quot;this Number is &quot;</span> + state.<span class="title function_">get</span>(<span class="string">&quot;number&quot;</span>); <span class="comment">// 执行闭包对象 Closure(module_status) 的 get 方法，</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">render</span>: render,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主模块</span></span><br><span class="line"><span class="keyword">var</span> module_main = (<span class="keyword">function</span> <span class="title function_">module_main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> state = module_status; <span class="comment">// 保存 module_status 模块返回的字面量对象的引用</span></span><br><span class="line">  <span class="keyword">var</span> color = module_color;</span><br><span class="line">  <span class="keyword">var</span> context = module_context;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> newNumber = state.<span class="title function_">get</span>(<span class="string">&quot;number&quot;</span>) + <span class="number">1</span>; <span class="comment">// 访问闭包对象 Closure(module_status) 的 number 属性</span></span><br><span class="line">  <span class="comment">// state.get() 执行完毕，正常情况下闭包对象 Closure(module_status) 随内部函数的执行完毕而被回收。</span></span><br><span class="line">  <span class="comment">// 但是这里将闭包对象的引用地址保存在当前执行上下文中，所以闭包对象 Closure(module_status) 并没有被销毁</span></span><br><span class="line">  state.<span class="title function_">set</span>(<span class="string">&quot;number&quot;</span>, newNumber); <span class="comment">// 改变闭包对象 Closure(module_status) 的number属性，number == 1</span></span><br><span class="line"></span><br><span class="line">  context.<span class="title function_">render</span>(); <span class="comment">// 43行访问的闭包对象于77行改变的闭包对象是同一个对象</span></span><br><span class="line">  color.<span class="title function_">render</span>();</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，module_status 的引用一直存在全局对象中没被释放，所以执行 module_status 时，还能访问到闭包对象Closure(module_status)，以为输出1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;-------&quot;</span>, module_status.<span class="title function_">get</span>(<span class="string">&quot;number&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主模块</span></span><br><span class="line"><span class="comment">// var module_main = (function () &#123;</span></span><br><span class="line"><span class="comment">//   var state = module_status;</span></span><br><span class="line"><span class="comment">//   var color = module_color;</span></span><br><span class="line"><span class="comment">//   var context = module_context;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   setInterval(function () &#123;  // 这里使用定时器实现切换固定颜色的功能</span></span><br><span class="line"><span class="comment">//     var newNumber = state.get(&#x27;number&#x27;) + 1;</span></span><br><span class="line"><span class="comment">//     state.set(&#x27;number&#x27;, newNumber);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     color.render();</span></span><br><span class="line"><span class="comment">//     context.render();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     console.log(1);</span></span><br><span class="line"><span class="comment">//   &#125;, 1000);</span></span><br><span class="line"><span class="comment">// &#125;)();</span></span><br></pre></td></tr></table></figure><h1 id="其他应用场景"><a href="#其他应用场景" class="headerlink" title="其他应用场景"></a>其他应用场景</h1><h2 id="使用其他模块暴露的接口"><a href="#使用其他模块暴露的接口" class="headerlink" title="使用其他模块暴露的接口"></a>使用其他模块暴露的接口</h2><p>utils&#x2F;index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">&quot;../../../utils&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Closure</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;a&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Closure</span>;</span><br></pre></td></tr></table></figure><p>在函数组件 Closure 中访问了 utils 模块中的变量 <code>a</code>，那么闭包对象就产生了。<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708325527266.png" alt="pic.1708325527266"></p><h2 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h2><p><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708325535782.png" alt="pic.1708325535782"><br>在<code>&lt;Child /&gt;</code>组件中执行<code>foo</code>时，闭包对象<code>Closure(MyClosure)</code>产生了。</p><h2 id="hooks-缓存上次结果"><a href="#hooks-缓存上次结果" class="headerlink" title="hooks 缓存上次结果"></a>hooks 缓存上次结果</h2><p>本质是将上次的结果（闭包对象）缓存在函数体内<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708325542236.png" alt="pic.1708325542236"><br>另外还有以下关于闭包的使用</p><ul><li>高阶函数: 记忆函数</li><li>状态管理：redux、mbox</li><li>函数封装</li><li>BEM</li><li>vue scoped</li><li>css in js：借 js 的作用域，生成 css 作用域</li><li>css modules</li></ul><h1 id="闭包的优缺点"><a href="#闭包的优缺点" class="headerlink" title="闭包的优缺点"></a>闭包的优缺点</h1><p>优点：</p><ol><li>可以重复使用闭包对象内的变量，并且不会造成变量污染</li><li>可以用来定义私有属性和私有方法（单例模式与闭包）</li></ol><p>缺点：</p><ol><li>可能会导致堆内存消耗过大</li></ol><h1 id="闭包对象的回收"><a href="#闭包对象的回收" class="headerlink" title="闭包对象的回收"></a>闭包对象的回收</h1><ul><li>如果是全局变量保存了内部函数的引用，如果没有手动释放这个对象，闭包对象会一直存在堆内存中</li><li>如果是函数内的一个局部变量保存了内部函数的引用，函数出栈后如果没有引用了，闭包对象等待下一次垃圾回收器回收</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防止验证码轰炸_谷歌人机校验_recaptchaV3</title>
      <link href="/2024/02/07/%E9%98%B2%E6%AD%A2%E9%AA%8C%E8%AF%81%E7%A0%81%E8%BD%B0%E7%82%B8_%E8%B0%B7%E6%AD%8C%E4%BA%BA%E6%9C%BA%E6%A0%A1%E9%AA%8C_recaptchaV3/"/>
      <url>/2024/02/07/%E9%98%B2%E6%AD%A2%E9%AA%8C%E8%AF%81%E7%A0%81%E8%BD%B0%E7%82%B8_%E8%B0%B7%E6%AD%8C%E4%BA%BA%E6%9C%BA%E6%A0%A1%E9%AA%8C_recaptchaV3/</url>
      
        <content type="html"><![CDATA[<p>在注册页，往往需要通过短信或者邮箱进行验证再注册。<br>如果短信平台接口被恶意调用，短信通道金额会被严重消耗，严重影响平台的利益。</p><p>recaptcha V3 是谷歌开发的一款可以验证人机交互是否合法的插件。它是一个 JS API，我们可以自定义一个 0-1 分数，来决定本次交互的合法性。假设我们自定义分数为<code>0.9</code>，当谷歌给本次交互打的分数低于<code>0.9</code>时，则表示本次交互不合法，从而达到拦截目的。</p><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><ol><li>创建秘钥。可参考 <a href="https://blog.csdn.net/weixin_59127121/article/details/127092549?spm=1001.2101.3001.6650.5">https://blog.csdn.net/weixin_59127121&#x2F;article&#x2F;details&#x2F;127092549?spm&#x3D;1001.2101.3001.6650.5</a></li></ol><p>公钥<code>Site Key</code> 和 私钥<code>Secret Key</code>：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Site</span> <span class="title class_">Key</span>=<span class="variable constant_">XXXXXXXXXXXXXXXXXX</span></span><br><span class="line"><span class="title class_">Secret</span> <span class="title class_">Key</span>=<span class="variable constant_">AAAAAAAAAAAAAAAAAA</span></span><br></pre></td></tr></table></figure><ol start="2"><li>引入谷歌提供的 script，将<code>Site Key</code>放上去</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://www.recaptcha.net/recaptcha/api.js?render=XXXXXXXXXXXXXXXXXX&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>:::info<br>注意：国内使用，需要将 <strong><a href="http://www.google.com/">www.google.com</a> <strong>替换成</strong> <a href="http://www.recaptcha.net/">www.recaptcha.net</a></strong><br>:::</p><ol start="3"><li>在需要人机验证的操作上调用<code>grecaptcha.execut</code>，填入<code>Site Key</code>，生成谷歌返回的<code>token</code></li></ol><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> token = <span class="keyword">await</span> <span class="variable language_">window</span>.<span class="property">grecaptcha</span>.<span class="title function_">execute</span>(<span class="string">&quot;XXXXXXXXXXXXXXXXXX&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">action</span>: <span class="string">&quot;login&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="4"><li>通过后端接口验证<code>token</code>是否有效，如果成功再进行提交&#x2F;登录等操作</li></ol><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123; token &#125;);</span><br><span class="line"><span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&quot;token&quot;</span>, token);</span><br><span class="line"><span class="keyword">const</span> &#123; data, code, msg &#125; = <span class="keyword">await</span> robotVerApi.<span class="title function_">post</span>(&#123;</span><br><span class="line">  <span class="attr">body</span>: formData,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 校验成功，进行注册等其他操作</span></span><br></pre></td></tr></table></figure><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>在未加入人机验证之前，我们遇到以下问题</p><ol><li>短信验证平台被恶意轰炸</li><li>注册数量暴增（注册邀请人成功后有返利的原因）</li></ol><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>控制短信验证平台的频繁请求。<br><em>控制了短信验证之后，注册接口也就不会频繁请求了。</em></p><p>一开始的解决办法：</p><ol><li>前端发起<strong>人机校验</strong></li><li>后端进行 token 认证，返回状态</li><li>校验成功，<strong>前端请求短信平台</strong></li></ol><p>以上能防止一些恶意的页面频繁操作，但是通过数据发现短信平台接口还在暴增，也就是说攻击者绕过前面两个步骤，通过脚本在轰炸短信平台。</p><p>所以我们改把<strong>前端发送短信</strong>的操作放在后端，避免脚本攻击，步骤如下：</p><ol><li>前端发起后端自定义的短信请求接口</li><li>后端<strong>人机校验</strong>，token 认证成功</li><li><strong>后端请求短信平台</strong></li></ol><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取token</span></span><br><span class="line"><span class="keyword">const</span> token = <span class="keyword">await</span> <span class="variable language_">window</span>.<span class="property">grecaptcha</span>.<span class="title function_">execute</span>(<span class="string">&quot;XXXXXXXXXXXXXXXXXX&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">action</span>: <span class="string">&quot;login&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将token和邮箱传给后端，后端认证token并请求短信平台</span></span><br><span class="line"><span class="keyword">const</span> &#123; data, msg, code &#125; = <span class="keyword">await</span> backendCustomApi.<span class="title function_">post</span>(&#123;</span><br><span class="line">  <span class="attr">body</span>: &#123; email, token &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将短信平台的状态返回</span></span><br><span class="line"><span class="keyword">if</span> (code === <span class="string">&quot;000&quot;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;邮箱已发送&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考:</p><ul><li><a href="https://developers.google.com/recaptcha/docs/v3">https://developers.google.com/recaptcha/docs/v3</a></li><li><a href="https://xushanxiang.com/recaptcha-v3.html">https://xushanxiang.com/recaptcha-v3.html</a></li><li><a href="https://blog.csdn.net/weixin_59127121/article/details/127092549?spm=1001.2101.3001.6650.5">https://blog.csdn.net/weixin_59127121&#x2F;article&#x2F;details&#x2F;127092549?spm&#x3D;1001.2101.3001.6650.5</a></li><li><a href="https://dun.163.com/news/p/b613338178b84e2ea5029e6cff150724">https://dun.163.com/news/p/b613338178b84e2ea5029e6cff150724</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 项目场景 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
