<!DOCTYPE html>
<html lang="zh" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="weilun" />
  <!-- Open Graph Description 简短摘要-->
  
  <!-- 用于搜索引擎的文章摘要 -->
  
  
  
  <title>
    
      事件循环机制 
      
      
      |
    
     维论
  </title>

  
    <link rel="apple-touch-icon" href="/images/favicon.png">
    <link rel="icon" href="/images/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <!-- 代码块风格 -->
  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/images/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">维论</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">首页</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">归档</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">标签</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">关于</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">事件循环机制</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
          2024-02-27 22:30:13
        </span>
        
              <span class="post-tags">
                <i class="iconfont icon-tags mr-10" title="Tags"></i>
                
                <span class="span--tag mr-8">
                  <a href="/tags/javascript/" title="javascript">
                    #javascript
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <h1 id="同步于异步"><a href="#同步于异步" class="headerlink" title="同步于异步"></a>同步于异步</h1><p>同步：按函数调用栈执行</p>
<p>异步：分发器分发一个任务，被通知后执行</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>负责 JS 执行环境的代码执行顺序的问题。如果没有异步事件，函数调用栈几乎可以解决所有执行顺序问题。而事件循环机制，就是异步事件代码执行顺序的解决方案。</p>
<p>那么，浏览器中有哪些异步事件，以及它们各自有哪些特点呢？</p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>许多异步事件，都是由线程负责处理。<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708327092141.png" alt="pic.1708327092141"><br>JS 是单线程的，但是 JS 的执行环境是由多个线程协同工作的。不同的线程，对应着不同的异步事件。</p>
<h2 id="五个线程"><a href="#五个线程" class="headerlink" title="五个线程"></a>五个线程</h2><p><strong>GUI 线程</strong></p>
<p>负责 HTML 的解析与渲染。DOM 结构的修改是同步的，但是 <strong>DOM 的渲染过程是异步的</strong>。</p>
<p><strong>JS 引擎线程</strong></p>
<p>负责 JS 代码的运行。<br>每一个网页，只会启动一个 JS 线程来配合完成页面的交互。</p>
<p><strong>定时器线程</strong></p>
<p>专门负责 setTimeout&#x2F;setInterval 的逻辑。<br>回调函数中的逻辑并不会马上执行，即使将时间设置为 0，这也是异步的。</p>
<p><strong>I&#x2F;O 时间触发线程</strong></p>
<p>当我们鼠标点击与滑动、键盘的输入等都会触发一些事件，而这些事件的触发逻辑的处理，就是依靠事件触发线程来帮助浏览器完成。</p>
<p>该线程也会把事件的逻辑放入队列中，等待 JS 引擎的处理。</p>
<p><strong>http 线程</strong></p>
<p>使用无状态短链接的 http 请求，在应用层基于 http 协议的基础之上，达到与服务端进行通信的目的。</p>
<p>该线程的触发逻辑，不是在 JS 引擎线程中，这个过程是异步的。</p>
<p>小结：除了 JS 引擎线程，其他四个线程分别处理与之对应的异步任务。比如定时器线程，由任务分发器 setTimeout &#x2F;setInterval 分发异步任务进入定时器执行队列。</p>
<h2 id="与-UI-render-紧密相关的-raf-ric"><a href="#与-UI-render-紧密相关的-raf-ric" class="headerlink" title="与 UI render 紧密相关的 raf&#x2F;ric"></a>与 UI render 紧密相关的 raf&#x2F;ric</h2><p><strong>requestAnimationFrame</strong> 简称「raf」,它是动画的重要实现手段。他跟前面介绍的异步方式大有不同，跟 UI render 紧密相关。</p>
<p>结合浏览器的渲染机制共同理解。<br>常规的显示器的刷新率为 60 Hz，也就是说，1 秒钟把页面刷新了 60 次，是最合理的频率。</p>
<p>这也是浏览器在进行 UI render 的合理频率。因此，每一次的渲染时间，控制在 1000 &#x2F; 60 ms 以内。对浏览器来说才不会负荷工作。</p>
<p>requestAnimationFrame 是完成符合浏览器刷新频率的回调方式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如果单次执行时间大于 <span class="number">16.</span>67ms，也就是刷新率低于 <span class="number">60</span> <span class="title class_">Hz</span>，会表现出卡顿；</span><br><span class="line"></span><br><span class="line">卡顿的理解：</span><br><span class="line">网络直播时，如果网络不好，会丢包导致卡帧。也就是说，下一秒的包还没发给你，自动刷新，刷新的还是上一次的老包，所以表现为卡顿，看起来就像刷新率低一样。</span><br><span class="line"></span><br><span class="line">会用掉帧策略（放弃某一帧的任务）来解决。而不使用任务堆积。</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果高于 60hz，浏览器会超负荷工作。raf 的回调函数为 <span class="number">1000</span> / <span class="number">60</span> 执行一次，刚刚好符合浏览器刷新频率</span><br></pre></td></tr></table></figure>

<p>我们通常喜欢将一次 UI render 描述为 一帧 「frame」。requsetAnimationFrame 只会在每一帧开始渲染之前执行。<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708327251065.png" alt="pic.1708327251065"></p>
<p><strong>requestIdleCallback</strong> 简称「ric」,图中的<code>idle</code>，通常将优先级不高的任务放在 ric 中执行。</p>
<p>它的执行频率也跟 UI render 的频率一样。但是它会在每一帧的最后执行。</p>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>在浏览器中，线程对应的事件，并不能覆盖所有的异步事件类型。Promise 就是一个特例。</p>
<p>Promise 是 JS 的内部逻辑。并非由浏览器额外的线程来处理。因此，Promise 的异步逻辑与线程对应的异步逻辑是不一样的。</p>
<p>在 JS 引擎的处理逻辑中，Promise 有自己的事件队列，并且该队列在所有 JS 代码执行完成后执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(f, r);</span><br></pre></td></tr></table></figure>

<h2 id="job"><a href="#job" class="headerlink" title="job"></a>job</h2><p>then 中的回调函数，就是一个 job。此处为 f 与 r。catch 同理。</p>
<h2 id="PromiseJobs-执行队列"><a href="#PromiseJobs-执行队列" class="headerlink" title="PromiseJobs 执行队列"></a>PromiseJobs 执行队列</h2><p>用于存储 Promise 异步逻辑。该队列在所有 JS 代码执行完之后执行。也可以说在 call stach 清空之后执行。</p>
<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>一个 promise 有三种状态</p>
<ul>
<li>pending: 等待结果状态</li>
<li>fulfilled: 已出结果，结果符合预期完成状态</li>
<li>rejected: 已出结果，结果未符合预期完成状态</li>
</ul>
<p>当一个 promise 实例在创建时，处于 pending 状态。<br>当 resolve 函数调用时， padding -&gt; fulfilled<br>当 reject 函数调动是， padding -&gt; rejected</p>
<p>当 promise 有了状态，不再是 padding ，那么我们称该 promise 的状态被固定: <strong>settled</strong></p>
<h2 id="何时进入-PromiseJobs"><a href="#何时进入-PromiseJobs" class="headerlink" title="何时进入 PromiseJobs"></a>何时进入 PromiseJobs</h2><p>调用 <code>p.then(f, r)</code>时，会将 <code>f</code> 放入 <code>[[PromiseFulfillReactions]]</code>队列尾部，将 <code>r</code>放入 <code>[[PromiseRejectReactions]]</code>队列尾部。</p>
<p>这两个队列，是<strong>临时中间队列</strong>（准确的说，应该叫临时存储地方，出队时是无序的）。该队列中的 job 只会移入到 PromiseJobs 队列中而不会有自己的执行过程。 PromiseJobs 才有执行 job 的逻辑。</p>
<p>当 <code>resolve/reject</code>函数调用时，promise 产生了结果。此时，根据不同的结果，<code>p.then(f, r)</code>将不同的 job 「f &#x2F; r」加入到 PromiseJobs 队列中。</p>
<p>如果在创建时，就已经 settled ，那么 job 会直接进入 PromiseJobs 队列中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(); <span class="comment">// 直接敲定状态</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>链式调用时，后续的 then 如何将 job 加入到 PromiseJobs 队列，需要根据上一个 then 的返回结果来决定。</p>
<ul>
<li>当不确定返回结果时，且 then 已调用，对应的 job 进入临时队列中。</li>
<li><strong>确定了返回结果之后，才会将 job 移入到 PromiseJobs 队列中</strong>。</li>
</ul>
<h2 id="PromiseJobs-队列如何执行"><a href="#PromiseJobs-队列如何执行" class="headerlink" title="PromiseJobs 队列如何执行"></a>PromiseJobs 队列如何执行</h2><p>先进入的先执行。但是有一点要注意，当 job 执行时，可能会产生新的 job 进入到该队列。因此 <strong>PromiseJobs 在执行过程中会动态变化</strong>。</p>
<p>PromiseJobs 的执行规则</p>
<ul>
<li>当所有 JS 代码执行完毕，PromiseJobs 队列开始出队执行</li>
<li>PromiseJobs 处于动态变化中，只有当 PromiseJobs 队列为空时，才会结束执行</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">PromiseJobs</span> = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入 job1</span></span><br><span class="line"><span class="title class_">PromiseJobs</span>.<span class="title function_">push</span>(job1);</span><br><span class="line"><span class="comment">// 加入 job2</span></span><br><span class="line"><span class="title class_">PromiseJobs</span>.<span class="title function_">push</span>(job2);</span><br><span class="line"></span><br><span class="line"><span class="title class_">PromiseJobs</span> = [job1, job2];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> job;</span><br><span class="line"><span class="comment">// 将先进入队列的 job 移除队列，并执行</span></span><br><span class="line"><span class="comment">// PromiseJobs 是处于动态变化的，所以只能用 while 来处理这种动态循环的场景。不能用 for 循环</span></span><br><span class="line"><span class="keyword">while</span> ((job = <span class="title class_">PromiseJobs</span>.<span class="title function_">shift</span>())) &#123;</span><br><span class="line">  <span class="title function_">job</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过两例子感受一下<br>例子一：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>();</span><br><span class="line">    &#125;)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">f3</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">f4</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出: 0 1 2 3 4</span></span><br></pre></td></tr></table></figure>

<p>Promise 在创建时，直接调用了 resolve ， Promise 有了结果，因此， f1 马上被加入 PromiseJobs 队列。f2 要等待 f1 的结果，所以只能被加入临时队列。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">PromiseJobs</span> = [f1];</span><br><span class="line"><span class="title class_">PromiseFulfillReactions</span> = [f2];</span><br></pre></td></tr></table></figure>

<p>输出 0, JS 所有代码执行结束, 开始执行 PromiseJobs 列队中的逻辑</p>
<p>** f1 出队执行**, 输出 1, 遇到一个新的 Promise 对象, 且直接调用了 resolve , f3 进入 PromiseJobs 队列，f4 需要等到 f3 的执行结果, 所以进入临时队列</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">PromiseJobs</span> = [f3];</span><br><span class="line"><span class="title class_">PromiseFulfillReactions</span> = [f2, f4];</span><br></pre></td></tr></table></figure>

<p><strong>f1 执行结束, 可以得知 f1 返回了 undefined, 等价于 resolve(undefined)</strong>. f1 有了结果, 所以 f2 进入 PromiseJobs 队列.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">PromiseJobs</span> = [f3, f2];</span><br><span class="line"><span class="title class_">PromiseFulfillReactions</span> = [f4];</span><br></pre></td></tr></table></figure>

<p>又开始执行 PromiseJobs 中的任务。</p>
<p>f3 出队执行, 输出 2<br>f3 执行完毕, 返回 undefined, 因此 f4 进入 PromiseJobs 队列</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">PromiseJobs</span> = [f2, f4];</span><br><span class="line"><span class="title class_">PromiseFulfillReactions</span> = [];</span><br></pre></td></tr></table></figure>

<p>开始执行 PromiseJobs 中的任务</p>
<p>依次执行 f2 f4, 没有产生新的 job, PromiseJobs 变为空, 当前循环结束。</p>
<p>例子二：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>();</span><br><span class="line">    &#125;)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">f3</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">f4</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">f5</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3.1</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1.1</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>();</span><br><span class="line">    &#125;)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">f6</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">resolve</span>();</span><br><span class="line">        &#125;)</span><br><span class="line">          .<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">f7</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">          &#125;)</span><br><span class="line">          .<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">f8</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">f9</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">f10</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出: 0 1 1.1 2 3 3.1 4 5 6</span></span><br></pre></td></tr></table></figure>

<p>Promise 在创建时, 直接调用了 resolve, 所以 f1 进入 PromiseJobs 队列. PromiseJobs &#x3D; [f1]<br>f2 需要等待 f1 的执行结果才能进入 PromiseJobs 队列中, f10 需要等待 f2, 所以 f2 f10 都进入临时队列. PromiseFulfillReactions &#x3D; [f2, f10]<br>输出 0, js 所有代码执行结束. 开始执行 PromiseJobs 队列中的逻辑</p>
<pre><code>f1 出队并执行, f1 执行过程中, 遇到了新的 Promise, 并直接调用了 resolve, 所以 f3 的状态直接被固定, 进入 PromiseJobs 队列. PromiseJobs = [f3]
f4 和 f5 需要等待 f3 的结果才能入 PromiseJobs 队列. 所以只能进入临时队列. PromiseFulfillReactions = [f2, f10, f4, f5]
f1 逻辑代码执行完毕, 相当于 resolve(undefined) , f2 进入 PromiseJobs 队列.  PromiseJobs = [f3, f2], PromiseFulfillReactions = [f10, f4, f5]. 开始执行 PromiseJobs 队列中的逻辑

f3 出队并执行, 输出 1, 逻辑代码执行完毕, f3 返回 undefined, 因此 f4 进入 PromiseJobs 队列.  PromiseJobs = [f2, f4], PromiseFulfillReactions = [f10, f5]. 开始执行 PromiseJobs 队列中的逻辑

f2 出队并执行, 输出 1.1, 遇到新的 Promise, 新的 Promise 直接调用了 resolve, f6 直接进入 PromiseJobs 队列.  PromiseJobs = [f4, f6], f9 进入临时队列, PromiseFulfillReactions = [f10, f5, f9]
f2 代码执行完毕, 返回 undefined, f10 进入 PromiseJobs , PromiseJobs = [f4, f6, f10], PromiseFulfillReactions = [f5, f9]. 开始执行 PromiseJobs 队列中的逻辑

f4 出队并执行, 输入 2, 返回 undefined, f5 进入 PromiseJobs, PromiseJobs = [f6, f10, f5], PromiseFulfillReactions = [f9]. 开始执行 PromiseJobs 队列中的逻辑

f6 出队并执行, 遇到了新的 Promise, 新的 Promise 直接调用了 resolve, f7 进入 PromiseJobs 队列, PromiseJobs = [f10, f5, f7], f8 进入临时队列.  PromiseFulfillReactions = [f9, f8].
f6 执行完毕, 返回 undefined, f9 进入 PromiseJobs . PromiseJobs = [f10, f5, f7, f9].  PromiseFulfillReactions = [f8]. 开始执行 PromiseJobs 队列中的逻辑

f10 出队并执行, 输出 3, PromiseJobs = [f5, f7, f9], PromiseFulfillReactions = [f8].  开始执行 PromiseJobs 队列中的逻辑

f5 出队并执行, 输出 3.1,  PromiseJobs = [f7, f9], PromiseFulfillReactions = [f8].  开始执行 PromiseJobs 队列中的逻辑

f7 出队并执行, 输入 4, 返回了 undefined, f8 进入 PromiseJobs 队列.  PromiseJobs = [f9, f8], PromiseFulfillReactions = [].  开始执行 PromiseJobs 队列中的逻辑

f9 出队并执行, 输出 5, PromiseJobs = [f8], PromiseFulfillReactions = [], 开始执行 PromiseJobs 队列中的逻辑

f8 出队并执行, 输出 6, PromiseJobs = [], PromiseFulfillReactions = []. 循环结束
</code></pre>
<h2 id="内循环的实现"><a href="#内循环的实现" class="headerlink" title="内循环的实现"></a>内循环的实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queue = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个事件分发器</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">rafx</span>(<span class="params">cb</span>) &#123;</span><br><span class="line">  queue.<span class="title function_">push</span>(cb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">rafx</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0.1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">rafx</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0.2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">rafx</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0.21</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">rafx</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0.3</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">rafx</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0.4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">rafx</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0.5</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cb;</span><br><span class="line"><span class="keyword">while</span> ((cb = queue.<span class="title function_">shift</span>())) &#123;</span><br><span class="line">  <span class="title function_">cb</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出: 0.1 0.2 0.3 0.4 0.5 0.21</span></span><br></pre></td></tr></table></figure>

<p>queue 队列为空时，才结束执行。</p>
<h1 id="事件循环到底是怎么回事"><a href="#事件循环到底是怎么回事" class="headerlink" title="事件循环到底是怎么回事"></a>事件循环到底是怎么回事</h1><p>我们已经知道，单纯依靠 call stask 不能完全覆盖所有代码的执行逻辑，call stask 的代码执行顺序永远都是同步的逻辑。对于许多线程引发的异步逻辑，需要依靠队列机制。<br><img src="https://raw.githubusercontent.com/weilun0510/blog-images/master/2024-02-07/pic.1708327269186.png" alt="pic.1708327269186"><br>每一个异步行为，都有对应的执行队列。</p>
<h2 id="执行队列"><a href="#执行队列" class="headerlink" title="执行队列"></a>执行队列</h2><p>会在一轮循环中，直接执行的队列。如 PromiseJobs 队列。</p>
<h2 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h2><p>不会马上执行，处于等待状态的队列。在 promise 中，有两个临时队列， PromiseFulfilledReactions 与 PromiseRejectedReactions 。<strong>在满足条件后，才会将该队列中的任务，移入到执行队列中</strong>。有的临时队列又被称为事件表 <strong>Event Table，</strong>或注册表。</p>
<p><strong>关于临时队列的理解</strong><br>通常，在代码中，setTimeout，事件 I&#x2F;O，http 请求，都会通过回调的方式编写代码的执行逻辑。<br>例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 点击之后执行的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">d.<span class="property">onclick</span> = foo;</span><br></pre></td></tr></table></figure>

<p>foo 就是回调函数。函调函数里的逻辑不会马上执行，而是要等到条件满足之后才会执行。</p>
<h2 id="执行队列有哪些"><a href="#执行队列有哪些" class="headerlink" title="执行队列有哪些"></a>执行队列有哪些</h2><ul>
<li><strong>scriptJobs</strong>：指的是 script 标签，更顶层的供任务，S 代码执行的起点</li>
<li><strong>rafs</strong>：requestAnimationFrame 对应的队列</li>
<li><strong>UI render</strong>：渲染 UI 的任务队列</li>
<li><strong>ric</strong>：requestIdleCallback 对应的队列</li>
<li><strong>event queue</strong>：I&#x2F;O 事件列队</li>
<li><strong>timer queue：</strong>定时器队列，由 setTimeout&#x2F;setInterval 分发</li>
<li><strong>http queue：</strong>http 队列</li>
<li><strong>PromiseJobs：</strong>Promise 队列，由 p.then 分发</li>
</ul>
<h3 id="宏任务队列与微任务队列"><a href="#宏任务队列与微任务队列" class="headerlink" title="宏任务队列与微任务队列"></a>宏任务队列与微任务队列</h3><p>每个队列都有各自鲜明的特点，如果非要区分这些异步队列是宏任务队列还是微任务队列，那么，除了 PromiseJobs ，其它的都可以理解为宏任务队列。</p>
<h2 id="一轮循环的起点"><a href="#一轮循环的起点" class="headerlink" title="一轮循环的起点"></a>一轮循环的起点</h2><p><strong>同一时间，不会存在两个任务同时执行的情况。</strong><br>UI 渲染也是一个任务，也不会与其它任务同时执行。所以我们常说，UI 渲染与 JS 代码时互斥的关系。</p>
<ul>
<li>我们知道，PromiseJobs 是内循环，所以永远不可能作为一轮循环的起点</li>
<li>UI render 的渲染，由 GUI 线程执行。所以 UI render 队列也不会是一轮循环的起点。</li>
</ul>
<p><em>UI render 队列，是纯粹的渲染任务队列。既然要渲染任务，那必须有分发任务的指令才知道如何渲染。发起一个 http 请求也算是一个指令。</em></p>
<p>除了 PromiseJobs 和 UI render，其他所有任务队列中的任务「称之为 task」，都有可能是一轮循环的起点。</p>
<h2 id="一轮循环完毕的标志"><a href="#一轮循环完毕的标志" class="headerlink" title="一轮循环完毕的标志"></a>一轮循环完毕的标志</h2><p><strong>当次循环所有的执行队列</strong>都清空之后，一轮循环完毕。<strong>一轮循环完毕的标志是最后一个 task 中的内循环 PromiseJobs 队列清空</strong>。</p>
<h2 id="事件循环的顺序"><a href="#事件循环的顺序" class="headerlink" title="事件循环的顺序"></a>事件循环的顺序</h2><p>从 script 开始第一次循环</p>
<ol>
<li>所有能作为起点的队列中的任务，都是进入主线程执行，借助函数调用栈依次执行，等调用栈清空，并且 PromiseJobs 为空，当次任务结束。PromiseJobs 是 task 的内循环</li>
<li>当次任务执行过程中，可能会产生新的任务，这些任务会放入临时队列或者下一次循环（比如定时器任务）的执行队列，当次循环的执行队列是执行一个少一个，直到清空为止。</li>
<li>任务分发时，多半都是进入临时队列，满足条件后，进入执行队列。</li>
<li>下一轮循环从执行队列中的第一个任务开始执行，直到当次执行队列清空为止</li>
<li>多个执行队列之间存在先后关系。raf -&gt; ui render -&gt; [event，http，timer] -&gt; ric</li>
<li>raf | ui render | ric 三个队列中的 task 不会每次循环都执行，他们的执行频率要和刷新率保持一致。因此多次循环中，他们都不会执行「执行队列为空」</li>
</ol>
<h2 id="任务进入执行队列的时机"><a href="#任务进入执行队列的时机" class="headerlink" title="任务进入执行队列的时机"></a>任务进入执行队列的时机</h2><p>以 setTimeout 为例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">onclick</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;s&quot;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5000000000</span>; i++);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;e&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击之后的输出结果</span></span><br><span class="line"><span class="comment">// 先立刻输出 s</span></span><br><span class="line"><span class="comment">// 10s 之后，依次快速输出</span></span><br><span class="line"><span class="comment">// e 0 1 2</span></span><br></pre></td></tr></table></figure>

<p>分析一下<br>setTimeout 执行时，三个 task 进入了临时队列。</p>
<p>但是 for 循环的执行时间非常长，超过了 3 秒，因此，在 for 循环执行的过程当中，定时器线程发现 timer 临时队列中的任务满足了条件，就之间放入到了 timer 执行队列。</p>
<p>等 for 循环结束时，就依次快速输出 e 1 2 3。</p>
<p>再说 setInterval</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">func</span>();</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>当 f1 的执行之间，会将 f1 放入临时队列。然后每隔 100 ms，会将 f1 这个任务重复的放入执行队列中。</p>
<p>这时候会有个问题，如果任务 f1 的执行时间超过 100 ms, 那么一轮循环里，执行队列里必然会多出一个 f1 任务，这就会让本次循环的时间拉长，后面队列的任务就会等待更多时间。</p>
<p>所以在 chrome 中，为了弱化这种情况的影响，timer 队列往往放在最后执行「仅比 ric 早」。</p>
<p>也正是这个原因，我们应该避免使用 setInterval, 不合理的使用可能会造成页面的严重卡顿。</p>
<p>所以我们常常使用 setTimeout 的递归调用方式来取代 setInterval .</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="comment">// 这句代码一定要放在最后</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(fn, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure>

<p>这种递归的方式，每次在 fn 执行完之后，才会 push 一个任务到临时队列中。然后临时队列满足 100 ms 的时间之后推入执行队列。也就是说，执行队列中的任务始终只会有一个，即使 fn 的执行时间超过了 100 ms，那它的影响也仅此而已，不会像 setInterval 那样累加。</p>
<h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>最有，再通过一个例子分析下事件循环的执行顺序。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">s1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line">&#125;, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">s2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    i == <span class="number">99</span> &amp;&amp; <span class="title function_">resolve</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">p1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 1 2 3 4 5 6</span></span><br></pre></td></tr></table></figure>

<p>事件循环从 script 开始, 在主线程, 此时只有 scriptJobs 队列中有任务</p>
<p>遇到第一个 setTimeout 函数, setTimeout 进入函数调用栈, setTimeout 分发一个 task s1 进入临时队列, 但是因为 1ms 时间太短, 因此 s1 直接进入 timer 执行队列, timer &#x3D; [s1], setTimeout 出栈</p>
<p><em>我们可能决定不立刻执行一个函数，而是在某时间之后执行，一般我们成为“调度执行”</em><br><em>因为调度的执行时间太短了，只有 1ms , 因此会立刻进入到执行队列。如果改成 2ms ,就可能不会这么快，就会先进入临时队列</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">s1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line">&#125;, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">s2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 输出: 5 6</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">s1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line">&#125;, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">s2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 输出: 6 5</span></span><br></pre></td></tr></table></figure>

<pre><code>又遇到 setTimeout, setTimeout 进入函数调用栈执行, setTimeout 分发一个 task s2, 因为延迟时间为 0, s2 直接进入 timer 执行队列队列, timer = [s1, s2] setTimeout 出栈

接下来遇到 Promise 的创建, Promise 构造函数进入函数调用栈, Promise 的第一个参数我们称为 executor, executor 会在 Promise 内部直接执行, 所以 executor 进栈,
又遇到 log 函数, log 进栈,输出 1, log 出栈. 在 for 循环时 遇到了 resolve 函数, resolve 进栈执行, Promise 状态被固定. log 进栈, 输出 2, log 出栈, resolve 出栈, executor 出栈, Promise 出栈

Promise 执行完, 接着执行 then 方法, 因此 then 进栈. then 方法时 Promise 的异步分发器. 本来 p1 应该直接进入 Promise 的临时队列, 但是 resolve 已经直接执行过了, 状态被固定, 因此已经知道了该如何执行, 所以 p1 直接进入 PromiseJobs 执行队列.
p1 进入执行队列后, then 执行完毕, 出栈.

然后遇到 log, log 进栈, 输出 3, log 出栈.

到这里, 主线程中的代码执行完毕, 调用栈也被清空了, 因此接下来就要执行 PromiseJobs 内循环. 发现 PromiseJos 队列中有任务, 开始执行 PromiseJobs 队列中的逻辑

p1 出队, 进入调用栈, p1 开始执行, log 进栈, 输出 4, log 出栈. p1 逻辑执行完毕, 出栈. 至此, PromiseJobs 执行队列已经清空, 内循环执行完毕. 当轮产生的 setTimeout 的任务, 应该放在下一轮执行. 至此第一轮循环结束

开始第二轮循环, 发现 timer 执行队列中有任务, s1 出队并进入函数调用栈, log 进栈, 输出 5, log 出栈, s1 出栈, timer = [s2]

s2 出队并进入函数调用栈, log 进栈, 输出 6, log 出栈, s2 出栈. s2 执行完之后, timer 队列也被清空了, 检查发现 PromiseJobs 队列中也没有任务, 所以可执行代码执行完毕, 循环结束
</code></pre>
<h2 id="模拟一个没有临时队列的外循环事件分发器"><a href="#模拟一个没有临时队列的外循环事件分发器" class="headerlink" title="模拟一个没有临时队列的外循环事件分发器"></a>模拟一个没有临时队列的外循环事件分发器</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用数组模拟一个队列</span></span><br><span class="line"><span class="keyword">var</span> tasks = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟一个事件分发器</span></span><br><span class="line"><span class="keyword">var</span> addFn1 = <span class="keyword">function</span> (<span class="params">task</span>) &#123;</span><br><span class="line">  tasks.<span class="title function_">push</span>(task);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行所有的任务</span></span><br><span class="line"><span class="keyword">var</span> flush = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  tasks.<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">task</span>) &#123;</span><br><span class="line">    <span class="title function_">task</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后利用setTimeout/或者其他你认为合适的方式丢入事件循环中</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">flush</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分发任务</span></span><br><span class="line"><span class="title function_">addFn1</span>(<span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;my name is add fn&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">addFn1</span>(<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;my name is foo fn&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>也可以不利用事件循环，而是手动在适当的时机去执行对应的某一个方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用数组模拟一个队列</span></span><br><span class="line"><span class="keyword">var</span> tasks = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟一个事件分发器</span></span><br><span class="line"><span class="keyword">var</span> addFn1 = <span class="keyword">function</span> (<span class="params">task</span>) &#123;</span><br><span class="line">  tasks.<span class="title function_">push</span>(task);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去执行对应的某一个方法</span></span><br><span class="line"><span class="keyword">var</span> dispatch = <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">  tasks.<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.<span class="property">name</span> === name) &#123;</span><br><span class="line">      item.<span class="title function_">handle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// task 只需要多保存一个 name 即可。格式如下</span></span><br><span class="line">demoTask = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;demo&quot;</span>,</span><br><span class="line">  <span class="attr">handle</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;my name is demoTack&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">addFn1</span>(demoTask);</span><br><span class="line"><span class="title function_">dispatch</span>(<span class="string">&quot;demo&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>于是，一个订阅-通知的设计模式就这样实现了。</p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p><strong>为什么要有一轮两轮</strong><br>相当于给一个浏览器一个缓存的时间。告诉浏览器下一轮该执行什么，而不是打他个措手不及。如果没有异步任务，那其实一轮就够了。<br>再回到之前的例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 点击之后执行的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">d.<span class="property">onclick</span> = foo;</span><br></pre></td></tr></table></figure>

<p>从 script 标签开始第一轮循环，给 I&#x2F;O 事件临时队列分发一个 task foo，主线程代码执行完毕，第一次循环结束。</p>
<p>当满足 onclick 条件时，foo 移入 I&#x2F;O 事件队列, 并开始出队执行。</p>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2024/02/07/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>Prev</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
              2024-02-27 22:30:13
            </span>
            
                  <span class="post-tags">
                    <i class="iconfont icon-tags mr-10" title="Tags"></i>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/javascript/" title="javascript">
                        #javascript
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2024/02/07/z%E8%BD%B4%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%99/" target="_self">
                <span>Next</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">Contents</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%BA%8E%E5%BC%82%E6%AD%A5"><span class="toc-text">同步于异步</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E4%B8%AA%E7%BA%BF%E7%A8%8B"><span class="toc-text">五个线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E-UI-render-%E7%B4%A7%E5%AF%86%E7%9B%B8%E5%85%B3%E7%9A%84-raf-ric"><span class="toc-text">与 UI render 紧密相关的 raf&#x2F;ric</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Promise"><span class="toc-text">Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#job"><span class="toc-text">job</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PromiseJobs-%E6%89%A7%E8%A1%8C%E9%98%9F%E5%88%97"><span class="toc-text">PromiseJobs 执行队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81"><span class="toc-text">状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E8%BF%9B%E5%85%A5-PromiseJobs"><span class="toc-text">何时进入 PromiseJobs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PromiseJobs-%E9%98%9F%E5%88%97%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C"><span class="toc-text">PromiseJobs 队列如何执行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">内循环的实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%88%B0%E5%BA%95%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B"><span class="toc-text">事件循环到底是怎么回事</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E9%98%9F%E5%88%97"><span class="toc-text">执行队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B4%E6%97%B6%E9%98%9F%E5%88%97"><span class="toc-text">临时队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E9%98%9F%E5%88%97%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">执行队列有哪些</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E4%B8%8E%E5%BE%AE%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97"><span class="toc-text">宏任务队列与微任务队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%BD%AE%E5%BE%AA%E7%8E%AF%E7%9A%84%E8%B5%B7%E7%82%B9"><span class="toc-text">一轮循环的起点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%BD%AE%E5%BE%AA%E7%8E%AF%E5%AE%8C%E6%AF%95%E7%9A%84%E6%A0%87%E5%BF%97"><span class="toc-text">一轮循环完毕的标志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-text">事件循环的顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E8%BF%9B%E5%85%A5%E6%89%A7%E8%A1%8C%E9%98%9F%E5%88%97%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-text">任务进入执行队列的时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="toc-text">举个例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E4%B8%80%E4%B8%AA%E6%B2%A1%E6%9C%89%E4%B8%B4%E6%97%B6%E9%98%9F%E5%88%97%E7%9A%84%E5%A4%96%E5%BE%AA%E7%8E%AF%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E5%99%A8"><span class="toc-text">模拟一个没有临时队列的外循环事件分发器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%9D%E8%80%83"><span class="toc-text">思考</span></a></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        






  <div id="gitalk-container"></div>

  <script>
    function loadGitalkSuc() {
      const gitalk = new Gitalk({
        clientID: '7f36612d9db1de0ab1f2',
        clientSecret: '3a814ba52ef16148a8790bff7134bd9db6fce9d4',
        repo: 'weilun0510.github.io',
        owner: 'weilun0510',
        admin: ['weilun0510'],
        id: location.pathname,
        distractionFreeMode: false
      })

      gitalk.render('gitalk-container')
    }
  </script>
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js" onload="loadGitalkSuc(this)"></script>
  



      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          
              <a title="github" target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">
                <i class="iconfont icon-github"></i>
              </a>
              
        </li>
        
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © 2024 Oranges</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="搜索...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        

      </div>
    </div>
  </body>
</html>
