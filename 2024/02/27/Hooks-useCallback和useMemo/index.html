<!DOCTYPE html>
<html lang="zh" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="weilun" />
  <!-- Open Graph Description 简短摘要-->
  
  <!-- 用于搜索引擎的文章摘要 -->
  
  
  
  <title>
    
      Hooks-useCallback和useMemo 
      
      
      |
    
     维论
  </title>

  
    <link rel="apple-touch-icon" href="/images/favicon.png">
    <link rel="icon" href="/images/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <!-- 代码块风格 -->
  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/images/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">维论</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">首页</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">归档</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">标签</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">关于</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">Hooks-useCallback和useMemo</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
          2024-02-27 22:30:13
        </span>
        
              <span class="post-tags">
                <i class="iconfont icon-tags mr-10" title="Tags"></i>
                
                <span class="span--tag mr-8">
                  <a href="/tags/hooks/" title="hooks">
                    #hooks
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <p><a name="qr2eI"></a></p>
<h1 id="记忆函数"><a href="#记忆函数" class="headerlink" title="记忆函数"></a>记忆函数</h1><p>在开发实践中，有一种优化手段叫做<strong>记忆函数。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">summation</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sum: &quot;</span>, sum);</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">summation</span>(<span class="number">10</span>);</span><br><span class="line"><span class="title function_">summation</span>(<span class="number">100</span>);</span><br><span class="line"><span class="title function_">summation</span>(<span class="number">100</span>);</span><br><span class="line"><span class="title function_">summation</span>(<span class="number">100</span>);</span><br><span class="line"><span class="title function_">summation</span>(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>这是一个求和函数，每次执行函数都会重新计算结果。当我们重复调用<code>summation(100)</code>时，内部的循环计算是不是有点冗余？因为传入相同的参数，必定得到相同的结果，因此如果传入参数一样，是不是可以不再重复计算直接使用上次的计算结果呢？</p>
<p>是的，利用闭包能够实现我们的目的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// memoFn.jsx</span></span><br><span class="line"><span class="comment">// 初始化一个非正常数字</span></span><br><span class="line"><span class="keyword">let</span> preTarget = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> memoSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">memoSummation</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  <span class="comment">// 传入参数与上次一样，直接返回缓存结果</span></span><br><span class="line">  <span class="keyword">if</span> (prevTarget &gt; <span class="number">0</span> &amp;&amp; prevTarget === target) &#123;</span><br><span class="line">    <span class="keyword">return</span> memoSum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 缓存本次传入的参数</span></span><br><span class="line">  prevTarget = target;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我出现，表示又重新计算了一次&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 缓存本次计算结果</span></span><br><span class="line">  memoSum = sum;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; memoSummation &#125; <span class="keyword">from</span> <span class="string">&quot;./memoFn&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">memoSummation</span>(<span class="number">10</span>);</span><br><span class="line"><span class="title function_">memoSummation</span>(<span class="number">50</span>);</span><br><span class="line"><span class="title function_">memoSummation</span>(<span class="number">100</span>);</span><br><span class="line"><span class="title function_">memoSummation</span>(<span class="number">50</span>);</span><br><span class="line"><span class="title function_">memoSummation</span>(<span class="number">100</span>);</span><br><span class="line"><span class="title function_">memoSummation</span>(<span class="number">100</span>);</span><br><span class="line"><span class="title function_">memoSummation</span>(<span class="number">100</span>);</span><br><span class="line"><span class="title function_">memoSummation</span>(<span class="number">100</span>);</span><br><span class="line"><span class="title function_">memoSummation</span>(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p><code>&#39;我出现，表示又重新计算了一次&#39;</code>只打印了 5 次。</p>
<p>将<code>memoFn.jsx</code>模块用伪代码表示，如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoFn = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> prevTarget = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> memoSum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">memoFn</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="comment">// 传入参数与上次一样，直接返回缓存结果</span></span><br><span class="line">    <span class="keyword">if</span> (prevTarget &gt; <span class="number">0</span> &amp;&amp; prevTarget === target) &#123;</span><br><span class="line">      <span class="keyword">return</span> memoSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存本次传入的参数</span></span><br><span class="line">    prevTarget = target;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我出现，表示又重新计算了一次&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">      sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 缓存本次计算结果</span></span><br><span class="line">    memoSum = sum;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> memoSummation = memoFn;</span><br></pre></td></tr></table></figure>

<p><strong>hooks 中的记忆函数</strong><br />hooks 提供的 api 中，大多都有记忆功能，例如：</p>
<ul>
<li>useState</li>
<li>useEffect</li>
<li>useCallback</li>
<li>useMemo</li>
<li>useLayoutEffect</li>
<li>useReducer</li>
<li>useRef</li>
</ul>
<p>这里主要讲<code>useCallback</code>和<code>useMemo</code>。<br><a name="jUPqG"></a></p>
<h1 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h1><p><strong>useMemo 缓存计算结果</strong>。它接收两个参数，第一个参数是回调函数（返回计算结果），第二个参数是依赖项（数组），当依赖项中某一项发生变化时，结果将会重新计算。<br /><code>const memorizedValue = useMemo(() =&gt; &#123;&#125;, deps)</code><br><a name="FSewX"></a></p>
<h1 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h1><p><strong>useCallback 缓存函数。</strong> 他的使用跟<code>useMemo</code>几乎一样，当依赖项中的某一个发生变化时，返回一个新函数。<br /><code>const memorizedFn = useCallback(() =&gt; &#123;&#125;, deps)</code><br><a name="YzPEU"></a></p>
<h3 id="伪代码实现"><a href="#伪代码实现" class="headerlink" title="伪代码实现"></a>伪代码实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * useCallback 简易实现（不考虑多个useCallbacks的情况）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> memoizedState = [];</span><br><span class="line"><span class="keyword">let</span> hookIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useCallbacks</span>(<span class="params">callback, nextDeps</span>) &#123;</span><br><span class="line">  <span class="comment">// debugger</span></span><br><span class="line">  <span class="keyword">const</span> prevState = memoizedState[hookIndex];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (prevState) &#123;</span><br><span class="line">    <span class="comment">// 更新</span></span><br><span class="line">    <span class="keyword">let</span> [prevCallback, prevDeps] = prevState;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对比依赖项</span></span><br><span class="line">    <span class="keyword">let</span> same = nextDeps.<span class="title function_">every</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> item === prevDeps[index]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依赖项相同</span></span><br><span class="line">    <span class="keyword">if</span> (same) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;返回旧函数&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> prevCallback;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 首次挂载时 或者 更新时但依赖项不同，都返回新函数</span></span><br><span class="line">  memoizedState[hookIndex] = [callback, nextDeps];</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;返回新函数&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> callback;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useCallbacks;</span><br></pre></td></tr></table></figure>

<p><a name="Vlhn4"></a></p>
<h3 id="useCallback-和-useMemo-的区别"><a href="#useCallback-和-useMemo-的区别" class="headerlink" title="useCallback 和 useMemo 的区别"></a>useCallback 和 useMemo 的区别</h3><ul>
<li>useCallback 缓存的是<code>callback</code>函数本身，useMemo 缓存的是<code>callback</code>函数的计算结果，也可以是一个函数</li>
<li>都是利用闭包缓存计算结果。只有在函数或计算的过程非常复杂时才考虑使用</li>
<li>useCallback&#x2F;useMemo 可以用来优化子组件和当前组件。优化子组件时，可以防止子组件没必要的重复渲染，useCallback 需要配合 React.memo 一起使用，useMemo 不需要；优化当前组件时，useCallback 主要用于某个会多次 re-render 组件中的没有依赖项的函数，useMome 主要用于缓存复杂的计算逻辑。</li>
<li>useCallback(fn, deps) 相等于 useMemo(() &#x3D;&gt; fn, deps)<br><a name="FkkUd"></a></li>
</ul>
<h1 id="是否需要优化"><a href="#是否需要优化" class="headerlink" title="是否需要优化"></a>是否需要优化</h1><p>通过记忆函数的原理，我们应该知道，<strong>创建记忆函数并不是没有代价的，我们需要创建闭包，占用更多的内存，用以解决计算上的冗余</strong>。</p>
<p>对于一个函数组件来说，我们在内部会创建许多函数，是否都有必要使用 useCallback 呢？思考下面代码</p>
<p><strong>useCallback 是否有必要包裹 setCount 函数？</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoAdd = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">setCount</span>(count++);</span><br><span class="line">&#125;, [count]);</span><br></pre></td></tr></table></figure>

<p><strong>存在依赖项时</strong>，如果 memoFn 不作为 props 传给子组件，仅做一个缓存函数的作用，这样是不是也有达到优化效果？</p>
<p>答案是<strong>没必要</strong>。创建函数的消耗很小，依赖项的对比反而有一定的性能开销。</p>
<p>当一个函数执行完毕，就会从函数调用栈被弹出，里面的内存也会被回收。对于函数组件来说也一样，当内部函数执行完毕后也会被释放掉。所以<strong>函数式组件的性能是非常快的。</strong><br />而当我们使用 useCallback 时，由于新增了对闭包的使用，新增了依赖项的对比逻辑，如果盲目使用他们，可能会让组件变得更慢。大多数情况下你不需要使用 useCallback&#x2F;useMemo。</p>
<p>那么，什么时候使用 useCallback 比较合适呢？<br><a name="efa0U"></a></p>
<h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><p>当<strong>函数或计算的过程非常复杂时</strong>，才优先考虑使用<code>useCallback/useMemo</code>。<br><a name="yZ26k"></a></p>
<h3 id="当函数（或子组件）非常复杂时"><a href="#当函数（或子组件）非常复杂时" class="headerlink" title="当函数（或子组件）非常复杂时"></a>当函数（或子组件）非常复杂时</h3><p>默认情况下，父组件的重新渲染会导致子组件也重新渲染。如果子组件的 props 未发生变化时，子组件就没有重新渲染的必要。</p>
<p>所以当函数非常复杂时，我们可以将 useCallbak 的返回值”缓存函数”传给子组件，然后配合子组件使用 React.memo 解决子组件不必要的渲染问题。</p>
<p>案例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useCallback, useMemo &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Button</span> <span class="keyword">from</span> <span class="string">&quot;./Button&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">UseCallback</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count1, setCount1] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [count2, setCount2] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [count3, setCount3] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 未使用useCallback的情况下，handleClickButton1 函数引用每次都会变化</span></span><br><span class="line">  <span class="comment">// 这会破坏子组件 memo 效果</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClickButton1</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setCount1</span>(count1 + <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 缓存函数：只有在依赖项发生改变时，才返回新的函数，否则返回缓存函数</span></span><br><span class="line">  <span class="comment">// 子组件发现onClickButton属性没发生改变，就不会重新渲染，从而达到优化效果</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用useCallback，如果 count2 不变，handleClickButton2 引用不变</span></span><br><span class="line">  <span class="keyword">const</span> handleClickButton2 = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount2</span>(count2 + <span class="number">1</span>);</span><br><span class="line">  &#125;, [count2]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>未使用useCallback<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClickButton</span>=<span class="string">&#123;handleClickButton1&#125;</span>&gt;</span>Button1<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClickButton</span>=<span class="string">&#123;handleClickButton2&#125;</span>&gt;</span>Button2<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Button2 上的on函数使用了useCallback<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">onClickButton</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">            setCount3(count3 + 1);</span></span><br><span class="line"><span class="language-xml">          &#125;&#125;</span></span><br><span class="line"><span class="language-xml">        &gt;</span></span><br><span class="line"><span class="language-xml">          Button3</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>子组件要配合 React.memo 一起使用。</strong><br />Button 子组件，假设这个组件非常复杂</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Button.jsx</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设这个组件非常复杂</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Button</span> = (<span class="params">&#123; onClickButton, children, count &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onClickButton&#125;</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;Math.random()&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;count &amp;&amp; <span class="tag">&lt;<span class="name">span</span>&gt;</span>count: &#123;count&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，useCallback一定要配合React.memo一起使用，否则就是反向优化</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="title class_">Button</span>);</span><br></pre></td></tr></table></figure>

<p><a name="X5CtY"></a></p>
<h3 id="会多次re-render的组件中，且函数没有任何依赖时"><a href="#会多次re-render的组件中，且函数没有任何依赖时" class="headerlink" title="会多次re-render的组件中，且函数没有任何依赖时"></a>会多次<code>re-render</code>的组件中，且函数没有任何依赖时</h3><p>如果某组件一定会多次<code>re-render</code>，且函数没有任何依赖，可以考虑使用 useCallback 降低多次执行带来的重复创建同样方法的负担。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> onChange=&#123;inputChange&#125; /&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inputChange = <span class="title function_">useCallback</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">setValue</span>(e.<span class="property">target</span>.<span class="property">value</span>);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>

<p>同样的场景，如果函数只会渲染一次，那么使用 useCallback 就完全没必要。<br><a name="fKmgS"></a></p>
<h1 id="闭包带来的问题"><a href="#闭包带来的问题" class="headerlink" title="闭包带来的问题"></a>闭包带来的问题</h1><p>通过前面的例子可以知道，<code>handleClickButton2</code>缓存函数仅在 <code>count</code>不变时保持稳定。<br />如果想要<strong>保持</strong><code>handleClickButton2</code><strong>引用一直稳定</strong>，要把依赖项移除，用空数组作为参数，这会<strong>导致访问到的</strong><code>count</code><strong>总是初始值</strong>，逻辑上引发了更大的问题，也就是闭包问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useCallback, useMemo &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Button</span> <span class="keyword">from</span> <span class="string">&quot;./Button&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">UseCallback</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count4, setCount4] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 缓存函数引用保持稳定时状态不更新问题</span></span><br><span class="line">  <span class="keyword">const</span> stableClickFn = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(count4);</span><br><span class="line">    <span class="comment">// 访问到的总是初始值</span></span><br><span class="line">    <span class="title function_">setCount4</span>(count4 + <span class="number">1</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>缓存函数引用保持稳定时状态不更新问题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClickButton</span>=<span class="string">&#123;stableClickFn&#125;</span>&gt;</span>stable button4<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>count 只会更新一次<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>count4: &#123;count4&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想要解决这个问题，可以看<a target="_blank" rel="noopener" href="https://www.yuque.com/weilun2023/nug9kz/dzbws5sqtoqg42g4"><strong>hooks 闭包陷阱</strong></a>中的解决办法。</p>
<p>react 团队为了解决这个问题，准备引入<code>useEvent</code>，它具备以下属性：</p>
<ul>
<li>每次重新渲染时都不会重新创建该函数</li>
<li>该函数将可以访问 props&#x2F;state 的最新值<br><a name="gX2OK"></a></li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>useCallback/useMemo</code>的作用在于利用记忆函数减少无效的<code>re-render</code>，来达到性能优化的作用。记忆函数的原理，是创建闭包，但创建闭包是有代价的，会占用更多的内存，用以解决计算上的冗余。所以我们需要根据场景来权衡是否有必要使用<code>useCallback/useMemo</code>。</p>
<p>参考：<br /><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/56975681">https://zhuanlan.zhihu.com/p/56975681</a><br /><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/MnkycB8D9kCRrsXaLBfgXg">https://mp.weixin.qq.com/s/MnkycB8D9kCRrsXaLBfgXg</a></p>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2024/02/27/Hooks-useState/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>Prev</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
              2024-02-27 22:30:13
            </span>
            
                  <span class="post-tags">
                    <i class="iconfont icon-tags mr-10" title="Tags"></i>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/hooks/" title="hooks">
                        #hooks
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2024/02/27/Hooks-useEvent/" target="_self">
                <span>Next</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">Contents</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%B0%E5%BF%86%E5%87%BD%E6%95%B0"><span class="toc-text">记忆函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#useMemo"><span class="toc-text">useMemo</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#useCallback"><span class="toc-text">useCallback</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">伪代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useCallback-%E5%92%8C-useMemo-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">useCallback 和 useMemo 的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E4%BC%98%E5%8C%96"><span class="toc-text">是否需要优化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">适用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E5%87%BD%E6%95%B0%EF%BC%88%E6%88%96%E5%AD%90%E7%BB%84%E4%BB%B6%EF%BC%89%E9%9D%9E%E5%B8%B8%E5%A4%8D%E6%9D%82%E6%97%B6"><span class="toc-text">当函数（或子组件）非常复杂时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%9A%E5%A4%9A%E6%AC%A1re-render%E7%9A%84%E7%BB%84%E4%BB%B6%E4%B8%AD%EF%BC%8C%E4%B8%94%E5%87%BD%E6%95%B0%E6%B2%A1%E6%9C%89%E4%BB%BB%E4%BD%95%E4%BE%9D%E8%B5%96%E6%97%B6"><span class="toc-text">会多次re-render的组件中，且函数没有任何依赖时</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">闭包带来的问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        






  <div id="gitalk-container"></div>

  <script>
    function loadGitalkSuc() {
      const gitalk = new Gitalk({
        clientID: '7f36612d9db1de0ab1f2',
        clientSecret: '3a814ba52ef16148a8790bff7134bd9db6fce9d4',
        repo: 'weilun0510.github.io',
        owner: 'weilun0510',
        admin: ['weilun0510'],
        id: location.pathname,
        distractionFreeMode: false
      })

      gitalk.render('gitalk-container')
    }
  </script>
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js" onload="loadGitalkSuc(this)"></script>
  



      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          
              <a title="github" target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">
                <i class="iconfont icon-github"></i>
              </a>
              
        </li>
        
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © 2024 Oranges</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="搜索...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        

      </div>
    </div>
  </body>
</html>
